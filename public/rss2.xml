<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ada 的个人博客主页</title>
    <link>https://github.com/Adashuai5/Adashuai5.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>当然我也在扯淡。。</description>
    <pubDate>Wed, 08 Apr 2020 17:11:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>如果让你展示国内各省市疫情数据你会怎么做</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2020/04/09/%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%B1%95%E7%A4%BA%E5%9B%BD%E5%86%85%E5%90%84%E7%9C%81%E5%B8%82%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2020/04/09/%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%B1%95%E7%A4%BA%E5%9B%BD%E5%86%85%E5%90%84%E7%9C%81%E5%B8%82%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A/</guid>
      <pubDate>Wed, 08 Apr 2020 17:10:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2020 年初始至今，冠状病毒肆虐，好在国内疫情已经逐步减少，武汉也解封了，而国外疫情却日益严重，不容乐观。&lt;/p&gt;
&lt;h1 id=&quot;做个可视化地图模拟展示一下疫情&quot;&gt;&lt;a href=&quot;#做个可视化地图模拟展示一下疫情&quot; class=&quot;headerlink&quot; title=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>2020 年初始至今，冠状病毒肆虐，好在国内疫情已经逐步减少，武汉也解封了，而国外疫情却日益严重，不容乐观。</p><h1 id="做个可视化地图模拟展示一下疫情"><a href="#做个可视化地图模拟展示一下疫情" class="headerlink" title="做个可视化地图模拟展示一下疫情"></a>做个可视化地图模拟展示一下疫情</h1><p>我们可以看到，各大 APP 都有实时显示全国乃至世界的疫情数据的地图表，那么它们是如何实现的呢？</p><p>让我们以中国为例，实现一下展示效果。由于平时用 Vue 较多，可视化框架之前在项目中用过 echarts，就用这两个来演示。（注：本次数据都是随机生成，非官方真实数据）</p><p>用 vue-cli 快速搭建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-echarts-map-china</span><br></pre></td></tr></table></figure><p>引入 echarts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add echarts -D</span><br></pre></td></tr></table></figure><h1 id="如何展示中国各省数据"><a href="#如何展示中国各省数据" class="headerlink" title="如何展示中国各省数据"></a>如何展示中国各省数据</h1><p>ProvinceChart.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;chart&quot; ref=&quot;chart&quot; style=&quot;width: 100%; height: 800px&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>我们首先需要给 echarts 一个容器</p><h2 id="引用-js-json-地图数据"><a href="#引用-js-json-地图数据" class="headerlink" title="引用 js/json 地图数据"></a>引用 js/json 地图数据</h2><p>echats 内置了 china.js 和 china.json 及其省市地图包，china.js 引入即可使用 china.json 需要注册到 echarts，两种方式任选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import echarts from &quot;echarts&quot;;</span><br><span class="line">import &quot;echarts/theme/macarons&quot;; // echarts 主题</span><br><span class="line"></span><br><span class="line">// 1. china.js 直接使用</span><br><span class="line">import china from &quot;echarts/map/js/china&quot;;</span><br><span class="line"></span><br><span class="line">// 2. china.json 需注册</span><br><span class="line">import china from &quot;echarts/map/json/china&quot;;</span><br><span class="line">echarts.registerMap(&quot;china&quot;, china);</span><br></pre></td></tr></table></figure><h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &quot;chart&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      chart: null</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    if (!this.chart) &#123;</span><br><span class="line">      this.drawChinaMap();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    if (!this.chart) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    this.chart.dispose();</span><br><span class="line">    this.chart = null;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    drawChinaMap()&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="drawChinaMap-方法详解"><a href="#drawChinaMap-方法详解" class="headerlink" title="drawChinaMap 方法详解"></a>drawChinaMap 方法详解</h2><p>首先找到我们的容器用 echarts.init() 初始化 echarts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.chart = echarts.init(document.querySelector(&quot;.chart&quot;), &quot;macarons&quot;);</span><br><span class="line">this.chart.setOption(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过 setOption 传入我们需要设定的选项参数</p><h3 id="图表类型及参数"><a href="#图表类型及参数" class="headerlink" title="图表类型及参数"></a>图表类型及参数</h3><p>最主要的是设置图表类型了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">series: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;数据&quot;,</span><br><span class="line">    type: &quot;map&quot;,</span><br><span class="line">    mapType: &quot;china&quot;, // 对应我们注册好的 &quot;china&quot;</span><br><span class="line">    roam: true, // 是否可缩放</span><br><span class="line">    label: &#123; // 文本标签</span><br><span class="line">      normal: &#123;</span><br><span class="line">        show: true //省份名称</span><br><span class="line">      &#125;,</span><br><span class="line">      emphasis: &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 地图默认样式</span><br><span class="line">    itemStyle: &#123;</span><br><span class="line">      normal: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        areaColor: &quot;#CECECE&quot;,</span><br><span class="line">        borderColor: &quot;#FCFCFC&quot;,</span><br><span class="line">        borderWidth: &quot;1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      emphasis: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        areaColor: &quot;#C8A5DF&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: [</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最重要的是 34 个省份的数据，这里我们模拟一下（注意格式和 name 是固定的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">data: [</span><br><span class="line">  &#123; name: &quot;北京&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;天津&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;上海&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;重庆&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;河北&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;河南&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;云南&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;辽宁&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;黑龙江&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;湖南&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;安徽&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;山东&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;新疆&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;江苏&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;浙江&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;江西&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;湖北&quot;, value: 9999 &#125;,</span><br><span class="line">  &#123; name: &quot;广西&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;甘肃&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;山西&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;内蒙古&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;陕西&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;吉林&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;福建&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;贵州&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;广东&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;青海&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;西藏&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;四川&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;宁夏&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;海南&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;台湾&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;香港&quot;, value: Math.round(Math.random() * 1000) &#125;,</span><br><span class="line">  &#123; name: &quot;澳门&quot;, value: Math.round(Math.random() * 1000) &#125;</span><br><span class="line">] //数据</span><br></pre></td></tr></table></figure><p>其他选项设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">backgroundColor: &quot;#FFFFFF&quot;,</span><br><span class="line">title: &#123;</span><br><span class="line">  text: &quot;全国省市地图大数据&quot;,</span><br><span class="line">  subtext: &quot;虚构数据&quot;,</span><br><span class="line">  x: &quot;center&quot;</span><br><span class="line">&#125;,</span><br><span class="line">tooltip: &#123;</span><br><span class="line">  trigger: &quot;item&quot;</span><br><span class="line">&#125;,</span><br><span class="line">toolbox: &#123; // 右侧复位下载</span><br><span class="line">  show: true,</span><br><span class="line">  orient: &quot;vertical&quot;,</span><br><span class="line">  right: &quot;20&quot;,</span><br><span class="line">  top: &quot;center&quot;,</span><br><span class="line">  feature: &#123;</span><br><span class="line">    mark: &#123; show: true &#125;,</span><br><span class="line">    restore: &#123; show: true &#125;,</span><br><span class="line">    saveAsImage: &#123; show: true &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 左侧小导航图标</span><br><span class="line">visualMap: &#123;</span><br><span class="line">  show: true,</span><br><span class="line">  x: &quot;left&quot;,</span><br><span class="line">  y: &quot;center&quot;,</span><br><span class="line">  splitList: [</span><br><span class="line">    &#123; start: 10000 &#125;,</span><br><span class="line">    &#123; start: 1000, end: 9999 &#125;,</span><br><span class="line">    &#123; start: 500, end: 999 &#125;,</span><br><span class="line">    &#123; start: 100, end: 499 &#125;,</span><br><span class="line">    &#123; start: 10, end: 99 &#125;,</span><br><span class="line">    &#123; start: 0, end: 9 &#125;</span><br><span class="line">  ],</span><br><span class="line">  color: [</span><br><span class="line">    &quot;#a50026&quot;,</span><br><span class="line">    &quot;#d73027&quot;,</span><br><span class="line">    &quot;#f46d43&quot;,</span><br><span class="line">    &quot;#fdae61&quot;,</span><br><span class="line">    &quot;#fee090&quot;,</span><br><span class="line">    &quot;#ffffbf&quot;,</span><br><span class="line">    &quot;#f0f0f0&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下:"></a>效果如下:</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-0c7418f37ceb6971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="如何展示中国各市数据"><a href="#如何展示中国各市数据" class="headerlink" title="如何展示中国各市数据"></a>如何展示中国各市数据</h1><p>如果要展示各市单独数据较为简单，只需要把地图和对应数据变成省即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import hubei from &quot;echarts/map/json/province/hubei&quot;;</span><br><span class="line">echarts.registerMap(&quot;hubei&quot;, hubei);</span><br><span class="line"></span><br><span class="line">series:[</span><br><span class="line">  ...</span><br><span class="line">  mapType: &quot;hubei&quot;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>你还可以做到点击省切换成市的效果，网上也有相应教程，实现方法也简单，这里不作详细介绍。</p><p>但是我想要看整个中国地图下的市的疫情情况怎么办？</p><h2 id="合并省市地图"><a href="#合并省市地图" class="headerlink" title="合并省市地图"></a>合并省市地图</h2><p>由于官方只提供了中国地图和省市分开的地图 json 或 js 包，而没有合并在一起的，我们没有现成的数据。</p><p>然而我注意到，china 和各省的 json 包只是 features 不同，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-5c6107fee246ffc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">china.features = [...new Set([...china.features, ...hubei.features])];</span><br></pre></td></tr></table></figure><p>最终，这种方法被我放弃了，原因如下：</p><ol><li>视觉效果差：</li></ol><p>如下图，有字根本看不清，没字也会很密集</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2373ab19d5bcda27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="2"><li>渲染效果差：</li></ol><p>目前只实现了一个省，可预见的是加上所有省份数据量很大（features 长度最终会是 533 ），渲染会卡顿</p><ol start="3"><li>有引入延迟问题：</li></ol><p>由于需要将 34 个省 JSON 包分别引入后合并到 china 内部，通常 echarts 组件已经渲染完毕</p><h2 id="使用中国地图配合市散点图"><a href="#使用中国地图配合市散点图" class="headerlink" title="使用中国地图配合市散点图"></a>使用中国地图配合市散点图</h2><p>我找到官方提供的<a href="https://www.echartsjs.com/examples/en/editor.html?c=doc-example/scatter-visualMap-piecewise" target="_blank" rel="noopener">scatter-visualMap-piecewise</a>示例，感觉这种方式也能满足我的要求，且呈现效果更好</p><h3 id="选项变化"><a href="#选项变化" class="headerlink" title="选项变化"></a>选项变化</h3><p>与原选项主要区别是 series 使用 scatter 散点类型，同时引入 geo 地理坐标系组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">geo: &#123;</span><br><span class="line">  map: &quot;china&quot;,</span><br><span class="line">  roam: true,</span><br><span class="line">  itemStyle: &#123;</span><br><span class="line">    // 定义样式</span><br><span class="line">    normal: &#123;</span><br><span class="line">      // 普通状态下的样式</span><br><span class="line">      areaColor: &quot;#323c48&quot;,</span><br><span class="line">      borderColor: &quot;#111&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    emphasis: &#123;</span><br><span class="line">      // 高亮状态下的样式</span><br><span class="line">      areaColor: &quot;#2a333d&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">series: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;确诊人数&quot;,</span><br><span class="line">    symbolSize: 10, // 点坐标大小</span><br><span class="line">    type: &quot;scatter&quot;,</span><br><span class="line">    data: this.cityData,</span><br><span class="line">    coordinateSystem: &quot;geo&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其数据格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// this.cityData</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#123; name: &quot;武汉&quot;, value: [114.31, 30.52, 8888 &#125;], // &#123; name: name, value: [x, y, value&#125;],</span><br><span class="line">  &#123; name: &quot;大庆&quot;, value: [125.03, 46.58, Math.round(Math.random() * 100) &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例小问题"><a href="#示例小问题" class="headerlink" title="示例小问题"></a>示例小问题</h3><p>需要注意的是，官方示例中 tooltip 的悬浮数据是有问题的，它不是 pm2.5 的 value，而是极坐标的 Y 的值</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d5ecbc146da32560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>想要其展示正确的数据需要在 tooltip 设置 formatter：以回调函数格式设置数据为 data 的第三个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tooltip: &#123;</span><br><span class="line">  trigger: &quot;item&quot;,</span><br><span class="line">  formatter: params =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      params.seriesName + &quot;&lt;br/&gt;&quot; + params.name + &quot;:&quot; + params.data.value[2]</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果如下"><a href="#最终效果如下" class="headerlink" title="最终效果如下:"></a>最终效果如下:</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-9928e061111e0303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们完成了国内各省市疫情模拟数据的可视化，如果想要展示世界数据也是类似，只需找到相应地图包替换，并处理对应数据即可。echarts 提供了完整的文档，按需查找对应选项即可完成相应需求，当然还有很多不错的库和方法等我们去探究。</p><p>如需查看完整代码：<a href="https://github.com/Adashuai5/vue-echarts-map-china">请点这里</a></p><p>看到这里了，不点个赞吗 😄！</p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2020/04/09/%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%B1%95%E7%A4%BA%E5%9B%BD%E5%86%85%E5%90%84%E7%9C%81%E5%B8%82%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【前端路由】这可能是最容易理解的一篇了</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2020/04/04/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2020/04/04/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/</guid>
      <pubDate>Sat, 04 Apr 2020 08:45:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;随着 ajax 的流行，异步数据请求体验极具提升，用户得以在不刷新浏览器的情况下进行页面交互，而异步交互体验的更高级版本就是 SPA —— 单页应用。&lt;/p&gt;
&lt;p&gt;单页应用不仅仅是在页面交互时无刷新，连页面跳转都是无刷新的，为了实现单页应用，就有了&lt;strong&gt;前端路由
        
      
      </description>
      
      <content:encoded><![CDATA[<p>随着 ajax 的流行，异步数据请求体验极具提升，用户得以在不刷新浏览器的情况下进行页面交互，而异步交互体验的更高级版本就是 SPA —— 单页应用。</p><p>单页应用不仅仅是在页面交互时无刷新，连页面跳转都是无刷新的，为了实现单页应用，就有了<strong>前端路由</strong>。</p><h1 id="常用的两种模式"><a href="#常用的两种模式" class="headerlink" title="常用的两种模式"></a>常用的两种模式</h1><p>类似于服务端路由解析对应的 url 路径，返回对应的页面/资源的方式，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。</p><p>这样自然 url 每次变化的时候，都会造成页面的刷新。</p><p>那么在改变 url 的情况下，如何保证页面的不刷新？</p><h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.xxx.com/#/login</span><br></pre></td></tr></table></figure><p>这种 # 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。</p><h3 id="为什么改变-hash-不刷新页面？——URL的井号‘-’"><a href="#为什么改变-hash-不刷新页面？——URL的井号‘-’" class="headerlink" title="为什么改变 hash 不刷新页面？——URL的井号‘#’"></a>为什么改变 hash 不刷新页面？——<a href="http://www.ruanyifeng.com/blog/2011/03/url_hash.html" target="_blank" rel="noopener">URL的井号‘#’</a></h3><blockquote><p>‘#’ 代表网页中的一个位置，它后面的字符，就是该位置的标识符，它只对浏览器有用，服务器不识别，因此 HTTP 请求不会包含 #</p></blockquote><p>(想要请求 url 包含 # ，可使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="noopener">encodeURIComponent()</a><br>进行部分转义)</p><p><strong>改变 hash ，只会让浏览器滚动到相应位置，不会重载网页</strong></p><p>每次 hash 值的变化，会触发 hashchange 事件，通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange" target="_blank" rel="noopener"><code>window.onhashchange</code></a>监听该事件我们就可以检测变化的 hash 值来做相应的页面操作。</p><h3 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h3><p>接下来我们用最简单的代码实现 hash 模式，仅为了解其思想（你可以直接复制到一个 html 上并通过静态服务器如 <a href="https://www.npmjs.com/package/http-server" target="_blank" rel="noopener">http-server</a> 查看）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Hash 路由&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#red&quot;&gt;红色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#green&quot;&gt;绿色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#grey&quot;&gt;灰色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function watchHash() &#123;</span><br><span class="line">        const hash = window.location.hash.slice(1) || &apos;/&apos;;</span><br><span class="line">        switch (hash) &#123;</span><br><span class="line">          case &quot;red&quot;:</span><br><span class="line">            document.body.style.background = &quot;red&quot;;</span><br><span class="line">            break;</span><br><span class="line">          case &quot;green&quot;:</span><br><span class="line">            document.body.style.background = &quot;green&quot;;</span><br><span class="line">            break;</span><br><span class="line">          case &quot;grey&quot;:</span><br><span class="line">            document.body.style.background = &quot;grey&quot;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(&quot;hashchange&quot;, watchHash, false);</span><br><span class="line">      window.addEventListener(&quot;load&quot;, watchHash, false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="如何实现最基础的前进后退？"><a href="#如何实现最基础的前进后退？" class="headerlink" title="如何实现最基础的前进后退？"></a>如何实现最基础的前进后退？</h4><p>这里我们简单实现一下后退功能，前进思路类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Hash 路由&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#red&quot;&gt;红色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#green&quot;&gt;绿色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#grey&quot;&gt;灰色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;button id=&quot;back&quot; disabled=&quot;true&quot;&gt;后退&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var isGoBack = false;</span><br><span class="line">      const history = [];</span><br><span class="line">      function watchHash() &#123;</span><br><span class="line">        const hash = window.location.hash.slice(1) || &quot;/&quot;;</span><br><span class="line">        // 防止后退时也记录 hash</span><br><span class="line">        if (!isGoBack &amp;&amp; window.location.hash) &#123;</span><br><span class="line">          history.push(window.location.hash);</span><br><span class="line">        &#125;</span><br><span class="line">        back.disabled = history.length &gt; 0 ? false : true;</span><br><span class="line">        console.log(history);</span><br><span class="line">        switch (hash) &#123;</span><br><span class="line">          case &quot;red&quot;:</span><br><span class="line">            document.body.style.background = &quot;red&quot;;</span><br><span class="line">            break;</span><br><span class="line">          case &quot;green&quot;:</span><br><span class="line">            document.body.style.background = &quot;green&quot;;</span><br><span class="line">            break;</span><br><span class="line">          case &quot;grey&quot;:</span><br><span class="line">            document.body.style.background = &quot;grey&quot;;</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            document.body.style.background = &quot;#fff&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        isGoBack = false;</span><br><span class="line">      &#125;</span><br><span class="line">      back.onclick = goBack;</span><br><span class="line">      function goBack() &#123;</span><br><span class="line">        isGoBack = true;</span><br><span class="line">        if (history.length &gt; 0) &#123;</span><br><span class="line">          history.pop(1);</span><br><span class="line">          window.location.hash = history[history.length - 1] || &quot;&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          back.disabled = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(&quot;load&quot;, watchHash, false);</span><br><span class="line">      window.addEventListener(&quot;hashchange&quot;, watchHash, false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>思路就是通过一个数组记录每次 hashchange 事件的 hash 值，点击后退时取出上一次 hash 值覆盖当前页面的 hash。</p><p>需要注意的是需要区别当前 hash 是后退生成（后退时的 hash 变化不应记录）的还是跳转生成，避免重复记录。</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-a0a5b8004805e7da.gif?imageMogr2/auto-orient/strip" alt="image"></p><h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>可以看到，在早期 hash 模式虽然可以实现前端路由，但其后退前进操作就十分麻烦。</p><p>2014 年后，HTML5 引入了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">History</a> API，让我们能够快速访问页面历史。</p><p>其中 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState" target="_blank" rel="noopener">history.pushState()</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState" target="_blank" rel="noopener">history.replaceState()</a> 方法，它们分别可以添加和修改历史记录条目，通过这两个 API 可以改变 url 地址而无须重新加载页面。</p><p>同时还有 popstate 事件：<br>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate" title="window.onpopstate是popstate事件在window对象上的事件处理程序." target="_blank" rel="noopener"><code>window.onpopstate</code></a>可以监听在<strong>浏览器点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法)</strong> 触发的 popstate 事件。</p><p>通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。</p><h3 id="用-history-实现上面-hash-代码"><a href="#用-history-实现上面-hash-代码" class="headerlink" title="用 history 实现上面 hash 代码"></a>用 history 实现上面 hash 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;History 路由&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul id=&quot;ul&quot;&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;/red&quot;&gt;红色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;/green&quot;&gt;绿色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;/grey&quot;&gt;灰色背景&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const path = window.location.pathname;</span><br><span class="line">      history.replaceState(&#123; path: path &#125;, null, path);</span><br><span class="line">      ul.addEventListener(&quot;click&quot;, (e) =&gt; &#123;</span><br><span class="line">        if (e.target.tagName === &quot;A&quot;) &#123;</span><br><span class="line">          e.preventDefault();</span><br><span class="line">          const path = e.target.getAttribute(&quot;href&quot;);</span><br><span class="line">          history.pushState(&#123; path: path &#125;, null, path);</span><br><span class="line">          watchHistory(path);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      function watchHistory() &#123;</span><br><span class="line">        const path = window.location.pathname;</span><br><span class="line">        switch (path) &#123;</span><br><span class="line">          case &quot;/red&quot;:</span><br><span class="line">            document.body.style.background = &quot;red&quot;;</span><br><span class="line">            break;</span><br><span class="line">          case &quot;/green&quot;:</span><br><span class="line">            document.body.style.background = &quot;green&quot;;</span><br><span class="line">            break;</span><br><span class="line">          case &quot;/grey&quot;:</span><br><span class="line">            document.body.style.background = &quot;grey&quot;;</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            document.body.style.background = &quot;#fff&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(&quot;popstate&quot;, watchHistory, false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。</p><p><strong>但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。</strong></p><p>为了避免出现这种情况，history 模式需要服务器的支持，把所有路由都重定向到根页面。</p><h3 id="如何监听-pushState-和-replaceState-的变化"><a href="#如何监听-pushState-和-replaceState-的变化" class="headerlink" title="如何监听 pushState 和 replaceState 的变化"></a>如何监听 pushState 和 replaceState 的变化</h3><p>经过理论及实践我们知道 replaceState()，pushState() 两个 API 不会触发 popstate 监听事件。</p><p>我们可以生成全新的 window 监听事件监听其变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function addListen(type) &#123;</span><br><span class="line">  const source = history[type];</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const event = new Event(type);</span><br><span class="line">    event.arguments = arguments;</span><br><span class="line">    window.dispatchEvent(event);</span><br><span class="line">    return source.apply(this, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">history.pushState = addListen(&quot;pushState&quot;);</span><br><span class="line">history.replaceState = addListen(&quot;replaceState&quot;);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&quot;replaceState&quot;, (e) =&gt; &#123;</span><br><span class="line">  console.log(&quot;我监听了 replaceState&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">window.addEventListener(&quot;pushState&quot;, (e) =&gt; &#123;</span><br><span class="line">  console.log(&quot;我监听了 pushState&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h1><ol><li>无 # 的  history 模式更自然</li><li>history 模式需要 IE9 以上，相对于 hash 模式的 IE8 兼容性差</li><li>history 模式需服务器端配合，反过来说 hash 模式不支持服务端渲染</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是前端路由的 hash 和 history 两种模式的主要原理及实现思路了，如果你觉得不错，别忘了点个赞😄！</p><hr><p>本文参考：</p><p><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b" target="_blank" rel="noopener">面试官: 你了解前端路由吗?</a></p><p><a href="https://juejin.im/post/5e85cb8151882573c66cf63f" target="_blank" rel="noopener">阿里P7：你了解路由吗？</a></p><p><a href="https://github.com/webfansplz/article/issues/1">[实践系列]前端路由</a></p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2020/04/04/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue 项目编译时间过长问题</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2019/11/14/Vue-%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E9%97%AE%E9%A2%98/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2019/11/14/Vue-%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Thu, 14 Nov 2019 15:20:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;随着公司项目不断增大，项目打包编译的时长也不断增加，尤其是在公司使用 jenkins 自动化部署以后更甚。由此我想到此问题可能是引入依赖过多而造成。通过 google 查看分析，终于找到相关问题并初步实践，方法如下：&lt;/p&gt;
&lt;h1 id=&quot;1-使用-webpack-bun
        
      
      </description>
      
      <content:encoded><![CDATA[<p>随着公司项目不断增大，项目打包编译的时长也不断增加，尤其是在公司使用 jenkins 自动化部署以后更甚。由此我想到此问题可能是引入依赖过多而造成。通过 google 查看分析，终于找到相关问题并初步实践，方法如下：</p><h1 id="1-使用-webpack-bundle-analyzer-分析项目外部依赖大小"><a href="#1-使用-webpack-bundle-analyzer-分析项目外部依赖大小" class="headerlink" title="1. 使用 webpack-bundle-analyzer 分析项目外部依赖大小"></a>1. 使用 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 分析项目外部依赖大小</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br><span class="line"># Yarn</span><br><span class="line">yarn add -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p>官网显示的使用方法，需要在 webpack.config.js 内配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new BundleAnalyzerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们的项目是使用 vue-cli3 搭建，其内置 webpack （也就是没有 webpack.config.js），因此我们找到 vue.config.js 使用如下代码引入插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    //*//</span><br><span class="line">    config</span><br><span class="line">      .plugin(&apos;webpack-bundle-analyzer&apos;)</span><br><span class="line">      .use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行 yarn serve 会执行 webpack-bundle-analyzer 插件 BundleAnalyzerPlugin 的默认功能</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-ab4bc9a1e287601a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>serve 完成，会在浏览器自动生成依赖大小分析的可视化网站，如下图所示</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-a23b069d62f17087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="2-使用-webpack-外部扩展-externals"><a href="#2-使用-webpack-外部扩展-externals" class="headerlink" title="2. 使用 webpack 外部扩展(externals)"></a>2. 使用 <a href="https://www.webpackjs.com/configuration/externals/" target="_blank" rel="noopener">webpack 外部扩展(externals)</a></h1><blockquote><p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖</p></blockquote><h2 id="使用前打包时间"><a href="#使用前打包时间" class="headerlink" title="使用前打包时间"></a>使用前打包时间</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-db8c24d4609bb95c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用 externals 过滤我们希望通过 cdn 引入的依赖，同样在 vue.config.js 配置：<br>（注意所需依赖的别名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    //*//</span><br><span class="line">    config.externals(&#123;</span><br><span class="line">      &apos;axios&apos;: &apos;axios&apos;,</span><br><span class="line">      &apos;vue&apos;: &apos;Vue&apos;,</span><br><span class="line">      &apos;vue-router&apos;: &apos;VueRouter&apos;,</span><br><span class="line">      &apos;vuex&apos;: &apos;Vuex&apos;,</span><br><span class="line">      &apos;element-ui&apos;: &apos;ELEMENT&apos; // 注意此处要全大写且 Vue.use(ELEMENT)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后在项目 index.html 文件内引入对应 cdn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- public/index.html --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.3.3/index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>需要将原来的引用注释，我们的过滤才能生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Vue from "vue"</span></span><br><span class="line"><span class="comment">// import Element from "element-ui"</span></span><br></pre></td></tr></table></figure><p>再次使用 webpack-bundle-analyzer，可以看到依赖的体积减少了近 10 M</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-8519d5ef027b6035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="使用后打包时间"><a href="#使用后打包时间" class="headerlink" title="使用后打包时间"></a>使用后打包时间</h2><p>再次打包，打包时间缩短了近一倍</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-7df2a6d82c804a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>未完待续。。。</p><hr><p>参考<br><a href="https://juejin.im/post/5d7266495188256f3b09baea" target="_blank" rel="noopener">vue-cli3 使用 webpack-bundle-analyzer 插件</a>;<br><a href="https://www.jianshu.com/p/b2fe6aebe691" target="_blank" rel="noopener">解决 vue 打包 wendor 过大的问题</a></p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2019/11/14/Vue-%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Flutter 踩坑之环境搭建</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2019/06/12/Flutter-%E8%B8%A9%E5%9D%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2019/06/12/Flutter-%E8%B8%A9%E5%9D%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <pubDate>Wed, 12 Jun 2019 14:09:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;对于前端来说， flutter 学习的难点在于环境搭建&lt;br&gt;在跟随 &lt;a href=&quot;https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5
        
      
      </description>
      
      <content:encoded><![CDATA[<p>对于前端来说， flutter 学习的难点在于环境搭建<br>在跟随 <a href="https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwindows%E7%89%88" target="_blank" rel="noopener">技术胖：Flutter 开发环境搭建 Windows 版</a> 时<br>出现以下 ✗ Android license status unknown 的环境错误</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-e2d7d273e10ecf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 <a href="https://github.com/flutter/flutter/issues/16025#">✗ Android license status unknown.</a> issue 内找到答案</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>在下方路径内找到 sdkmanager.bat 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Android\Sdk\tools\bin</span><br></pre></td></tr></table></figure><p>在以下区域加入如 17 行所示 set JAVA_HOME=”xxx\Android Studio\jre”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 @rem Add default JVM options here. You can also use JAVA_OPTS and SDKMANAGER_OPTS to pass JVM options to this script.</span><br><span class="line">+17 set JAVA_HOME=&quot;F:\ada\Android Studio\jre&quot; // 你的 Android Studio\jre 路径</span><br><span class="line">18 set DEFAULT_JVM_OPTS=&quot;-Dcom.android.sdklib.toolsdir=%~dp0\..&quot;</span><br></pre></td></tr></table></figure><p>再运行 flutter doctor</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-49d92a6402463517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据提示运行 flutter doctor –android-licenses<br>然后一直 y 就可以了</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d8ba85e97083d9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以继续愉快得学习拉！</p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2019/06/12/Flutter-%E8%B8%A9%E5%9D%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7 个实用的 JavaScript 小技巧（译文）</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2019/05/06/7%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84-JavaScript-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2019/05/06/7%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84-JavaScript-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/</guid>
      <pubDate>Mon, 06 May 2019 15:52:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。&lt;br&gt;原文：&lt;a href=&quot;https://davidwalsh.name/javascript-tricks&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。<br>原文：<a href="https://davidwalsh.name/javascript-tricks" target="_blank" rel="noopener">7 Useful JavaScript Tricks</a><br>以下为译文：<br>和其他编程语言一样，JavaScript 有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 JavaScript 小技巧！</p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>获取<a href="https://davidwalsh.name/array-unique" target="_blank" rel="noopener">数组的唯一值</a>可能比你想象中要简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var j = [...new Set([1, 2, 3, 3])]</span><br><span class="line">&gt;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>我超爱（…）和 Set！</p><h1 id="数组配合布尔"><a href="#数组配合布尔" class="headerlink" title="数组配合布尔"></a>数组配合布尔</h1><p>要从一个数组中<a href="https://davidwalsh.name/array-boolean" target="_blank" rel="noopener">过滤 falsy 值</a>？你或许不知道有这种技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myArray</span><br><span class="line">    .map(item =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // 记得 return</span><br><span class="line">    &#125;)</span><br><span class="line">    // 摆脱这些空值</span><br><span class="line">    .filter(Boolean);</span><br></pre></td></tr></table></figure><p>只需传递 Boolean 就能去除这些 falsy 值！</p><h1 id="创建一个空的对象"><a href="#创建一个空的对象" class="headerlink" title="创建一个空的对象"></a>创建一个空的对象</h1><p>当然，似乎你可以通过像 {} 这样来创建一个空对象，但实际上这样创建的对象还是有__proto__、hasOwnProperty 以及其他对象的方法。下面是一种<a href="https://davidwalsh.name/object-create-null" target="_blank" rel="noopener">创造一个纯对象</a>的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let dict = Object.create(null);</span><br><span class="line"></span><br><span class="line">// dict.__proto__ === &quot;undefined&quot;</span><br><span class="line">// 在你添加动态属性之前为空</span><br></pre></td></tr></table></figure><p>这个对象上绝对没有你没有放入的键或方法！</p><h1 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h1><p>JavaScript <a href="https://davidwalsh.name/merge-objects" target="_blank" rel="noopener">合并多个对象</a>的需求由来已久，尤其是当我们创建带有选项的类和小部件时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &apos;David Walsh&apos;, gender: &apos;Male&apos; &#125;;</span><br><span class="line">const tools = &#123; computer: &apos;Mac&apos;, editor: &apos;Atom&apos; &#125;;</span><br><span class="line">const attributes = &#123; handsomeness: &apos;Extreme&apos;, hair: &apos;Brown&apos;, eyes: &apos;Blue&apos; &#125;;</span><br><span class="line"></span><br><span class="line">const summary = &#123;...person, ...tools, ...attributes&#125;;</span><br><span class="line">/*</span><br><span class="line">Object &#123;</span><br><span class="line">  &quot;computer&quot;: &quot;Mac&quot;,</span><br><span class="line">  &quot;editor&quot;: &quot;Atom&quot;,</span><br><span class="line">  &quot;eyes&quot;: &quot;Blue&quot;,</span><br><span class="line">  &quot;gender&quot;: &quot;Male&quot;,</span><br><span class="line">  &quot;hair&quot;: &quot;Brown&quot;,</span><br><span class="line">  &quot;handsomeness&quot;: &quot;Extreme&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;David Walsh&quot;,</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>这三个点让任务变得简单多了！</p><h1 id="强制函数传参"><a href="#强制函数传参" class="headerlink" title="强制函数传参"></a>强制函数传参</h1><p>能够为函数参数设置默认值是 JavaScript 的一个很棒的补充。请查看这个技巧，<a href="[https://davidwalsh.name/javascript-function-parameters](https://davidwalsh.name/javascript-function-parameters">要求为给定的参数</a>&gt;)传递值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const isRequired = () =&gt; &#123; throw new Error(&apos;param is required&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;;</span><br><span class="line"></span><br><span class="line">// 由于没给 hello() 传 name，该代码会报错</span><br><span class="line"></span><br><span class="line">// 下面代码也会报错</span><br><span class="line">hello(undefined);</span><br><span class="line"></span><br><span class="line">// 来看看符合要求的写法</span><br><span class="line">hello(null);</span><br><span class="line">hello(&apos;David&apos;);</span><br></pre></td></tr></table></figure><p>这是一些下一级验证和 JavaScript 用法</p><h1 id="解构别名"><a href="#解构别名" class="headerlink" title="解构别名"></a>解构别名</h1><p><a href="https://davidwalsh.name/destructuring-alias" target="_blank" rel="noopener">解构赋值</a>是一个非常受欢迎的 JavaScript 升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; x: 1 &#125;;</span><br><span class="line"></span><br><span class="line">// Grabs obj.x as &#123; x &#125;</span><br><span class="line">const &#123; x &#125; = obj;</span><br><span class="line"></span><br><span class="line">// Grabs obj.x as &#123; otherName &#125;</span><br><span class="line">const &#123; x: otherName &#125; = obj;</span><br></pre></td></tr></table></figure><p>有效避免了与现有变量的命名冲突！</p><h1 id="获取查询字符串参数"><a href="#获取查询字符串参数" class="headerlink" title="获取查询字符串参数"></a>获取查询字符串参数</h1><p>多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 <a href="[https://davidwalsh.name/query-string-javascript](https://davidwalsh.name/query-string-javascript">URLSearchParams</a>&gt;) API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设 &quot;?post=1234&amp;action=edit&quot;</span><br><span class="line"></span><br><span class="line">var urlParams = new URLSearchParams(window.location.search);</span><br><span class="line"></span><br><span class="line">console.log(urlParams.has(&apos;post&apos;)); // true</span><br><span class="line">console.log(urlParams.get(&apos;action&apos;)); // &quot;edit&quot;</span><br><span class="line">console.log(urlParams.getAll(&apos;action&apos;)); // [&quot;edit&quot;]</span><br><span class="line">console.log(urlParams.toString()); // &quot;?post=1234&amp;action=edit&quot;</span><br><span class="line">console.log(urlParams.append(&apos;active&apos;, &apos;1&apos;)); // &quot;?post=1234&amp;action=edit&amp;active=1&quot;</span><br></pre></td></tr></table></figure><p>是不是比之前简单多了。</p><p>这些年 JavaScript 已经发生了很大的变化，但我最喜欢的部分是我们现在看到 JavaScript 语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需!</p><p>你最喜欢的 JavaScript 技巧是什么呢？</p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2019/05/06/7%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84-JavaScript-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 算法之旅</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/</guid>
      <pubDate>Thu, 28 Mar 2019 14:19:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。&lt;br&gt;于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。&lt;/p&gt;
&lt;h2 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。<br>于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twoSum = function (nums, target) &#123;</span><br><span class="line">    let newArr = []</span><br><span class="line">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        for (let j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">            if (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                newArr.push(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr</span><br><span class="line">&#125;</span><br><span class="line">// 164 ms</span><br></pre></td></tr></table></figure><h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeDuplicates = function (nums) &#123;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] === nums[i + 1]) &#123;</span><br><span class="line">            nums.splice(i, 1)</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length</span><br><span class="line">&#125;</span><br><span class="line">// 376 ms</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue 全家桶学习总结</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Tue, 26 Feb 2019 15:32:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;h2 id=&quot;Vue-js-特性：&quot;&gt;&lt;a href=&quot;#Vue-js-特性：&quot; class=&quot;headerlink&quot; title=&quot;V
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue-js-特性："><a href="#Vue-js-特性：" class="headerlink" title="Vue.js 特性："></a>Vue.js 特性：</h2><p>1.轻量级<br>2.双向数据绑定<br>3.指令<br>4.组件化</p><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVC =&gt; MVP =&gt; MVVM</span><br><span class="line">// 视图层和数据层的双向绑定</span><br><span class="line">View &lt;=&gt; ViewModel &lt;=&gt; Model</span><br></pre></td></tr></table></figure><ol><li><p>MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p></li><li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。</p></li><li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p></li></ol><h2 id="Vue-js-的优点"><a href="#Vue-js-的优点" class="headerlink" title="Vue.js 的优点"></a>Vue.js 的优点</h2><ol><li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li><li>易用灵活高效</li></ol><h2 id="Vue-组件是什么"><a href="#Vue-组件是什么" class="headerlink" title="Vue 组件是什么"></a>Vue 组件是什么</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p><h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。</p><h2 id="Vue-脚手架-3-x-以上版本使用"><a href="#Vue-脚手架-3-x-以上版本使用" class="headerlink" title="Vue 脚手架 3.x 以上版本使用"></a>Vue 脚手架 3.x 以上版本使用</h2><p>全局安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p><p>快速原型开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure></p><p>创建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br><span class="line">// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令</span><br><span class="line">winpty vue.cmd create hello-world</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hello-world</span><br></pre></td></tr></table></figure><p>Project setup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure></p><p>（以下命令 run 可以省略）<br>Compiles and hot-reloads for development<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run serve</span><br></pre></td></tr></table></figure></p><p>Compiles and minifies for production<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build</span><br></pre></td></tr></table></figure></p><p>Run your tests<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run test</span><br></pre></td></tr></table></figure></p><p>Lints and fixes files<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run lint</span><br></pre></td></tr></table></figure></p><h2 id="Vuecli-3-x-版本-上图-与-2-x-初始化目录对比"><a href="#Vuecli-3-x-版本-上图-与-2-x-初始化目录对比" class="headerlink" title="Vuecli 3.x 版本(上图)与 2.x 初始化目录对比"></a>Vuecli 3.x 版本(上图)与 2.x 初始化目录对比</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官方的路由管理器。<br>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure></p><p>引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p><p>配置路由文件，并在vue实例中注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes:[&#123;</span><br><span class="line">    path:&apos;/user/:userId&apos;, // 指定要跳转的路径</span><br><span class="line">    name: &apos;user&apos;, // 命名路由，便于路由跳转</span><br><span class="line">    component: User// 指定要跳转的组件</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">const User = (&#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="确定视图加载的位置"><a href="#确定视图加载的位置" class="headerlink" title="确定视图加载的位置"></a>确定视图加载的位置</h2><p>视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      components: &#123; // 同个路由，多个视图就需要多个组件,components 要有(s)</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现路由跳转"><a href="#实现路由跳转" class="headerlink" title="实现路由跳转"></a>实现路由跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; // 路由导航到 /user/123</span><br></pre></td></tr></table></figure><p>等同于代码调用 router.push()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 编程式导航</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) // 路由导航到 /user/123</span><br></pre></td></tr></table></figure></p><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>使用动态路由参数，以冒号开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p><p>当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应路由参数变化"><a href="#响应路由参数变化" class="headerlink" title="响应路由参数变化"></a>响应路由参数变化</h2><p>动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 <strong>watch</strong> (监测变化) $route 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者使用 <strong>beforeRouteUpdate</strong> 导航守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don&apos;t forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由组件参数解耦"><a href="#路由组件参数解耦" class="headerlink" title="路由组件参数解耦"></a>路由组件参数解耦</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: [&apos;id&apos;],</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/user/:id&apos;,</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>props 有三种模式：布尔模式、对象模式、函数模式</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h2 id="在-store-存储-内有下列核心概念"><a href="#在-store-存储-内有下列核心概念" class="headerlink" title="在 store (存储)内有下列核心概念"></a>在 store (存储)内有下列核心概念</h2><p><strong>State()：核心原始数据</strong> 展示<br><strong>Getter：计算属性，根据所依赖的数据的变化计算自身变化</strong> 存储<br><strong>Mutation(转变)：提交 mutation 才能改变存储状态</strong><br><strong>Action：</strong>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br><strong>Module：可以将将 store 分割</strong><br>一般放在 state 文件夹下</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="vuex状态管理的流程"><a href="#vuex状态管理的流程" class="headerlink" title="vuex状态管理的流程"></a>vuex状态管理的流程</h2><p>view =&gt; actions =&gt; mutations =&gt; state =&gt; view</p><h2 id="核心概念详解"><a href="#核心概念详解" class="headerlink" title="核心概念详解"></a>核心概念详解</h2><h3 id="state：记录所有公共数据状态的对象"><a href="#state：记录所有公共数据状态的对象" class="headerlink" title="state：记录所有公共数据状态的对象"></a>state：记录所有公共数据状态的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 组件如何获取</span><br><span class="line">this.$store.state.XXX</span><br><span class="line">// 此处的 XXX 是 state 内定义的数据状态的键名</span><br></pre></td></tr></table></figure><h3 id="mutations：包含所有-操作数据状态的方法-的对象"><a href="#mutations：包含所有-操作数据状态的方法-的对象" class="headerlink" title="mutations：包含所有 操作数据状态的方法 的对象"></a>mutations：包含所有 操作数据状态的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 组件如何调用</span><br><span class="line">this.$store.commit(XXX)</span><br><span class="line">// 此处的 XXX是 mutations 中定义的方法名</span><br></pre></td></tr></table></figure><h3 id="actions：用于操作-mutations-内方法-的对象"><a href="#actions：用于操作-mutations-内方法-的对象" class="headerlink" title="actions：用于操作 mutations 内方法 的对象"></a>actions：用于操作 mutations 内方法 的对象</h3><p>actions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 如何调用</span><br><span class="line">this.$store.dispatch(XXX)</span><br><span class="line">// 此处的XXX是你在actions中定义的方法名</span><br></pre></td></tr></table></figure></p><h3 id="getters：定义状态内容的方法-的对象"><a href="#getters：定义状态内容的方法-的对象" class="headerlink" title="getters：定义状态内容的方法 的对象"></a>getters：定义状态内容的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters.XXX</span><br><span class="line">// 此处的XXX是你在getters里定义的方法名</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。<br>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API拦截</li><li>请求和响应转换</li><li>请求和响应数据取消</li><li>请求自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li><li><p>引入加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure></li><li><p>将axios全局挂载到 Vue 原型上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置全局-axios-默认值"><a href="#设置全局-axios-默认值" class="headerlink" title="设置全局 axios 默认值"></a>设置全局 axios 默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置基础路径，一般为后端接口线上地址根路径</span><br><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">// 设置默认 token</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">// 默认 POST 请求</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure><h2 id="axios-的-url-有两种传递参数的形式"><a href="#axios-的-url-有两种传递参数的形式" class="headerlink" title="axios 的 url 有两种传递参数的形式"></a>axios 的 url 有两种传递参数的形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一种 对象形式</span><br><span class="line">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">// 如果只有一个参数，可以省略 params</span><br><span class="line">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">  &#125;) </span><br><span class="line">--------------------------------- </span><br><span class="line">// 第二种 形式</span><br><span class="line">this.$http.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure><h2 id="POST-传递数据有两种格式："><a href="#POST-传递数据有两种格式：" class="headerlink" title="POST 传递数据有两种格式："></a>POST 传递数据有两种格式：</h2><ol><li>form­-data ?page=1&amp;limit=48</li><li>x-­www­-form-­urlencoded { page: 1,limit: 10 }</li></ol><p><strong>在 axios 中，post 请求接收的参数必须是 form­-data 形式<br>如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$http.post(&apos;/user&apos;, qs.stringify(&#123;</span><br><span class="line">   ID: 12345</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="实现增删改查"><a href="#实现增删改查" class="headerlink" title="实现增删改查"></a>实现增删改查</h2><h3 id="发起-GET-请求：查"><a href="#发起-GET-请求：查" class="headerlink" title="发起 GET 请求：查"></a>发起 GET 请求：查</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;) // 下同省略</span><br><span class="line"></span><br><span class="line">//发起一个user请求，参数为给定的ID</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then((response) =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="发起-POST-请求：增"><a href="#发起-POST-请求：增" class="headerlink" title="发起 POST 请求：增"></a>发起 POST 请求：增</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">  firstName: &apos;yuanda&apos;,</span><br><span class="line">  lastName: &apos;zhou&apos;</span><br><span class="line">&#125;)</span><br><span class="line">  .then((response) =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[,config])</span><br><span class="line">axios.delete(url[,config]) // 删除</span><br><span class="line">axios.head(url[,config])</span><br><span class="line">axios.options(url[,config])</span><br><span class="line">axios.post(url[,data[,config]])</span><br><span class="line">axios.put(url[,data[,config]]) // 改</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure><p>PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</p><h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class="line">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class="line">        //两个请求现在都完成</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><p>axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。</p><h2 id="拦截器-interceptors"><a href="#拦截器-interceptors" class="headerlink" title="拦截器 interceptors"></a>拦截器 interceptors</h2><p>你可以在<strong>请求</strong>或者<strong>响应</strong>被 then 或者 catch 处理之前对他们进行拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加一个请求拦截器</span><br><span class="line">axios.interceptors.request.use(function(config)&#123;</span><br><span class="line">    //在请求发送之前做一些事</span><br><span class="line">    return config;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //当出现请求错误是做一些事</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加一个返回拦截器</span><br><span class="line">axios.interceptors.response.use(function(response)&#123;</span><br><span class="line">    //对返回的数据进行一些处理</span><br><span class="line">    return response;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //对返回的错误进行一些处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用 eject 移除拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p><h2 id="axios-如何获取-cookie"><a href="#axios-如何获取-cookie" class="headerlink" title="axios 如何获取 cookie"></a>axios 如何获取 cookie</h2><p>axios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">axios.defaults.withCredentials=true; //让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure></p><p>通过js原生接口来获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let allCookies = document.cookie</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从「从输入 URL 到页面加载」谈及Web性能优化</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sat, 29 Dec 2018 06:09:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;如何理解-Web-性能优化&quot;&gt;&lt;a href=&quot;#如何理解-Web-性能优化&quot; class=&quot;headerlink&quot; title=&quot;如何理解 Web 性能优化&quot;&gt;&lt;/a&gt;如何理解 Web 性能优化&lt;/h1&gt;&lt;p&gt;事实上就是用户觉得页面加载很快，用户从输入 URL（
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="如何理解-Web-性能优化"><a href="#如何理解-Web-性能优化" class="headerlink" title="如何理解 Web 性能优化"></a>如何理解 Web 性能优化</h1><p>事实上就是用户觉得页面加载很快，用户从输入 URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。<br>对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。</p><h1 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h1><p>一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。</p><h2 id="0-缓存"><a href="#0-缓存" class="headerlink" title="0. 缓存"></a>0. 缓存</h2><p>当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。</p><h2 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1. DNS 查询"></a>1. DNS 查询</h2><p>DNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>DNS 查询完成之前，浏览器无法从服务器下载任何数据。</p><h3 id="优化方案：减少-DNS-查询"><a href="#优化方案：减少-DNS-查询" class="headerlink" title="优化方案：减少 DNS 查询"></a>优化方案：减少 DNS 查询</h3><h4 id="1-1-DNS-缓存"><a href="#1-1-DNS-缓存" class="headerlink" title="1.1 DNS 缓存"></a>1.1 DNS 缓存</h4><p>ISP、局域网、操作系统、浏览器等都会有相应的 DNS 缓存机制。</p><h4 id="1-2-减少页面的唯一域名"><a href="#1-2-减少页面的唯一域名" class="headerlink" title="1.2 减少页面的唯一域名"></a>1.2 减少页面的唯一域名</h4><p>因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。</p><h2 id="2-TCP-连接"><a href="#2-TCP-连接" class="headerlink" title="2. TCP 连接"></a>2. TCP 连接</h2><p>经典的三次握手和四次挥手，不展开赘述。<br>简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。</p><h2 id="3-HTTP-请求及响应"><a href="#3-HTTP-请求及响应" class="headerlink" title="3. HTTP 请求及响应"></a>3. HTTP 请求及响应</h2><p>直接讲优化策略</p><h4 id="3-1-避免不必要的重定向"><a href="#3-1-避免不必要的重定向" class="headerlink" title="3.1 避免不必要的重定向"></a>3.1 避免不必要的重定向</h4><blockquote><p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问<a href="http://astrology.yahoo.com/astrology将被301重定向到" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology将被301重定向到</a> <a href="http://astrology.yahoo.com/astrology/（注意末尾的" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/（注意末尾的</a> /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。</p></blockquote><h4 id="3-2-Cookie"><a href="#3-2-Cookie" class="headerlink" title="3.2 Cookie"></a>3.2 Cookie</h4><h5 id="3-2-1-减少-Cookie-大小"><a href="#3-2-1-减少-Cookie-大小" class="headerlink" title="3.2.1 减少 Cookie 大小"></a>3.2.1 减少 Cookie 大小</h5><p>每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：</p><ul><li>去除不必要的 Cookie；</li><li>尽量压缩 Cookie 大小；</li><li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li><li>设置合适的过期时间。</li></ul><h5 id="3-2-2-静态资源使用无-Cookie-域名"><a href="#3-2-2-静态资源使用无-Cookie-域名" class="headerlink" title="3.2.2 静态资源使用无 Cookie 域名"></a>3.2.2 静态资源使用无 Cookie 域名</h5><p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p><h4 id="3-3-添加-Expires-或-Cache-Control-响应头"><a href="#3-3-添加-Expires-或-Cache-Control-响应头" class="headerlink" title="3.3 添加 Expires 或 Cache-Control 响应头"></a>3.3 添加 Expires 或 Cache-Control 响应头</h4><p>HTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。</p><ul><li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li><li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li></ul><h4 id="3-4-配置-Etag"><a href="#3-4-配置-Etag" class="headerlink" title="3.4 配置 Etag"></a>3.4 配置 Etag</h4><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p><h4 id="3-5-使用-Gzip"><a href="#3-5-使用-Gzip" class="headerlink" title="3.5 使用 Gzip"></a>3.5 使用 Gzip</h4><p>使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。<br>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。<br>从 HTTP/1.1 开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>需要注意的是，已经压缩过的内容如图片和 PDF 不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。</p><h3 id="值得一提"><a href="#值得一提" class="headerlink" title="值得一提"></a>值得一提</h3><p>HTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。<br>另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：</p><h4 id="3-6-延迟加载（懒加载）"><a href="#3-6-延迟加载（懒加载）" class="headerlink" title="3.6 延迟加载（懒加载）"></a>3.6 延迟加载（懒加载）</h4><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p><ul><li>非首屏使用的数据、样式、脚本、图片等；</li><li>用户交互时才会显示的内容。</li></ul><p>遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。</p><blockquote><p>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者 type 属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p></blockquote><h4 id="3-7-预加载"><a href="#3-7-预加载" class="headerlink" title="3.7 预加载"></a>3.7 预加载</h4><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p><h2 id="4-浏览器解析渲染页面"><a href="#4-浏览器解析渲染页面" class="headerlink" title="4. 浏览器解析渲染页面"></a>4. 浏览器解析渲染页面</h2><p>响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。</p><h4 id="4-1-写对文档类型声明-lt-DOCTYPE-html-gt"><a href="#4-1-写对文档类型声明-lt-DOCTYPE-html-gt" class="headerlink" title="4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;"></a>4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;</h4><blockquote><p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">怪异模式(兼容模式)</a>”的渲染模式。“<code>&amp;lt;!DOCTYPE html&amp;gt;</code>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></blockquote><p>不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。</p><h4 id="4-2-CSS-放在-lt-head-gt-中"><a href="#4-2-CSS-放在-lt-head-gt-中" class="headerlink" title="4.2 CSS 放在 &lt;head&gt; 中"></a>4.2 CSS 放在 &lt;head&gt; 中</h4><p>把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。<br>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。<br>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的 HEAD 部分能让页面看起来加载地更快。</p><h4 id="4-2-把脚本放在页面底部"><a href="#4-2-把脚本放在页面底部" class="headerlink" title="4.2 把脚本放在页面底部"></a>4.2 把脚本放在页面底部</h4><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。<br>一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：</p><ul><li>defer 属性；</li><li>HTML5 新增的 async 属性。</li></ul><h4 id="4-3-使用外部-JavaScript-和-CSS"><a href="#4-3-使用外部-JavaScript-和-CSS" class="headerlink" title="4.3 使用外部 JavaScript 和 CSS"></a>4.3 使用外部 JavaScript 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p><h4 id="4-4-合并和压缩-JS-CSS-等文件"><a href="#4-4-合并和压缩-JS-CSS-等文件" class="headerlink" title="4.4 合并和压缩 JS/CSS 等文件"></a>4.4 合并和压缩 JS/CSS 等文件</h4><p>通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。</p><h4 id="4-5-减少-DOM-操作和使用高效的事件处理"><a href="#4-5-减少-DOM-操作和使用高效的事件处理" class="headerlink" title="4.5 减少 DOM 操作和使用高效的事件处理"></a>4.5 减少 DOM 操作和使用高效的事件处理</h4><ul><li>缓存已经访问过的元素；</li><li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li><li>操作 className，而不是多次读写 style；</li><li>避免使用 JavaScript 修复布局；</li><li>减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；</li><li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li></ul><h4 id="4-6-图片优化"><a href="#4-6-图片优化" class="headerlink" title="4.6 图片优化"></a>4.6 图片优化</h4><p>如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。</p><h4 id="4-7-使用-CND"><a href="#4-7-使用-CND" class="headerlink" title="4.7 使用 CND"></a>4.7 使用 CND</h4><blockquote><p>内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p></blockquote><p>动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。<br>深入阅读 <a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noopener">从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p><p>本文参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51" target="_blank" rel="noopener">前端性能优化之雅虎 35 条军规</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入 URL 到页面加载发生了什么？</a><br>MDN<br>维基百科</p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>优先级 和 CSS 预处理</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <pubDate>Thu, 20 Dec 2018 14:30:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前言扯淡&quot;&gt;&lt;a href=&quot;#前言扯淡&quot; class=&quot;headerlink&quot; title=&quot;前言扯淡&quot;&gt;&lt;/a&gt;前言扯淡&lt;/h2&gt;&lt;p&gt;前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言扯淡"><a href="#前言扯淡" class="headerlink" title="前言扯淡"></a>前言扯淡</h2><p>前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。<br>需求是最好的学习 API 的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。</p><h2 id="首先是-优先级"><a href="#首先是-优先级" class="headerlink" title="首先是 优先级"></a>首先是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">优先级</a></h2><p>链接是文档，优先级主要是指 CSS 属性的优先级。</p><blockquote><p>浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。</p></blockquote><p>简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 id=&quot;title&quot; class=&quot;title&quot; style=&quot;color: yellow;&quot;&gt;优先级&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--优先级显示为 pink--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title&#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#title&#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: pink !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先级如何确定："><a href="#优先级如何确定：" class="headerlink" title="优先级如何确定："></a>优先级如何确定：</h4><p>选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）</p><ol><li><strong>ID 选择器</strong>（例如, #title）</li><li><strong>类选择器</strong>（class selectors） (例如,.title)，<strong>属性选择器</strong>（attributes selectors）（例如, [type=”radio”]），<strong>伪类</strong>（pseudo-classes）（例如, :hover）</li><li><strong>类型选择器</strong>（type selectors）（例如, h1）和 <strong>伪元素</strong>（pseudo-elements）（例如, ::before）</li></ol><p><strong>通配选择符</strong>（universal selector）(*), <strong>关系选择符</strong>（combinators） (+, &gt;, ~, ‘ ‘) 和 <strong>否定伪类</strong>（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。<br>给元素添加的<strong>内联样式</strong> (例如, style=”color: yellow;”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。<br><strong>!important</strong> 是例外，此声明将覆盖任何其他声明，技术上!important 与优先级无关，但它与它直接相关。</p><h4 id="如何利用优先级"><a href="#如何利用优先级" class="headerlink" title="如何利用优先级"></a>如何利用优先级</h4><ol><li>选择器越具体，优先级越高。</li><li>相同优先级情况下，后面的样式覆盖前面的。</li><li>!important 最特殊，有他的声明最优先，但应该避免使用。</li></ol><p>上面内容均来自 MDN，也就是我给的链接，还有很多如<code>无视DOM树中的距离</code>等没有记录。大家还是直接看 MDN 为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看 MDN 文档而收获一些东西，便是此文的意义了。<br>扩展阅读 <a href="https://github.com/jincdream/jincdream.github.io/issues/14">真正理解”CSS 选择器的优先级”</a></p><h2 id="CSS-预处理（预编译）"><a href="#CSS-预处理（预编译）" class="headerlink" title="CSS 预处理（预编译）"></a>CSS 预处理（预编译）</h2><p>当面试关问我知不知道 CSS 预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。</p><hr><p>(以下内容来自 <a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="noopener">再谈 CSS 预处理器</a>)<br>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li></ul><p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。</p><hr><p>这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度 EFE 的文档比我写肯定高到不知道哪里去了。<br>那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;&#125;</span><br><span class="line">div&gt;ul&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&gt;a&#123;&#125;</span><br></pre></td></tr></table></figure><p>本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。</p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈 JS 继承</title>
      <link>https://github.com/Adashuai5/Adashuai5.github.io/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/</link>
      <guid>https://github.com/Adashuai5/Adashuai5.github.io/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/</guid>
      <pubDate>Fri, 02 Nov 2018 12:38:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;什么是继承&quot;&gt;&lt;a href=&quot;#什么是继承&quot; class=&quot;headerlink&quot; title=&quot;什么是继承&quot;&gt;&lt;/a&gt;什么是继承&lt;/h1&gt;&lt;p&gt;根据维基百科解释，可以简单概括为：&lt;br&gt;继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h1><p>根据维基百科解释，可以简单概括为：<br>继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。</p><h1 id="JS-里的原型继承模型"><a href="#JS-里的原型继承模型" class="headerlink" title="JS 里的原型继承模型"></a>JS 里的原型继承模型</h1><p>JS：不好意思，我没有类。（即使是 ES6 中的类也是语法糖）<br>JavaScript 是基于原型实现面向对象的，那么在 JS 中，面向对象概念中的继承自然也是基于原型。</p><blockquote><p>当谈到继承时，JavaScript  只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象  ，层层向上直到一个对象的原型对象为  <code>null</code>。根据定义，<code>null</code>  没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p></blockquote><blockquote><p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <strong>Object</strong> 的实例。</p></blockquote><p>有关原型之前写过博客<a href="https://www.jianshu.com/p/93441c4e8f48" target="_blank" rel="noopener">JavaScript 原型和原型链</a>，对理解下面内容有帮助。<br>虽然没有传统语言意义上的类，但是 JS 语言 使用构造函数生成对象，实现面向对象程序设计。</p><h1 id="说了这么多，JS-中的继承到底是什么？"><a href="#说了这么多，JS-中的继承到底是什么？" class="headerlink" title="说了这么多，JS 中的继承到底是什么？"></a>说了这么多，JS 中的继承到底是什么？</h1><p><strong>可以简单理解为：两次的原型搜索就是继承。<br>数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。</strong></p><p>接下来我们用代码实现一下继承</p><h2 id="1-使用-prototype-实现继承"><a href="#1-使用-prototype-实现继承" class="headerlink" title="1. 使用 prototype 实现继承"></a>1. 使用 prototype 实现继承</h2><p><strong>prototype 的作用：为构造函数内添加实例对象之间的共有属性</strong></p><p><strong>明确 JS 内的继承</strong><br>以下面代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个 人类</span><br><span class="line">function Human(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 给所有 人类 添加一个 跑 的共有属性</span><br><span class="line">Human.prototype.run = function()&#123;</span><br><span class="line">  console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">  return undefined</span><br><span class="line">&#125;</span><br><span class="line">// 构造一个 男人类</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Human.call(this, name)</span><br><span class="line">  this.gender = &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 所有 男人 都有好战属性</span><br><span class="line">Man.prototype.fight = function()&#123;</span><br><span class="line">  console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到名为 ada 的人只有 name、gender 和 fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。<br><strong>目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。</strong><br>根据我原型知识的博客里面的内容我们知道，我们可以直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype.__proto__ = Human.prototype</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到  Man  指向了  Human  而不是直接指向  Object，ada2  继承了来自  Human  的  run  属性</p><p><strong>但是在实际编程过程中直接操作 </strong> proto <strong> 这个非标准但许多浏览器（IE 不支持）实现的属性是不规范的。</strong></p><p>那怎么办？<br>new 可不可以？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype = new Human()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>直接用上述代码不行，因为在 new 的过程中，虽然 new 内部实现了 <code>Man.prototype.__proto__ = Human.prototype</code> 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined</strong></p><p>那么我们只要避免这个过程中 Human 执行就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;&#125;</span><br><span class="line">a.prototype = Human.prototype</span><br><span class="line">Man.prototype = new a()</span><br></pre></td></tr></table></figure><p>通过上面三行代码，即实现了没有内部执行空函数的 new</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-ES6-实现继承"><a href="#2-ES6-实现继承" class="headerlink" title="2. ES6 实现继承"></a>2. ES6 实现继承</h2><p>上面代码的 ES6 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES6 写法</span><br><span class="line">class Human&#123;</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         this.name = name</span><br><span class="line">     &#125;</span><br><span class="line">     run()&#123;</span><br><span class="line">         console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">         return undefined</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class Man extends Human&#123; // extends 实现上述继承过程</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         super(name) // 调用构造函数:&apos;超类&apos;</span><br><span class="line">         this.gender = &apos;男&apos;</span><br><span class="line">     &#125;</span><br><span class="line">     fight()&#123;</span><br><span class="line">         console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>JS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。</p><blockquote><p>原型继承模型本身实际上比经典模型更强大</p></blockquote><hr><p>感谢阅读<br>本文仅供个人学习使用</p><p>部分参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p>]]></content:encoded>
      
      <comments>https://github.com/Adashuai5/Adashuai5.github.io/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
