<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ada 的个人博客主页</title>
    <link>http://adashuai5.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>当然我也在扯淡。。</description>
    <pubDate>Wed, 12 Jun 2019 14:11:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Flutter 踩坑之环境搭建</title>
      <link>http://adashuai5.com/2019/06/12/Flutter-%E8%B8%A9%E5%9D%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <guid>http://adashuai5.com/2019/06/12/Flutter-%E8%B8%A9%E5%9D%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <pubDate>Wed, 12 Jun 2019 14:09:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;对于前端来说， flutter 学习的难点在于环境搭建&lt;br&gt;在跟随 &lt;a href=&quot;https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5
        
      
      </description>
      
      <content:encoded><![CDATA[<p>对于前端来说， flutter 学习的难点在于环境搭建<br>在跟随 <a href="https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwindows%E7%89%88" target="_blank" rel="noopener">技术胖：Flutter开发环境搭建Windows版</a> 时<br>出现以下 ✗ Android license status unknown 的环境错误</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-e2d7d273e10ecf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 <a href="https://github.com/flutter/flutter/issues/16025#" target="_blank" rel="noopener">✗ Android license status unknown.</a> issue 内找到答案</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>在下方路径内找到 sdkmanager.bat 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Android\Sdk\tools\bin</span><br></pre></td></tr></table></figure></p><p>在以下区域加入如 17 行所示 set JAVA_HOME=”xxx\Android Studio\jre”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 @rem Add default JVM options here. You can also use JAVA_OPTS and SDKMANAGER_OPTS to pass JVM options to this script.</span><br><span class="line">+17 set JAVA_HOME=&quot;F:\ada\Android Studio\jre&quot; // 你的 Android Studio\jre 路径</span><br><span class="line">18 set DEFAULT_JVM_OPTS=&quot;-Dcom.android.sdklib.toolsdir=%~dp0\..&quot;</span><br></pre></td></tr></table></figure></p><p>再运行 flutter doctor</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-49d92a6402463517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据提示运行 flutter doctor –android-licenses<br>然后一直 y 就可以了</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d8ba85e97083d9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以继续愉快得学习拉！</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/06/12/Flutter-%E8%B8%A9%E5%9D%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>7个实用的 JavaScript 小技巧（译文）</title>
      <link>http://adashuai5.com/2019/05/06/7%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84-JavaScript-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/</link>
      <guid>http://adashuai5.com/2019/05/06/7%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84-JavaScript-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/</guid>
      <pubDate>Mon, 06 May 2019 15:52:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。&lt;br&gt;原文：&lt;a href=&quot;https://davidwalsh.name/javascript-tricks&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。<br>原文：<a href="https://davidwalsh.name/javascript-tricks" target="_blank" rel="noopener">7 Useful JavaScript Tricks</a><br>以下为译文：<br>和其他编程语言一样，JavaScript 有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 JavaScript 小技巧！</p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>获取<a href="https://davidwalsh.name/array-unique" target="_blank" rel="noopener">数组的唯一值</a>可能比你想象中要简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var j = [...new Set([1, 2, 3, 3])]</span><br><span class="line">&gt;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>我超爱（…）和 Set！</p><h1 id="数组配合布尔"><a href="#数组配合布尔" class="headerlink" title="数组配合布尔"></a>数组配合布尔</h1><p>要从一个数组中<a href="https://davidwalsh.name/array-boolean" target="_blank" rel="noopener">过滤falsy值</a>？你或许不知道有这种技巧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myArray</span><br><span class="line">    .map(item =&gt; &#123;</span><br><span class="line">        // ... </span><br><span class="line">        // 记得 return</span><br><span class="line">    &#125;)</span><br><span class="line">    // 摆脱这些空值</span><br><span class="line">    .filter(Boolean);</span><br></pre></td></tr></table></figure></p><p>只需传递 Boolean 就能去除这些 falsy 值！</p><h1 id="创建一个空的对象"><a href="#创建一个空的对象" class="headerlink" title="创建一个空的对象"></a>创建一个空的对象</h1><p>当然，似乎你可以通过像 {} 这样来创建一个空对象，但实际上这样创建的对象还是有__proto__、hasOwnProperty 以及其他对象的方法。下面是一种<a href="https://davidwalsh.name/object-create-null" target="_blank" rel="noopener">创造一个纯对象</a>的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let dict = Object.create(null);</span><br><span class="line"></span><br><span class="line">// dict.__proto__ === &quot;undefined&quot;</span><br><span class="line">// 在你添加动态属性之前为空</span><br></pre></td></tr></table></figure></p><p>这个对象上绝对没有你没有放入的键或方法！</p><h1 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h1><p>JavaScript <a href="https://davidwalsh.name/merge-objects" target="_blank" rel="noopener">合并多个对象</a>的需求由来已久，尤其是当我们创建带有选项的类和小部件时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &apos;David Walsh&apos;, gender: &apos;Male&apos; &#125;;</span><br><span class="line">const tools = &#123; computer: &apos;Mac&apos;, editor: &apos;Atom&apos; &#125;;</span><br><span class="line">const attributes = &#123; handsomeness: &apos;Extreme&apos;, hair: &apos;Brown&apos;, eyes: &apos;Blue&apos; &#125;;</span><br><span class="line"></span><br><span class="line">const summary = &#123;...person, ...tools, ...attributes&#125;;</span><br><span class="line">/*</span><br><span class="line">Object &#123;</span><br><span class="line">  &quot;computer&quot;: &quot;Mac&quot;,</span><br><span class="line">  &quot;editor&quot;: &quot;Atom&quot;,</span><br><span class="line">  &quot;eyes&quot;: &quot;Blue&quot;,</span><br><span class="line">  &quot;gender&quot;: &quot;Male&quot;,</span><br><span class="line">  &quot;hair&quot;: &quot;Brown&quot;,</span><br><span class="line">  &quot;handsomeness&quot;: &quot;Extreme&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;David Walsh&quot;,</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>这三个点让任务变得简单多了！</p><h1 id="强制函数传参"><a href="#强制函数传参" class="headerlink" title="强制函数传参"></a>强制函数传参</h1><p>能够为函数参数设置默认值是 JavaScript 的一个很棒的补充。请查看这个技巧，<a href="[https://davidwalsh.name/javascript-function-parameters](https://davidwalsh.name/javascript-function-parameters">要求为给定的参数</a><br>)传递值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const isRequired = () =&gt; &#123; throw new Error(&apos;param is required&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;;</span><br><span class="line"></span><br><span class="line">// 由于没给 hello() 传 name，该代码会报错</span><br><span class="line"></span><br><span class="line">// 下面代码也会报错</span><br><span class="line">hello(undefined);</span><br><span class="line"></span><br><span class="line">// 来看看符合要求的写法</span><br><span class="line">hello(null);</span><br><span class="line">hello(&apos;David&apos;);</span><br></pre></td></tr></table></figure></p><p>这是一些下一级验证和 JavaScript 用法</p><h1 id="解构别名"><a href="#解构别名" class="headerlink" title="解构别名"></a>解构别名</h1><p><a href="https://davidwalsh.name/destructuring-alias" target="_blank" rel="noopener">解构赋值</a>是一个非常受欢迎的 JavaScript 升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; x: 1 &#125;;</span><br><span class="line"></span><br><span class="line">// Grabs obj.x as &#123; x &#125;</span><br><span class="line">const &#123; x &#125; = obj;</span><br><span class="line"></span><br><span class="line">// Grabs obj.x as &#123; otherName &#125;</span><br><span class="line">const &#123; x: otherName &#125; = obj;</span><br></pre></td></tr></table></figure></p><p>有效避免了与现有变量的命名冲突！</p><h1 id="获取查询字符串参数"><a href="#获取查询字符串参数" class="headerlink" title="获取查询字符串参数"></a>获取查询字符串参数</h1><p>多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 <a href="[https://davidwalsh.name/query-string-javascript](https://davidwalsh.name/query-string-javascript">URLSearchParams</a><br>) API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设 &quot;?post=1234&amp;action=edit&quot;</span><br><span class="line"></span><br><span class="line">var urlParams = new URLSearchParams(window.location.search);</span><br><span class="line"></span><br><span class="line">console.log(urlParams.has(&apos;post&apos;)); // true</span><br><span class="line">console.log(urlParams.get(&apos;action&apos;)); // &quot;edit&quot;</span><br><span class="line">console.log(urlParams.getAll(&apos;action&apos;)); // [&quot;edit&quot;]</span><br><span class="line">console.log(urlParams.toString()); // &quot;?post=1234&amp;action=edit&quot;</span><br><span class="line">console.log(urlParams.append(&apos;active&apos;, &apos;1&apos;)); // &quot;?post=1234&amp;action=edit&amp;active=1&quot;</span><br></pre></td></tr></table></figure></p><p>是不是比之前简单多了。</p><p>这些年 JavaScript 已经发生了很大的变化，但我最喜欢的部分是我们现在看到 JavaScript 语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需!</p><p>你最喜欢的 JavaScript 技巧是什么呢？</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/05/06/7%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84-JavaScript-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 算法之旅</title>
      <link>http://adashuai5.com/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/</link>
      <guid>http://adashuai5.com/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/</guid>
      <pubDate>Thu, 28 Mar 2019 14:19:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。&lt;br&gt;于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。&lt;/p&gt;
&lt;h2 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。<br>于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twoSum = function (nums, target) &#123;</span><br><span class="line">    let newArr = []</span><br><span class="line">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        for (let j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">            if (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                newArr.push(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr</span><br><span class="line">&#125;</span><br><span class="line">// 164 ms</span><br></pre></td></tr></table></figure><h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeDuplicates = function (nums) &#123;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] === nums[i + 1]) &#123;</span><br><span class="line">            nums.splice(i, 1)</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length</span><br><span class="line">&#125;</span><br><span class="line">// 376 ms</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue 全家桶学习总结</title>
      <link>http://adashuai5.com/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <guid>http://adashuai5.com/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Tue, 26 Feb 2019 15:32:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;h2 id=&quot;Vue-js-特性：&quot;&gt;&lt;a href=&quot;#Vue-js-特性：&quot; class=&quot;headerlink&quot; title=&quot;V
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue-js-特性："><a href="#Vue-js-特性：" class="headerlink" title="Vue.js 特性："></a>Vue.js 特性：</h2><p>1.轻量级<br>2.双向数据绑定<br>3.指令<br>4.组件化</p><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVC =&gt; MVP =&gt; MVVM</span><br><span class="line">// 视图层和数据层的双向绑定</span><br><span class="line">View &lt;=&gt; ViewModel &lt;=&gt; Model</span><br></pre></td></tr></table></figure><ol><li><p>MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p></li><li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。</p></li><li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p></li></ol><h2 id="Vue-js-的优点"><a href="#Vue-js-的优点" class="headerlink" title="Vue.js 的优点"></a>Vue.js 的优点</h2><ol><li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li><li>易用灵活高效</li></ol><h2 id="Vue-组件是什么"><a href="#Vue-组件是什么" class="headerlink" title="Vue 组件是什么"></a>Vue 组件是什么</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p><h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。</p><h2 id="Vue-脚手架-3-x-以上版本使用"><a href="#Vue-脚手架-3-x-以上版本使用" class="headerlink" title="Vue 脚手架 3.x 以上版本使用"></a>Vue 脚手架 3.x 以上版本使用</h2><p>全局安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p><p>快速原型开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure></p><p>创建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br><span class="line">// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令</span><br><span class="line">winpty vue.cmd create hello-world</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hello-world</span><br></pre></td></tr></table></figure><p>Project setup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure></p><p>（以下命令 run 可以省略）<br>Compiles and hot-reloads for development<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run serve</span><br></pre></td></tr></table></figure></p><p>Compiles and minifies for production<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build</span><br></pre></td></tr></table></figure></p><p>Run your tests<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run test</span><br></pre></td></tr></table></figure></p><p>Lints and fixes files<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run lint</span><br></pre></td></tr></table></figure></p><h2 id="Vuecli-3-x-版本-上图-与-2-x-初始化目录对比"><a href="#Vuecli-3-x-版本-上图-与-2-x-初始化目录对比" class="headerlink" title="Vuecli 3.x 版本(上图)与 2.x 初始化目录对比"></a>Vuecli 3.x 版本(上图)与 2.x 初始化目录对比</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官方的路由管理器。<br>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure></p><p>引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p><p>配置路由文件，并在vue实例中注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes:[&#123;</span><br><span class="line">    path:&apos;/user/:userId&apos;, // 指定要跳转的路径</span><br><span class="line">    name: &apos;user&apos;, // 命名路由，便于路由跳转</span><br><span class="line">    component: User// 指定要跳转的组件</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">const User = (&#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="确定视图加载的位置"><a href="#确定视图加载的位置" class="headerlink" title="确定视图加载的位置"></a>确定视图加载的位置</h2><p>视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      components: &#123; // 同个路由，多个视图就需要多个组件,components 要有(s)</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现路由跳转"><a href="#实现路由跳转" class="headerlink" title="实现路由跳转"></a>实现路由跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; // 路由导航到 /user/123</span><br></pre></td></tr></table></figure><p>等同于代码调用 router.push()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 编程式导航</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) // 路由导航到 /user/123</span><br></pre></td></tr></table></figure></p><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>使用动态路由参数，以冒号开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p><p>当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应路由参数变化"><a href="#响应路由参数变化" class="headerlink" title="响应路由参数变化"></a>响应路由参数变化</h2><p>动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 <strong>watch</strong> (监测变化) $route 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos; (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者使用 <strong>beforeRouteUpdate</strong> 导航守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;...&apos;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don&apos;t forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由组件参数解耦"><a href="#路由组件参数解耦" class="headerlink" title="路由组件参数解耦"></a>路由组件参数解耦</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: [&apos;id&apos;],</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/user/:id&apos;,</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>props 有三种模式：布尔模式、对象模式、函数模式</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h2 id="在-store-存储-内有下列核心概念"><a href="#在-store-存储-内有下列核心概念" class="headerlink" title="在 store (存储)内有下列核心概念"></a>在 store (存储)内有下列核心概念</h2><p><strong>State()：核心原始数据</strong> 展示<br><strong>Getter：计算属性，根据所依赖的数据的变化计算自身变化</strong> 存储<br><strong>Mutation(转变)：提交 mutation 才能改变存储状态</strong><br><strong>Action：</strong>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br><strong>Module：可以将将 store 分割</strong><br>一般放在 state 文件夹下</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="vuex状态管理的流程"><a href="#vuex状态管理的流程" class="headerlink" title="vuex状态管理的流程"></a>vuex状态管理的流程</h2><p>view =&gt; actions =&gt; mutations =&gt; state =&gt; view</p><h2 id="核心概念详解"><a href="#核心概念详解" class="headerlink" title="核心概念详解"></a>核心概念详解</h2><h3 id="state：记录所有公共数据状态的对象"><a href="#state：记录所有公共数据状态的对象" class="headerlink" title="state：记录所有公共数据状态的对象"></a>state：记录所有公共数据状态的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 组件如何获取</span><br><span class="line">this.$store.state.XXX</span><br><span class="line">// 此处的 XXX 是 state 内定义的数据状态的键名</span><br></pre></td></tr></table></figure><h3 id="mutations：包含所有-操作数据状态的方法-的对象"><a href="#mutations：包含所有-操作数据状态的方法-的对象" class="headerlink" title="mutations：包含所有 操作数据状态的方法 的对象"></a>mutations：包含所有 操作数据状态的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 组件如何调用</span><br><span class="line">this.$store.commit(XXX)</span><br><span class="line">// 此处的 XXX是 mutations 中定义的方法名</span><br></pre></td></tr></table></figure><h3 id="actions：用于操作-mutations-内方法-的对象"><a href="#actions：用于操作-mutations-内方法-的对象" class="headerlink" title="actions：用于操作 mutations 内方法 的对象"></a>actions：用于操作 mutations 内方法 的对象</h3><p>actions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 如何调用</span><br><span class="line">this.$store.dispatch(XXX)</span><br><span class="line">// 此处的XXX是你在actions中定义的方法名</span><br></pre></td></tr></table></figure></p><h3 id="getters：定义状态内容的方法-的对象"><a href="#getters：定义状态内容的方法-的对象" class="headerlink" title="getters：定义状态内容的方法 的对象"></a>getters：定义状态内容的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters.XXX</span><br><span class="line">// 此处的XXX是你在getters里定义的方法名</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。<br>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API拦截</li><li>请求和响应转换</li><li>请求和响应数据取消</li><li>请求自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li><li><p>引入加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure></li><li><p>将axios全局挂载到 Vue 原型上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置全局-axios-默认值"><a href="#设置全局-axios-默认值" class="headerlink" title="设置全局 axios 默认值"></a>设置全局 axios 默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置基础路径，一般为后端接口线上地址根路径</span><br><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">// 设置默认 token</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">// 默认 POST 请求</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure><h2 id="axios-的-url-有两种传递参数的形式"><a href="#axios-的-url-有两种传递参数的形式" class="headerlink" title="axios 的 url 有两种传递参数的形式"></a>axios 的 url 有两种传递参数的形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一种 对象形式</span><br><span class="line">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">// 如果只有一个参数，可以省略 params</span><br><span class="line">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">  &#125;) </span><br><span class="line">--------------------------------- </span><br><span class="line">// 第二种 形式</span><br><span class="line">this.$http.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure><h2 id="POST-传递数据有两种格式："><a href="#POST-传递数据有两种格式：" class="headerlink" title="POST 传递数据有两种格式："></a>POST 传递数据有两种格式：</h2><ol><li>form­-data ?page=1&amp;limit=48</li><li>x-­www­-form-­urlencoded { page: 1,limit: 10 }</li></ol><p><strong>在 axios 中，post 请求接收的参数必须是 form­-data 形式<br>如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$http.post(&apos;/user&apos;, qs.stringify(&#123;</span><br><span class="line">   ID: 12345</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="实现增删改查"><a href="#实现增删改查" class="headerlink" title="实现增删改查"></a>实现增删改查</h2><h3 id="发起-GET-请求：查"><a href="#发起-GET-请求：查" class="headerlink" title="发起 GET 请求：查"></a>发起 GET 请求：查</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;) // 下同省略</span><br><span class="line"></span><br><span class="line">//发起一个user请求，参数为给定的ID</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then((response) =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="发起-POST-请求：增"><a href="#发起-POST-请求：增" class="headerlink" title="发起 POST 请求：增"></a>发起 POST 请求：增</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">  firstName: &apos;yuanda&apos;,</span><br><span class="line">  lastName: &apos;zhou&apos;</span><br><span class="line">&#125;)</span><br><span class="line">  .then((response) =&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[,config])</span><br><span class="line">axios.delete(url[,config]) // 删除</span><br><span class="line">axios.head(url[,config])</span><br><span class="line">axios.options(url[,config])</span><br><span class="line">axios.post(url[,data[,config]])</span><br><span class="line">axios.put(url[,data[,config]]) // 改</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure><p>PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</p><h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class="line">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class="line">        //两个请求现在都完成</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><p>axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。</p><h2 id="拦截器-interceptors"><a href="#拦截器-interceptors" class="headerlink" title="拦截器 interceptors"></a>拦截器 interceptors</h2><p>你可以在<strong>请求</strong>或者<strong>响应</strong>被 then 或者 catch 处理之前对他们进行拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加一个请求拦截器</span><br><span class="line">axios.interceptors.request.use(function(config)&#123;</span><br><span class="line">    //在请求发送之前做一些事</span><br><span class="line">    return config;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //当出现请求错误是做一些事</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加一个返回拦截器</span><br><span class="line">axios.interceptors.response.use(function(response)&#123;</span><br><span class="line">    //对返回的数据进行一些处理</span><br><span class="line">    return response;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    //对返回的错误进行一些处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>用 eject 移除拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p><h2 id="axios-如何获取-cookie"><a href="#axios-如何获取-cookie" class="headerlink" title="axios 如何获取 cookie"></a>axios 如何获取 cookie</h2><p>axios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">axios.defaults.withCredentials=true; //让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure></p><p>通过js原生接口来获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let allCookies = document.cookie</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hash 模式和 history 模式小记</title>
      <link>http://adashuai5.com/2019/01/28/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/</link>
      <guid>http://adashuai5.com/2019/01/28/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/</guid>
      <pubDate>Mon, 28 Jan 2019 13:55:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前端路由&quot;&gt;&lt;a href=&quot;#前端路由&quot; class=&quot;headerlink&quot; title=&quot;前端路由&quot;&gt;&lt;/a&gt;前端路由&lt;/h1&gt;&lt;p&gt;随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><p>随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</p><h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/#/login</span><br></pre></td></tr></table></figure></p><p>这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function matchAndUpdate () &#123;</span><br><span class="line">   // todo 匹配 hash 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;hashchange&apos;, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>14年后，因为 HTML5 标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function matchAndUpdate () &#123;</span><br><span class="line">   // todo 匹配路径 做 dom 更新操作</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;popstate&apos;, matchAndUpdate)</span><br></pre></td></tr></table></figure></p><p>(以上内容转载自<a href="https://zhuanlan.zhihu.com/p/37730038" target="_blank" rel="noopener">前端路由简介以及vue-router实现原理</a>部分内容，作者总结得很好)</p><p>在 vue-router 中，默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。<br>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面</p><h2 id="hash-模式和-history-模式主要区别"><a href="#hash-模式和-history-模式主要区别" class="headerlink" title="hash 模式和 history 模式主要区别"></a>hash 模式和 history 模式主要区别</h2><ol><li>使用 hash 模式，当 一个窗口的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件，而不会刷新页面，比如: 在页面内点击带有锚点的 a 标签，不会刷新页面。</li><li>使用 history，URL 没有了 #，一般都需要服务器端配置或支持 SSR，否则刷新页面服务器会返回 404。</li></ol><h2 id="hash-模式以及为什么改变-hash-不刷新页面——URL的井号‘-’"><a href="#hash-模式以及为什么改变-hash-不刷新页面——URL的井号‘-’" class="headerlink" title="hash 模式以及为什么改变 hash 不刷新页面——URL的井号‘#’"></a>hash 模式以及为什么改变 hash 不刷新页面——<a href="http://www.ruanyifeng.com/blog/2011/03/url_hash.html" target="_blank" rel="noopener">URL的井号‘#’</a></h2><h2 id="有关-history-对象"><a href="#有关-history-对象" class="headerlink" title="有关 history 对象"></a>有关 <a href="https://javascript.ruanyifeng.com/bom/history.html#toc1" target="_blank" rel="noopener">history 对象</a></h2><p>由于 HTML5 只在 IE9 以上支持</p><h2 id="控制-vue-router-内的自动降级"><a href="#控制-vue-router-内的自动降级" class="headerlink" title="控制 vue-router 内的自动降级"></a>控制 vue-router 内的自动降级</h2><blockquote><p>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p></blockquote><p>可使用 <strong>fallback</strong> API</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-b7d0691f21ffc7cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2019/01/28/hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从「从输入URL到页面加载」谈及Web性能优化</title>
      <link>http://adashuai5.com/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <guid>http://adashuai5.com/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sat, 29 Dec 2018 06:09:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;如何理解-Web-性能优化&quot;&gt;&lt;a href=&quot;#如何理解-Web-性能优化&quot; class=&quot;headerlink&quot; title=&quot;如何理解 Web 性能优化&quot;&gt;&lt;/a&gt;如何理解 Web 性能优化&lt;/h1&gt;&lt;p&gt;事实上就是用户觉得页面加载很快，用户从输入URL（网
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="如何理解-Web-性能优化"><a href="#如何理解-Web-性能优化" class="headerlink" title="如何理解 Web 性能优化"></a>如何理解 Web 性能优化</h1><p>事实上就是用户觉得页面加载很快，用户从输入URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。<br>对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。</p><h1 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h1><p>一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。</p><h2 id="0-缓存"><a href="#0-缓存" class="headerlink" title="0. 缓存"></a>0. 缓存</h2><p>当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。</p><h2 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1. DNS 查询"></a>1. DNS 查询</h2><p>DNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>DNS查询完成之前，浏览器无法从服务器下载任何数据。</p><h3 id="优化方案：减少-DNS-查询"><a href="#优化方案：减少-DNS-查询" class="headerlink" title="优化方案：减少 DNS 查询"></a>优化方案：减少 DNS 查询</h3><h4 id="1-1-DNS-缓存"><a href="#1-1-DNS-缓存" class="headerlink" title="1.1 DNS 缓存"></a>1.1 DNS 缓存</h4><p>ISP、局域网、操作系统、浏览器等都会有相应的DNS缓存机制。</p><h4 id="1-2-减少页面的唯一域名"><a href="#1-2-减少页面的唯一域名" class="headerlink" title="1.2 减少页面的唯一域名"></a>1.2 减少页面的唯一域名</h4><p>因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。</p><h2 id="2-TCP-连接"><a href="#2-TCP-连接" class="headerlink" title="2. TCP 连接"></a>2. TCP 连接</h2><p>经典的三次握手和四次挥手，不展开赘述。<br>简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。</p><h2 id="3-HTTP-请求及响应"><a href="#3-HTTP-请求及响应" class="headerlink" title="3. HTTP 请求及响应"></a>3. HTTP 请求及响应</h2><p>直接讲优化策略</p><h4 id="3-1-避免不必要的重定向"><a href="#3-1-避免不必要的重定向" class="headerlink" title="3.1 避免不必要的重定向"></a>3.1 避免不必要的重定向</h4><blockquote><p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问<a href="http://astrology.yahoo.com/astrology将被301重定向到" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology将被301重定向到</a> <a href="http://astrology.yahoo.com/astrology/（注意末尾的" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/（注意末尾的</a> /）。如果使用 Apache，可以通过Alias或mod_rewrite或DirectorySlash解决这个问题。</p></blockquote><h4 id="3-2-Cookie"><a href="#3-2-Cookie" class="headerlink" title="3.2 Cookie"></a>3.2 Cookie</h4><h5 id="3-2-1减少-Cookie-大小"><a href="#3-2-1减少-Cookie-大小" class="headerlink" title="3.2.1减少 Cookie 大小"></a>3.2.1减少 Cookie 大小</h5><p>每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：</p><ul><li>去除不必要的 Cookie；</li><li>尽量压缩 Cookie 大小；</li><li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li><li>设置合适的过期时间。</li></ul><h5 id="3-2-2-静态资源使用无-Cookie-域名"><a href="#3-2-2-静态资源使用无-Cookie-域名" class="headerlink" title="3.2.2 静态资源使用无 Cookie 域名"></a>3.2.2 静态资源使用无 Cookie 域名</h5><p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p><h4 id="3-3-添加-Expires-或-Cache-Control-响应头"><a href="#3-3-添加-Expires-或-Cache-Control-响应头" class="headerlink" title="3.3 添加 Expires 或 Cache-Control 响应头"></a>3.3 添加 Expires 或 Cache-Control 响应头</h4><p>HTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。</p><ul><li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li><li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li></ul><h4 id="3-4-配置-Etag"><a href="#3-4-配置-Etag" class="headerlink" title="3.4 配置 Etag"></a>3.4 配置 Etag</h4><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p><h4 id="3-5-使用-Gzip"><a href="#3-5-使用-Gzip" class="headerlink" title="3.5 使用 Gzip"></a>3.5 使用 Gzip</h4><p>使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。<br>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。<br>从HTTP/1.1开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p><p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过 Content-Encoding 响应头来通知客户端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p><p>需要注意的是，已经压缩过的内容如图片和PDF不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。</p><h3 id="值得一提"><a href="#值得一提" class="headerlink" title="值得一提"></a>值得一提</h3><p>HTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。<br>另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：</p><h4 id="3-6-延迟加载（懒加载）"><a href="#3-6-延迟加载（懒加载）" class="headerlink" title="3.6 延迟加载（懒加载）"></a>3.6 延迟加载（懒加载）</h4><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p><ul><li>非首屏使用的数据、样式、脚本、图片等；</li><li>用户交互时才会显示的内容。</li></ul><p>遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。</p><blockquote><p>将首屏以外的HTML放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者type属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p></blockquote><h4 id="3-7-预加载"><a href="#3-7-预加载" class="headerlink" title="3.7 预加载"></a>3.7 预加载</h4><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p><h2 id="4-浏览器解析渲染页面"><a href="#4-浏览器解析渲染页面" class="headerlink" title="4. 浏览器解析渲染页面"></a>4. 浏览器解析渲染页面</h2><p>响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。</p><h4 id="4-1-写对文档类型声明-lt-DOCTYPE-html-gt"><a href="#4-1-写对文档类型声明-lt-DOCTYPE-html-gt" class="headerlink" title="4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;"></a>4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;</h4><blockquote><p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">怪异模式(兼容模式)</a>”的渲染模式。“<code>&amp;lt;!DOCTYPE html&amp;gt;</code>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></blockquote><p>不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。</p><h4 id="4-2-CSS-放在-lt-head-gt-中"><a href="#4-2-CSS-放在-lt-head-gt-中" class="headerlink" title="4.2 CSS 放在 &lt;head&gt; 中"></a>4.2 CSS 放在 &lt;head&gt; 中</h4><p>把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。<br>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。<br>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的HEAD部分能让页面看起来加载地更快。</p><h4 id="4-2-把脚本放在页面底部"><a href="#4-2-把脚本放在页面底部" class="headerlink" title="4.2 把脚本放在页面底部"></a>4.2 把脚本放在页面底部</h4><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。<br>一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：</p><ul><li>defer 属性；</li><li>HTML5 新增的async属性。</li></ul><h4 id="4-3-使用外部-JavaScript-和-CSS"><a href="#4-3-使用外部-JavaScript-和-CSS" class="headerlink" title="4.3 使用外部 JavaScript 和 CSS"></a>4.3 使用外部 JavaScript 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少HTTP请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p><h4 id="4-4-合并和压缩-JS-CSS-等文件"><a href="#4-4-合并和压缩-JS-CSS-等文件" class="headerlink" title="4.4 合并和压缩 JS/CSS 等文件"></a>4.4 合并和压缩 JS/CSS 等文件</h4><p>通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。</p><h4 id="4-5-减少-DOM-操作和使用高效的事件处理"><a href="#4-5-减少-DOM-操作和使用高效的事件处理" class="headerlink" title="4.5 减少 DOM 操作和使用高效的事件处理"></a>4.5 减少 DOM 操作和使用高效的事件处理</h4><ul><li>缓存已经访问过的元素；</li><li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li><li>操作 className，而不是多次读写 style；</li><li>避免使用 JavaScript 修复布局；</li><li>减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；</li><li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li></ul><h4 id="4-6-图片优化"><a href="#4-6-图片优化" class="headerlink" title="4.6 图片优化"></a>4.6 图片优化</h4><p>如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。</p><h4 id="4-7-使用-CND"><a href="#4-7-使用-CND" class="headerlink" title="4.7 使用 CND"></a>4.7 使用 CND</h4><blockquote><p>内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p></blockquote><p>动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。<br>深入阅读 <a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p><p>本文参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51" target="_blank" rel="noopener">前端性能优化之雅虎35条军规</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br>MDN<br>维基百科</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>优先级 和 CSS 预处理</title>
      <link>http://adashuai5.com/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <guid>http://adashuai5.com/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <pubDate>Thu, 20 Dec 2018 14:30:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前言扯淡&quot;&gt;&lt;a href=&quot;#前言扯淡&quot; class=&quot;headerlink&quot; title=&quot;前言扯淡&quot;&gt;&lt;/a&gt;前言扯淡&lt;/h2&gt;&lt;p&gt;前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言扯淡"><a href="#前言扯淡" class="headerlink" title="前言扯淡"></a>前言扯淡</h2><p>前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。<br>需求是最好的学习API的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。</p><h2 id="首先是-优先级"><a href="#首先是-优先级" class="headerlink" title="首先是 优先级"></a>首先是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">优先级</a></h2><p>链接是文档，优先级主要是指CSS属性的优先级。</p><blockquote><p>浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。</p></blockquote><p>简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 id=&quot;title&quot; class=&quot;title&quot; style=&quot;color: yellow;&quot;&gt;优先级&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--优先级显示为 pink--&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title&#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#title&#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: pink !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先级如何确定："><a href="#优先级如何确定：" class="headerlink" title="优先级如何确定："></a>优先级如何确定：</h4><p>选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）</p><ol><li><strong>ID选择器</strong>（例如, #title）</li><li><strong>类选择器</strong>（class selectors） (例如,.title)，<strong>属性选择器</strong>（attributes selectors）（例如, [type=”radio”]），<strong>伪类</strong>（pseudo-classes）（例如, :hover）</li><li><strong>类型选择器</strong>（type selectors）（例如, h1）和 <strong>伪元素</strong>（pseudo-elements）（例如, ::before）</li></ol><p><strong>通配选择符</strong>（universal selector）(*), <strong>关系选择符</strong>（combinators） (+, &gt;, ~, ‘ ‘)  和 <strong>否定伪类</strong>（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。<br>给元素添加的<strong>内联样式</strong>  (例如, style=”color: yellow;”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。<br><strong>!important</strong> 是例外，此声明将覆盖任何其他声明，技术上!important与优先级无关，但它与它直接相关。</p><h4 id="如何利用优先级"><a href="#如何利用优先级" class="headerlink" title="如何利用优先级"></a>如何利用优先级</h4><ol><li>选择器越具体，优先级越高。</li><li>相同优先级情况下，后面的样式覆盖前面的。</li><li>!important 最特殊，有他的声明最优先，但应该避免使用。</li></ol><p>上面内容均来自 MDN，也就是我给的链接，还有很多如<code>无视DOM树中的距离</code>等没有记录。大家还是直接看MDN为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看MDN文档而收获一些东西，便是此文的意义了。<br>扩展阅读 <a href="https://github.com/jincdream/jincdream.github.io/issues/14" target="_blank" rel="noopener">真正理解”CSS选择器的优先级”</a></p><h2 id="CSS预处理（预编译）"><a href="#CSS预处理（预编译）" class="headerlink" title="CSS预处理（预编译）"></a>CSS预处理（预编译）</h2><p>当面试关问我知不知道CSS预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。</p><hr><p>(以下内容来自 <a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="noopener">再谈 CSS 预处理器</a>)<br>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li></ul><p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。</p><hr><p>这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度EFE的文档比我写肯定高到不知道哪里去了。<br>那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;&#125;</span><br><span class="line">div&gt;ul&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&gt;a&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。</p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/12/20/%E4%BC%98%E5%85%88%E7%BA%A7-%E5%92%8C-CSS-%E9%A2%84%E5%A4%84%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈JS继承</title>
      <link>http://adashuai5.com/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/</link>
      <guid>http://adashuai5.com/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/</guid>
      <pubDate>Fri, 02 Nov 2018 12:38:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;什么是继承&quot;&gt;&lt;a href=&quot;#什么是继承&quot; class=&quot;headerlink&quot; title=&quot;什么是继承&quot;&gt;&lt;/a&gt;什么是继承&lt;/h1&gt;&lt;p&gt;根据维基百科解释，可以简单概括为：&lt;br&gt;继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h1><p>根据维基百科解释，可以简单概括为：<br>继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。</p><h1 id="JS-里的原型继承模型"><a href="#JS-里的原型继承模型" class="headerlink" title="JS 里的原型继承模型"></a>JS 里的原型继承模型</h1><p>JS：不好意思，我没有类。（即使是ES6中的类也是语法糖）<br>JavaScript 是基于原型实现面向对象的，那么在JS中，面向对象概念中的继承自然也是基于原型。</p><blockquote><p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p></blockquote><blockquote><p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <strong>Object</strong> 的实例。</p></blockquote><p>有关原型之前写过博客<a href="https://www.jianshu.com/p/93441c4e8f48" target="_blank" rel="noopener">JavaScript原型和原型链</a>，对理解下面内容有帮助。<br>虽然没有传统语言意义上的类，但是 JS语言 使用构造函数生成对象，实现面向对象程序设计。</p><h1 id="说了这么多，JS-中的继承到底是什么？"><a href="#说了这么多，JS-中的继承到底是什么？" class="headerlink" title="说了这么多，JS 中的继承到底是什么？"></a>说了这么多，JS 中的继承到底是什么？</h1><p><strong>可以简单理解为：两次的原型搜索就是继承。<br>数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。</strong></p><p>接下来我们用代码实现一下继承</p><h2 id="1-使用-prototype-实现继承"><a href="#1-使用-prototype-实现继承" class="headerlink" title="1. 使用 prototype 实现继承"></a>1. 使用 prototype 实现继承</h2><p><strong>prototype 的作用：为构造函数内添加实例对象之间的共有属性</strong></p><p><strong>明确 JS 内的继承</strong><br>以下面代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个 人类</span><br><span class="line">function Human(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 给所有 人类 添加一个 跑 的共有属性</span><br><span class="line">Human.prototype.run = function()&#123;</span><br><span class="line">  console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">  return undefined</span><br><span class="line">&#125;</span><br><span class="line">// 构造一个 男人类</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Human.call(this, name)</span><br><span class="line">  this.gender = &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 所有 男人 都有好战属性</span><br><span class="line">Man.prototype.fight = function()&#123;</span><br><span class="line">  console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到名为 ada 的人只有 name、gender 和fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。<br><strong>目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。</strong><br>根据我原型知识的博客里面的内容我们知道，我们可以直接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype.__proto__ = Human.prototype</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到 Man 指向了 Human 而不是直接指向 Object，ada2 继承了来自 Human 的 run 属性</p><p><strong>但是在实际编程过程中直接操作 <strong> proto </strong> 这个非标准但许多浏览器（IE不支持）实现的属性是不规范的。</strong></p><p>那怎么办？<br>new 可不可以？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype = new Human()</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>直接用上述代码不行，因为在 new 的过程中，虽然new 内部实现了 <code>Man.prototype.__proto__ = Human.prototype</code> 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined</strong></p><p>那么我们只要避免这个过程中 Human 执行就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;&#125;</span><br><span class="line">a.prototype = Human.prototype</span><br><span class="line">Man.prototype = new a()</span><br></pre></td></tr></table></figure></p><p>通过上面三行代码，即实现了没有内部执行空函数的 new</p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="2-ES6-实现继承"><a href="#2-ES6-实现继承" class="headerlink" title="2. ES6 实现继承"></a>2. ES6 实现继承</h2><p>上面代码的 ES6 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES6 写法</span><br><span class="line">class Human&#123;</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         this.name = name</span><br><span class="line">     &#125;</span><br><span class="line">     run()&#123;</span><br><span class="line">         console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">         return undefined</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class Man extends Human&#123; // extends 实现上述继承过程</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         super(name) // 调用构造函数:&apos;超类&apos;</span><br><span class="line">         this.gender = &apos;男&apos;</span><br><span class="line">     &#125;</span><br><span class="line">     fight()&#123;</span><br><span class="line">         console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>JS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。</p><blockquote><p>原型继承模型本身实际上比经典模型更强大</p></blockquote><hr><p>感谢阅读<br>本文仅供个人学习使用</p><p>部分参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/11/02/%E6%B5%85%E8%B0%88JS%E7%BB%A7%E6%89%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>正则表达式速记</title>
      <link>http://adashuai5.com/2018/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E8%AE%B0/</link>
      <guid>http://adashuai5.com/2018/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E8%AE%B0/</guid>
      <pubDate>Sun, 28 Oct 2018 06:15:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如何学习：&lt;a href=&quot;https://luke0922.gitbooks.io/learnregularexpressionin30m
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如何学习：<a href="https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html" target="_blank" rel="noopener">30分钟入门正则表达式</a><br><a href="https://www.regexpal.com/" target="_blank" rel="noopener">工具</a><br>本文参（zhao）考（chao）<a href="https://wangdoc.com/javascript/stdlib/regexp.html" target="_blank" rel="noopener">RegExp 对象</a>，该笔记只为速查</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象，其体系参照 Perl 5 建立。</p><h1 id="创建正则表达式的方法"><a href="#创建正则表达式的方法" class="headerlink" title="创建正则表达式的方法"></a>创建正则表达式的方法</h1><ol><li><p>使用一个正则表达式字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var re = /xxx/</span><br></pre></td></tr></table></figure></li><li><p>调用 RegExp 对象的构造函数</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var re = new RegExp(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure><p>两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p><h1 id="正则表达式的实例属性"><a href="#正则表达式的实例属性" class="headerlink" title="正则表达式的实例属性"></a>正则表达式的实例属性</h1><p>分为两类</p><ol><li>修饰符（只读）<br>RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。用于忽略字符串大小写。<br>RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。用于全局匹配。<br>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。用于设置匹配为多行模式。</li><li>其他属性<br>RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。<br>RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li></ol><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><h2 id="1-RegExp-prototype-test"><a href="#1-RegExp-prototype-test" class="headerlink" title="1. RegExp.prototype.test()"></a>1. RegExp.prototype.test()</h2><p>test 方法返回布尔值，表示当前模式是否能匹配参数字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(&apos;and&apos;) // true</span><br></pre></td></tr></table></figure></p><h2 id="2-RegExp-prototype-exec"><a href="#2-RegExp-prototype-exec" class="headerlink" title="2. RegExp.prototype.exec()"></a>2. RegExp.prototype.exec()</h2><p>exec方法，用来返回匹配结果<br>如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/.exec(&apos;adbca&apos;)</span><br></pre></td></tr></table></figure></p><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</span><br><span class="line">String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</span><br><span class="line">String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</span><br><span class="line">String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</span><br></pre></td></tr></table></figure></p><hr><h1 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ol><li>点字符（.)<br>匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</li><li><p>位置字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^ 表示字符串的开始位置</span><br><span class="line">$ 表示字符串的结束位置</span><br></pre></td></tr></table></figure></li><li><p>选择符（|）<br>表示“或关系”</p></li><li>转义符<br>匹配元字符本身可以在它们前面加反斜杠<br>构造函数需要两次转义</li><li>特殊字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</span><br><span class="line">[\b] 匹配退格键(U+0008)，不要与\b混淆。</span><br><span class="line">\n 匹配换行键。</span><br><span class="line">\r 匹配回车键。</span><br><span class="line">\t 匹配制表符 tab（U+0009）。</span><br><span class="line">\v 匹配垂直制表符（U+000B）。</span><br><span class="line">\f 匹配换页符（U+000C）。</span><br><span class="line">\0 匹配null字符（U+0000）。</span><br><span class="line">\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。</span><br><span class="line">\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</span><br></pre></td></tr></table></figure></li></ol><h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示x、y、z之中任选一个匹配。</p><ol><li>脱字符（^）：需在字符类第一位<br>表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</li><li>连字符（-）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0-9.,]</span><br><span class="line">[0-9a-fA-F]</span><br><span class="line">[a-zA-Z0-9-]</span><br><span class="line">[1-31] // 不代表1到31，只代表1到3</span><br></pre></td></tr></table></figure></li></ol><h1 id="预定义模式：某些常见模式的简写方式"><a href="#预定义模式：某些常见模式的简写方式" class="headerlink" title="预定义模式：某些常见模式的简写方式"></a>预定义模式：某些常见模式的简写方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\d 匹配0-9之间的任一数字，相当于[0-9]。</span><br><span class="line">\D 匹配所有0-9以外的字符，相当于[^0-9]。</span><br><span class="line">\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</span><br><span class="line">\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</span><br><span class="line">\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</span><br><span class="line">\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</span><br><span class="line">\b 匹配词的边界。</span><br><span class="line">\B 匹配非词边界，即在词的内部</span><br></pre></td></tr></table></figure><h1 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h1><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p><h1 id="量词符：设定某个模式出现的次数"><a href="#量词符：设定某个模式出现的次数" class="headerlink" title="量词符：设定某个模式出现的次数"></a>量词符：设定某个模式出现的次数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。</span><br><span class="line">* 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。</span><br><span class="line">+ 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。</span><br></pre></td></tr></table></figure><h1 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure><p>贪婪模式改为非贪婪模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</span><br><span class="line">+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</span><br></pre></td></tr></table></figure></p><h1 id="字符串去空格-replace"><a href="#字符串去空格-replace" class="headerlink" title="字符串去空格(replace)"></a>字符串去空格(replace)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;  #id div.class  &apos;;</span><br><span class="line">str.trim() // &quot;#id div.class&quot;</span><br><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;) // &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&amp;：匹配的子字符串。</span><br><span class="line">$`：匹配结果前面的文本。</span><br><span class="line">$’：匹配结果后面的文本。</span><br><span class="line">$n：匹配成功的第n组内容，n是从1开始的自然数。</span><br><span class="line">$$：指代美元符号$。</span><br></pre></td></tr></table></figure><p>多多练习吧</p><hr><p>本文仅供个人学习使用</p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>理解虚拟 DOM</title>
      <link>http://adashuai5.com/2018/09/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F-DOM/</link>
      <guid>http://adashuai5.com/2018/09/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F-DOM/</guid>
      <pubDate>Thu, 27 Sep 2018 13:10:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;DOM-和-Virtual-DOM&quot;&gt;&lt;a href=&quot;#DOM-和-Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM 和 Virtual DOM&quot;&gt;&lt;/a&gt;DOM 和 Virtual DOM&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;DO
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="DOM-和-Virtual-DOM"><a href="#DOM-和-Virtual-DOM" class="headerlink" title="DOM 和 Virtual DOM"></a>DOM 和 Virtual DOM</h1><p><strong>DOM：Document Object Model 把文档变成对象的模型<br>在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。<br>问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？<br>你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。<br>方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。<br>在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。</strong></p><p><code>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</code></p><h1 id="过程实现"><a href="#过程实现" class="headerlink" title="过程实现"></a>过程实现</h1><p>文档界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./v-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 VNode 类</span><br><span class="line">class VNode &#123;</span><br><span class="line">    constructor(tag, children, text) &#123;</span><br><span class="line">        this.tag = tag</span><br><span class="line">        this.children = children</span><br><span class="line">        this.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; // render 方法，创建子元素</span><br><span class="line">        if (this.tag === &apos;#text&apos;) &#123;</span><br><span class="line">            return document.createTextNode(this.text)</span><br><span class="line">        &#125;</span><br><span class="line">        let el = document.createElement(this.tag)</span><br><span class="line">        this.children.forEach(vChild =&gt; &#123;</span><br><span class="line">            el.appendChild(vChild.render())</span><br><span class="line">        &#125;)</span><br><span class="line">        return el</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// v 构造函数，判断子元素类型</span><br><span class="line">function v(tag, children, text) &#123;</span><br><span class="line">    if (typeof children === &apos;string&apos;) &#123;</span><br><span class="line">        text = children</span><br><span class="line">        children = []</span><br><span class="line">    &#125;</span><br><span class="line">    return new VNode(tag, children, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let vNode = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class="line">])</span><br><span class="line">const root = document.querySelector(&apos;#root&apos;)</span><br><span class="line">root.appendChild(vNode.render())</span><br></pre></td></tr></table></figure><p>通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中<br><img src="https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function patchElement(parent, newVNode, oldVNode, index = 0) &#123;</span><br><span class="line">    if (!oldVNode) &#123;</span><br><span class="line">        parent.appendChild(newVNode.render())</span><br><span class="line">    &#125; else if (!newVNode) &#123;</span><br><span class="line">        parent.removeChild(parent.childNodes[index])</span><br><span class="line">    &#125; else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123;</span><br><span class="line">        parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class="line">            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。</p><p>整个状态变更的过程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建虚拟DOM</span><br><span class="line">let vNode = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class="line">])</span><br><span class="line">// 3. 生成新的虚拟DOM</span><br><span class="line">let vNode1 = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)]),</span><br><span class="line">    v(&apos;p&apos;, [v(&apos;#text&apos;, &apos;upload&apos;)])</span><br><span class="line">])</span><br><span class="line">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class="line">const root = document.querySelector(&apos;#root&apos;)</span><br><span class="line">patchElement(root, vNode)</span><br><span class="line">var n = 0</span><br><span class="line">// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更</span><br><span class="line">document.querySelector(&apos;.btn&apos;).onclick = function () &#123;</span><br><span class="line">    if (n % 2 == 0) &#123;</span><br><span class="line">        patchElement(root, vNode1, vNode)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        patchElement(root, vNode, vNode1)</span><br><span class="line">    &#125;</span><br><span class="line">    n += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本文仅供个人学习使用</p><hr><p>主要参考：<a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">深度剖析：如何实现一个 Virtual DOM 算法</a></p>]]></content:encoded>
      
      <comments>http://adashuai5.com/2018/09/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F-DOM/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
