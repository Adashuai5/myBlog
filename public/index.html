<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="你是哥哥还是 MM">
<meta name="keywords" content="前端开发">
<meta property="og:type" content="website">
<meta property="og:title" content="Ada 的个人主页">
<meta property="og:url" content="http://adashuai5.com/index.html">
<meta property="og:site_name" content="Ada 的个人主页">
<meta property="og:description" content="你是哥哥还是 MM">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ada 的个人主页">
<meta name="twitter:description" content="你是哥哥还是 MM">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://adashuai5.com/">





  <title>Ada 的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ada 的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">试问谁可，洁白无比？</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/12/29/从「从输入URL到页面加载」谈及Web性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/29/从「从输入URL到页面加载」谈及Web性能优化/" itemprop="url">从「从输入URL到页面加载」谈及Web性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-29T14:09:32+08:00">
                2018-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何理解-Web-性能优化"><a href="#如何理解-Web-性能优化" class="headerlink" title="如何理解 Web 性能优化"></a>如何理解 Web 性能优化</h1><p>事实上就是用户觉得页面加载很快，用户从输入URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。<br>对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。</p>
<h1 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h1><p>一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。</p>
<h2 id="0-缓存"><a href="#0-缓存" class="headerlink" title="0. 缓存"></a>0. 缓存</h2><p>当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。</p>
<h2 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1. DNS 查询"></a>1. DNS 查询</h2><p>DNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>DNS查询完成之前，浏览器无法从服务器下载任何数据。</p>
<h3 id="优化方案：减少-DNS-查询"><a href="#优化方案：减少-DNS-查询" class="headerlink" title="优化方案：减少 DNS 查询"></a>优化方案：减少 DNS 查询</h3><h4 id="1-1-DNS-缓存"><a href="#1-1-DNS-缓存" class="headerlink" title="1.1 DNS 缓存"></a>1.1 DNS 缓存</h4><p>ISP、局域网、操作系统、浏览器等都会有相应的DNS缓存机制。</p>
<h4 id="1-2-减少页面的唯一域名"><a href="#1-2-减少页面的唯一域名" class="headerlink" title="1.2 减少页面的唯一域名"></a>1.2 减少页面的唯一域名</h4><p>因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。</p>
<h2 id="2-TCP-连接"><a href="#2-TCP-连接" class="headerlink" title="2. TCP 连接"></a>2. TCP 连接</h2><p>经典的三次握手和四次挥手，不展开赘述。<br>简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。</p>
<h2 id="3-HTTP-请求及响应"><a href="#3-HTTP-请求及响应" class="headerlink" title="3. HTTP 请求及响应"></a>3. HTTP 请求及响应</h2><p>直接讲优化策略</p>
<h4 id="3-1-避免不必要的重定向"><a href="#3-1-避免不必要的重定向" class="headerlink" title="3.1 避免不必要的重定向"></a>3.1 避免不必要的重定向</h4><p>&gt; 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问<a href="http://astrology.yahoo.com/astrology将被301重定向到" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology将被301重定向到</a> <a href="http://astrology.yahoo.com/astrology/（注意末尾的" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/（注意末尾的</a> /）。如果使用 Apache，可以通过Alias或mod_rewrite或DirectorySlash解决这个问题。</p>
<h4 id="3-2-Cookie"><a href="#3-2-Cookie" class="headerlink" title="3.2 Cookie"></a>3.2 Cookie</h4><h5 id="3-2-1减少-Cookie-大小"><a href="#3-2-1减少-Cookie-大小" class="headerlink" title="3.2.1减少 Cookie 大小"></a>3.2.1减少 Cookie 大小</h5><p>每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：</p>
<ul>
<li>去除不必要的 Cookie；</li>
<li>尽量压缩 Cookie 大小；</li>
<li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li>
<li>设置合适的过期时间。</li>
</ul>
<h5 id="3-2-2-静态资源使用无-Cookie-域名"><a href="#3-2-2-静态资源使用无-Cookie-域名" class="headerlink" title="3.2.2 静态资源使用无 Cookie 域名"></a>3.2.2 静态资源使用无 Cookie 域名</h5><p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p>
<h4 id="3-3-添加-Expires-或-Cache-Control-响应头"><a href="#3-3-添加-Expires-或-Cache-Control-响应头" class="headerlink" title="3.3 添加 Expires 或 Cache-Control 响应头"></a>3.3 添加 Expires 或 Cache-Control 响应头</h4><p>HTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。</p>
<ul>
<li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li>
<li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li>
</ul>
<h4 id="3-4-配置-Etag"><a href="#3-4-配置-Etag" class="headerlink" title="3.4 配置 Etag"></a>3.4 配置 Etag</h4><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p>
<h4 id="3-5-使用-Gzip"><a href="#3-5-使用-Gzip" class="headerlink" title="3.5 使用 Gzip"></a>3.5 使用 Gzip</h4><p>使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。<br>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。<br>从HTTP/1.1开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p>
<p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过 Content-Encoding 响应头来通知客户端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，已经压缩过的内容如图片和PDF不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。</p>
<h3 id="值得一提"><a href="#值得一提" class="headerlink" title="值得一提"></a>值得一提</h3><p>HTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。<br>另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：</p>
<h4 id="3-6-延迟加载（懒加载）"><a href="#3-6-延迟加载（懒加载）" class="headerlink" title="3.6 延迟加载（懒加载）"></a>3.6 延迟加载（懒加载）</h4><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>
<ul>
<li>非首屏使用的数据、样式、脚本、图片等；</li>
<li>用户交互时才会显示的内容。</li>
</ul>
<p>遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。<br>&gt;将首屏以外的HTML放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者type属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p>
<h4 id="3-7-预加载"><a href="#3-7-预加载" class="headerlink" title="3.7 预加载"></a>3.7 预加载</h4><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p>
<h2 id="4-浏览器解析渲染页面"><a href="#4-浏览器解析渲染页面" class="headerlink" title="4. 浏览器解析渲染页面"></a>4. 浏览器解析渲染页面</h2><p>响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。</p>
<h4 id="4-1-写对文档类型声明-lt-DOCTYPE-html-gt"><a href="#4-1-写对文档类型声明-lt-DOCTYPE-html-gt" class="headerlink" title="4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;"></a>4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;</h4><p>&gt;这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">怪异模式(兼容模式)</a>”的渲染模式。“<code>&amp;lt;!DOCTYPE html&amp;gt;</code>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p>
<p>不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。</p>
<h4 id="4-2-CSS-放在-lt-head-gt-中"><a href="#4-2-CSS-放在-lt-head-gt-中" class="headerlink" title="4.2 CSS 放在 &lt;head&gt; 中"></a>4.2 CSS 放在 &lt;head&gt; 中</h4><p>把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。<br>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。<br>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的HEAD部分能让页面看起来加载地更快。</p>
<h4 id="4-2-把脚本放在页面底部"><a href="#4-2-把脚本放在页面底部" class="headerlink" title="4.2 把脚本放在页面底部"></a>4.2 把脚本放在页面底部</h4><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。<br>一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：</p>
<ul>
<li>defer 属性；</li>
<li>HTML5 新增的async属性。</li>
</ul>
<h4 id="4-3-使用外部-JavaScript-和-CSS"><a href="#4-3-使用外部-JavaScript-和-CSS" class="headerlink" title="4.3 使用外部 JavaScript 和 CSS"></a>4.3 使用外部 JavaScript 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少HTTP请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p>
<h4 id="4-4-合并和压缩-JS-CSS-等文件"><a href="#4-4-合并和压缩-JS-CSS-等文件" class="headerlink" title="4.4 合并和压缩 JS/CSS 等文件"></a>4.4 合并和压缩 JS/CSS 等文件</h4><p>通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。</p>
<h4 id="4-5-减少-DOM-操作和使用高效的事件处理"><a href="#4-5-减少-DOM-操作和使用高效的事件处理" class="headerlink" title="4.5 减少 DOM 操作和使用高效的事件处理"></a>4.5 减少 DOM 操作和使用高效的事件处理</h4><ul>
<li>缓存已经访问过的元素；</li>
<li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li>
<li>操作 className，而不是多次读写 style；</li>
<li>避免使用 JavaScript 修复布局；</li>
<li>减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；</li>
<li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li>
</ul>
<h4 id="4-6-图片优化"><a href="#4-6-图片优化" class="headerlink" title="4.6 图片优化"></a>4.6 图片优化</h4><p>如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。</p>
<h4 id="4-7-使用-CND"><a href="#4-7-使用-CND" class="headerlink" title="4.7 使用 CND"></a>4.7 使用 CND</h4><p>&gt;内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
<p>动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。<br>深入阅读 <a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p>
<p>本文参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51" target="_blank" rel="noopener">前端性能优化之雅虎35条军规</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br>MDN<br>维基百科</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/12/20/优先级-和-CSS-预处理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/优先级-和-CSS-预处理/" itemprop="url">优先级 和 CSS 预处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-20T22:30:16+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言扯淡"><a href="#前言扯淡" class="headerlink" title="前言扯淡"></a>前言扯淡</h2><p>前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。<br>需求是最好的学习API的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。</p>
<h2 id="首先是-优先级"><a href="#首先是-优先级" class="headerlink" title="首先是 优先级"></a>首先是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">优先级</a></h2><p>链接是文档，优先级主要是指CSS属性的优先级。</p>
<blockquote>
<p>浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。</p>
</blockquote>
<p>简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 id=&quot;title&quot; class=&quot;title&quot; style=&quot;color: yellow;&quot;&gt;优先级&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--优先级显示为 pink--&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title&#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#title&#123;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1&#123;</span><br><span class="line">  color: pink !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级如何确定："><a href="#优先级如何确定：" class="headerlink" title="优先级如何确定："></a>优先级如何确定：</h4><p>选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）</p>
<ol>
<li><strong>ID选择器</strong>（例如, #title）</li>
<li><strong>类选择器</strong>（class selectors） (例如,.title)，<strong>属性选择器</strong>（attributes selectors）（例如, [type=”radio”]），<strong>伪类</strong>（pseudo-classes）（例如, :hover）</li>
<li><strong>类型选择器</strong>（type selectors）（例如, h1）和 <strong>伪元素</strong>（pseudo-elements）（例如, ::before）</li>
</ol>
<p><strong>通配选择符</strong>（universal selector）(*), <strong>关系选择符</strong>（combinators） (+, &gt;, ~, ‘ ‘)  和 <strong>否定伪类</strong>（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。<br>给元素添加的<strong>内联样式</strong>  (例如, style=”color: yellow;”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。<br><strong>!important</strong> 是例外，此声明将覆盖任何其他声明，技术上!important与优先级无关，但它与它直接相关。</p>
<h4 id="如何利用优先级"><a href="#如何利用优先级" class="headerlink" title="如何利用优先级"></a>如何利用优先级</h4><ol>
<li>选择器越具体，优先级越高。</li>
<li>相同优先级情况下，后面的样式覆盖前面的。</li>
<li>!important 最特殊，有他的声明最优先，但应该避免使用。</li>
</ol>
<p>上面内容均来自 MDN，也就是我给的链接，还有很多如<code>无视DOM树中的距离</code>等没有记录。大家还是直接看MDN为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看MDN文档而收获一些东西，便是此文的意义了。<br>扩展阅读 <a href="https://github.com/jincdream/jincdream.github.io/issues/14" target="_blank" rel="noopener">真正理解”CSS选择器的优先级”</a></p>
<h2 id="CSS预处理（预编译）"><a href="#CSS预处理（预编译）" class="headerlink" title="CSS预处理（预编译）"></a>CSS预处理（预编译）</h2><p>当面试关问我知不知道CSS预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。</p>
<hr>
<p>(以下内容来自 <a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="noopener">再谈 CSS 预处理器</a>)<br>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>
</ul>
<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。</p>
<hr>
<p>这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度EFE的文档比我写肯定高到不知道哪里去了。<br>那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;&#125;</span><br><span class="line">div&gt;ul&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&#123;&#125;</span><br><span class="line">div&gt;ul&gt;li&gt;a&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。</p>
<hr>
<p>本文仅供个人学习使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/11/02/浅谈JS继承/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/02/浅谈JS继承/" itemprop="url">浅谈JS继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-02T20:38:27+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h1><p>根据维基百科解释，可以简单概括为：<br>继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。</p>
<h1 id="JS-里的原型继承模型"><a href="#JS-里的原型继承模型" class="headerlink" title="JS 里的原型继承模型"></a>JS 里的原型继承模型</h1><p>JS：不好意思，我没有类。（即使是ES6中的类也是语法糖）<br>JavaScript 是基于原型实现面向对象的，那么在JS中，面向对象概念中的继承自然也是基于原型。</p>
<blockquote>
<p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>
</blockquote>
<blockquote>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <strong>Object</strong> 的实例。</p>
</blockquote>
<p>有关原型之前写过博客<a href="https://www.jianshu.com/p/93441c4e8f48" target="_blank" rel="noopener">JavaScript原型和原型链</a>，对理解下面内容有帮助。<br>虽然没有传统语言意义上的类，但是 JS语言 使用构造函数生成对象，实现面向对象程序设计。</p>
<h1 id="说了这么多，JS-中的继承到底是什么？"><a href="#说了这么多，JS-中的继承到底是什么？" class="headerlink" title="说了这么多，JS 中的继承到底是什么？"></a>说了这么多，JS 中的继承到底是什么？</h1><p><strong>可以简单理解为：两次的原型搜索就是继承。<br>数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。</strong></p>
<p>接下来我们用代码实现一下继承</p>
<h2 id="1-使用-prototype-实现继承"><a href="#1-使用-prototype-实现继承" class="headerlink" title="1. 使用 prototype 实现继承"></a>1. 使用 prototype 实现继承</h2><p><strong>prototype 的作用：为构造函数内添加实例对象之间的共有属性</strong></p>
<p><strong>明确 JS 内的继承</strong><br>以下面代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个 人类</span><br><span class="line">function Human(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 给所有 人类 添加一个 跑 的共有属性</span><br><span class="line">Human.prototype.run = function()&#123;</span><br><span class="line">  console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">  return undefined</span><br><span class="line">&#125;</span><br><span class="line">// 构造一个 男人类</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Human.call(this, name)</span><br><span class="line">  this.gender = &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 所有 男人 都有好战属性</span><br><span class="line">Man.prototype.fight = function()&#123;</span><br><span class="line">  console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到名为 ada 的人只有 name、gender 和fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。<br><strong>目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。</strong><br>根据我原型知识的博客里面的内容我们知道，我们可以直接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype.__proto__ = Human.prototype</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到 Man 指向了 Human 而不是直接指向 Object，ada2 继承了来自 Human 的 run 属性</p>
<p><strong>但是在实际编程过程中直接操作 <strong> proto </strong> 这个非标准但许多浏览器（IE不支持）实现的属性是不规范的。</strong></p>
<p>那怎么办？<br>new 可不可以？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype = new Human()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>直接用上述代码不行，因为在 new 的过程中，虽然new 内部实现了 <code>Man.prototype.__proto__ = Human.prototype</code> 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined</strong></p>
<p>那么我们只要避免这个过程中 Human 执行就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;&#125;</span><br><span class="line">a.prototype = Human.prototype</span><br><span class="line">Man.prototype = new a()</span><br></pre></td></tr></table></figure></p>
<p>通过上面三行代码，即实现了没有内部执行空函数的 new</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="2-ES6-实现继承"><a href="#2-ES6-实现继承" class="headerlink" title="2. ES6 实现继承"></a>2. ES6 实现继承</h2><p>上面代码的 ES6 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES6 写法</span><br><span class="line">class Human&#123;</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         this.name = name</span><br><span class="line">     &#125;</span><br><span class="line">     run()&#123;</span><br><span class="line">         console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class="line">         return undefined</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class Man extends Human&#123; // extends 实现上述继承过程</span><br><span class="line">     constructor(name)&#123;</span><br><span class="line">         super(name) // 调用构造函数:&apos;超类&apos;</span><br><span class="line">         this.gender = &apos;男&apos;</span><br><span class="line">     &#125;</span><br><span class="line">     fight()&#123;</span><br><span class="line">         console.log(&apos;糊你熊脸&apos;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>JS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。</p>
<blockquote>
<p>原型继承模型本身实际上比经典模型更强大</p>
</blockquote>
<hr>
<p>感谢阅读<br>本文仅供个人学习使用</p>
<p>部分参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/10/28/正则表达式速记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/28/正则表达式速记/" itemprop="url">正则表达式速记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-28T14:15:51+08:00">
                2018-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如何学习：<a href="https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html" target="_blank" rel="noopener">30分钟入门正则表达式</a><br><a href="https://www.regexpal.com/" target="_blank" rel="noopener">工具</a><br>本文参（zhao）考（chao）<a href="https://wangdoc.com/javascript/stdlib/regexp.html" target="_blank" rel="noopener">RegExp 对象</a>，该笔记只为速查</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象，其体系参照 Perl 5 建立。</p>
<h1 id="创建正则表达式的方法"><a href="#创建正则表达式的方法" class="headerlink" title="创建正则表达式的方法"></a>创建正则表达式的方法</h1><ol>
<li><p>使用一个正则表达式字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var re = /xxx/</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 RegExp 对象的构造函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var re = new RegExp(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure>
<p>两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>
<h1 id="正则表达式的实例属性"><a href="#正则表达式的实例属性" class="headerlink" title="正则表达式的实例属性"></a>正则表达式的实例属性</h1><p>分为两类</p>
<ol>
<li>修饰符（只读）<br>RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。用于忽略字符串大小写。<br>RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。用于全局匹配。<br>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。用于设置匹配为多行模式。</li>
<li>其他属性<br>RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。<br>RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ol>
<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><h2 id="1-RegExp-prototype-test"><a href="#1-RegExp-prototype-test" class="headerlink" title="1. RegExp.prototype.test()"></a>1. RegExp.prototype.test()</h2><p>test 方法返回布尔值，表示当前模式是否能匹配参数字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(&apos;and&apos;) // true</span><br></pre></td></tr></table></figure></p>
<h2 id="2-RegExp-prototype-exec"><a href="#2-RegExp-prototype-exec" class="headerlink" title="2. RegExp.prototype.exec()"></a>2. RegExp.prototype.exec()</h2><p>exec方法，用来返回匹配结果<br>如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/.exec(&apos;adbca&apos;)</span><br></pre></td></tr></table></figure></p>
<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</span><br><span class="line">String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</span><br><span class="line">String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</span><br><span class="line">String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ol>
<li>点字符（.)<br>匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</li>
<li><p>位置字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^ 表示字符串的开始位置</span><br><span class="line">$ 表示字符串的结束位置</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择符（|）<br>表示“或关系”</p>
</li>
<li>转义符<br>匹配元字符本身可以在它们前面加反斜杠<br>构造函数需要两次转义</li>
<li>特殊字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</span><br><span class="line">[\b] 匹配退格键(U+0008)，不要与\b混淆。</span><br><span class="line">\n 匹配换行键。</span><br><span class="line">\r 匹配回车键。</span><br><span class="line">\t 匹配制表符 tab（U+0009）。</span><br><span class="line">\v 匹配垂直制表符（U+000B）。</span><br><span class="line">\f 匹配换页符（U+000C）。</span><br><span class="line">\0 匹配null字符（U+0000）。</span><br><span class="line">\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。</span><br><span class="line">\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示x、y、z之中任选一个匹配。</p>
<ol>
<li>脱字符（^）：需在字符类第一位<br>表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</li>
<li>连字符（-）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0-9.,]</span><br><span class="line">[0-9a-fA-F]</span><br><span class="line">[a-zA-Z0-9-]</span><br><span class="line">[1-31] // 不代表1到31，只代表1到3</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="预定义模式：某些常见模式的简写方式"><a href="#预定义模式：某些常见模式的简写方式" class="headerlink" title="预定义模式：某些常见模式的简写方式"></a>预定义模式：某些常见模式的简写方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\d 匹配0-9之间的任一数字，相当于[0-9]。</span><br><span class="line">\D 匹配所有0-9以外的字符，相当于[^0-9]。</span><br><span class="line">\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</span><br><span class="line">\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</span><br><span class="line">\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</span><br><span class="line">\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</span><br><span class="line">\b 匹配词的边界。</span><br><span class="line">\B 匹配非词边界，即在词的内部</span><br></pre></td></tr></table></figure>
<h1 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h1><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p>
<h1 id="量词符：设定某个模式出现的次数"><a href="#量词符：设定某个模式出现的次数" class="headerlink" title="量词符：设定某个模式出现的次数"></a>量词符：设定某个模式出现的次数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。</span><br><span class="line">* 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。</span><br><span class="line">+ 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。</span><br></pre></td></tr></table></figure>
<h1 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure>
<p>贪婪模式改为非贪婪模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</span><br><span class="line">+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</span><br></pre></td></tr></table></figure></p>
<h1 id="字符串去空格-replace"><a href="#字符串去空格-replace" class="headerlink" title="字符串去空格(replace)"></a>字符串去空格(replace)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;  #id div.class  &apos;;</span><br><span class="line">str.trim() // &quot;#id div.class&quot;</span><br><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;) // &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&amp;：匹配的子字符串。</span><br><span class="line">$`：匹配结果前面的文本。</span><br><span class="line">$’：匹配结果后面的文本。</span><br><span class="line">$n：匹配成功的第n组内容，n是从1开始的自然数。</span><br><span class="line">$$：指代美元符号$。</span><br></pre></td></tr></table></figure>
<p>多多练习吧</p>
<hr>
<p>本文仅供个人学习使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/09/27/理解虚拟-DOM/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/理解虚拟-DOM/" itemprop="url">理解虚拟 DOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T21:10:41+08:00">
                2018-09-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DOM-和-Virtual-DOM"><a href="#DOM-和-Virtual-DOM" class="headerlink" title="DOM 和 Virtual DOM"></a>DOM 和 Virtual DOM</h1><p><strong>DOM：Document Object Model 把文档变成对象的模型<br>在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。<br>问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？<br>你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。<br>方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。<br>在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。</strong></p>
<p><code>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</code></p>
<h1 id="过程实现"><a href="#过程实现" class="headerlink" title="过程实现"></a>过程实现</h1><p>文档界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./v-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个 VNode 类</span><br><span class="line">class VNode &#123;</span><br><span class="line">    constructor(tag, children, text) &#123;</span><br><span class="line">        this.tag = tag</span><br><span class="line">        this.children = children</span><br><span class="line">        this.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; // render 方法，创建子元素</span><br><span class="line">        if (this.tag === &apos;#text&apos;) &#123;</span><br><span class="line">            return document.createTextNode(this.text)</span><br><span class="line">        &#125;</span><br><span class="line">        let el = document.createElement(this.tag)</span><br><span class="line">        this.children.forEach(vChild =&gt; &#123;</span><br><span class="line">            el.appendChild(vChild.render())</span><br><span class="line">        &#125;)</span><br><span class="line">        return el</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// v 构造函数，判断子元素类型</span><br><span class="line">function v(tag, children, text) &#123;</span><br><span class="line">    if (typeof children === &apos;string&apos;) &#123;</span><br><span class="line">        text = children</span><br><span class="line">        children = []</span><br><span class="line">    &#125;</span><br><span class="line">    return new VNode(tag, children, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let vNode = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class="line">])</span><br><span class="line">const root = document.querySelector(&apos;#root&apos;)</span><br><span class="line">root.appendChild(vNode.render())</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中<br><img src="https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function patchElement(parent, newVNode, oldVNode, index = 0) &#123;</span><br><span class="line">    if (!oldVNode) &#123;</span><br><span class="line">        parent.appendChild(newVNode.render())</span><br><span class="line">    &#125; else if (!newVNode) &#123;</span><br><span class="line">        parent.removeChild(parent.childNodes[index])</span><br><span class="line">    &#125; else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123;</span><br><span class="line">        parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class="line">            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。</p>
<p>整个状态变更的过程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建虚拟DOM</span><br><span class="line">let vNode = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class="line">])</span><br><span class="line">// 3. 生成新的虚拟DOM</span><br><span class="line">let vNode1 = v(&apos;div&apos;, [</span><br><span class="line">    v(&apos;p&apos;, [</span><br><span class="line">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class="line">    ]),</span><br><span class="line">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)]),</span><br><span class="line">    v(&apos;p&apos;, [v(&apos;#text&apos;, &apos;upload&apos;)])</span><br><span class="line">])</span><br><span class="line">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class="line">const root = document.querySelector(&apos;#root&apos;)</span><br><span class="line">patchElement(root, vNode)</span><br><span class="line">var n = 0</span><br><span class="line">// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更</span><br><span class="line">document.querySelector(&apos;.btn&apos;).onclick = function () &#123;</span><br><span class="line">    if (n % 2 == 0) &#123;</span><br><span class="line">        patchElement(root, vNode1, vNode)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        patchElement(root, vNode, vNode1)</span><br><span class="line">    &#125;</span><br><span class="line">    n += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本文仅供个人学习使用</p>
<hr>
<p>主要参考：<a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">深度剖析：如何实现一个 Virtual DOM 算法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/09/16/HTTP-学习之-Cookie/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/16/HTTP-学习之-Cookie/" itemprop="url">HTTP 学习之 Cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-16T18:43:31+08:00">
                2018-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h2><p>今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识<br><code>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</code></p>
<p>我们知道，服务器和客户端（浏览器）之间通过 HTTP 发送请求和响应来交流。<br>但是 HTTP 是<a href="https://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="noopener">无状态协议</a>：这样做当然能够减少服务器负担，服务器不必记录每一次请求和响应的状态，但这严重阻碍了<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" title="交互式Web应用程序" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。</p>
<p><strong>所以就有了 Cookie 技术：在请求和响应的报文中写入 Cookie 信息来控制客户端状态。</strong></p>
<ul>
<li>服务器通过 Set-Cookie 响应头设置 Cookie</li>
<li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li>
<li>服务器发现并读取 Cookie 就知道对应客户端的状态信息</li>
</ul>
<p>Cookie主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong>通过 HTTP 协议和 Cookie 技术的协同作用，服务器与客户端之间就可以既快速（HTTP 无状态）又可控（Cookie 有状态）得请求和响应并交互了。<br>当然，由于 Cookie 的安全性等问题，有了 Session（服务器的一小块内存）本文不涉及</strong></p>
<h2 id="在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情"><a href="#在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情" class="headerlink" title="在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 API 详情"></a>在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value" target="_blank" rel="noopener">API 详情</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;`)</span><br></pre></td></tr></table></figure>
<p>(这是我写的关于登录注册 demo 里登录请求成功的服务端响应 Cookie 内容部分，完整的代码有兴趣可以看我 <a href="https://github.com/Adashuai5/node-demo/tree/master/cookie-demo" target="_blank" rel="noopener">github</a>，有关 node.js 搭建简单的服务器的内容可以看我相关博客)</p>
<p>如图当 <a href="mailto:1@ada.com" target="_blank" rel="noopener">1@ada.com</a> 用户发送登录请求成功，服务器返回响应的响应头（Response Headers）内出现 Set - Cookie <img src="https://upload-images.jianshu.io/upload_images/7094266-fdff2ea48f36c28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">其他页面（只要是同源域名）都将带上 Cookie 信息（这里我们并没有设置其他内容）<img src="https://upload-images.jianshu.io/upload_images/7094266-341585400a01ecf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>设置多个 Cookies<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;, [`sign_in_email = $&#123;email&#125;`, &apos;language=javascript&apos;]);</span><br></pre></td></tr></table></figure></p>
<p>在开发者工具里的 Application 界面里有 Cookies 我们可以随意设置其 cookie <img src="http://upload-images.jianshu.io/upload_images/7094266-637c2da4867f4daf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Set-Cookie-字段还可以附加-Cookie-的属性-MDN"><a href="#Set-Cookie-字段还可以附加-Cookie-的属性-MDN" class="headerlink" title="Set-Cookie 字段还可以附加 Cookie 的属性 MDN"></a>Set-Cookie 字段还可以附加 Cookie 的属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">MDN</a></h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-479fc61fdf79ed54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常用属性"><br><strong>多个属性之间用 ; 连接，下面代码添加了 Secure 和 HttpOnly 属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;;Secure;HttpOnly`)</span><br></pre></td></tr></table></figure></p>
<p><strong>可以通过设置 Set-Cookie 的 Max-Age 属性 和 Expires 属性</strong><br>以 node.js 为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;,&apos; Max-Age=1000; Expires=Sun, 16 Sep 2018 10:05:35 GMT&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码设置了响应头在1000秒后 cookie 失效，同时指定了 Expires 和Max-Age，那么Max-Age的值将优先生效</p>
<p>关闭 session（会话）即可删除内存 Cookie；上述过期时间达到则会删除硬盘 Cookie，因此可以通过设置过期时间删除 Cookie<br>我们还可以通过手动清除浏览器 Cookie 及缓存删除 cookie</p>
<p><strong>相关内容可以参考<br><a href="http://javascript.ruanyifeng.com/bom/cookie.html#toc4" target="_blank" rel="noopener">Cookie 的属性</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP Cookie</a><br><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">Cookie-wikipedia</a><br>同时这也是本文参考内容，另外还参考了 《图解HTTP》相关章节</strong></p>
<hr>
<p>本文仅供个人学习使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/09/10/CSS常用布局-续篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/CSS常用布局-续篇/" itemprop="url">CSS常用布局 续篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T10:32:52+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>几个月前初学 CSS布局，写了一篇关于 <a href="https://www.jianshu.com/p/59c9477816b8" target="_blank" rel="noopener">CSS常用布局学习</a> 的博客，介绍了一些传统的依靠 position 和 float 等实现简单的布局方式的例子，这些布局只能简单得实现基本功能，十分不便。<br>今天，作为引申，我们用同样例子，来使用上篇中简单提到的 flex 布局的方案实现。与此同时，我将推荐最近学习的 grid 布局，它十分强大，可以方便得解决各种布局方案，且十分便于理解。</p>
<h3 id="Flex-实现左中右布局"><a href="#Flex-实现左中右布局" class="headerlink" title="Flex 实现左中右布局"></a>Flex 实现左中右布局</h3><p>主要是在父元素中使用以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">flex-direction:row;</span><br></pre></td></tr></table></figure></p>
<p>相对于传统布局，是不是简便得多<img src="https://upload-images.jianshu.io/upload_images/7094266-f0d2834c90f115a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flex 左中右"></p>
<h3 id="Flex-实现垂直居中"><a href="#Flex-实现垂直居中" class="headerlink" title="Flex 实现垂直居中"></a>Flex 实现垂直居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-42ece01a2af28519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flex 垂直居中"></p>
<p>可以看到 flex 布局十分方便<br>想要了解更多 flex 布局相关技巧可以阅读阮大大 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">博客</a> 当然你可以看 MDN</p>
<p>前面介绍的都是一维布局，但是在复杂的二维布局方面，无疑是为解决布局而创建的 CSS 网格布局更为专业<br>学习网格布局事实上是学习对应英文的过程，所以英语好真的很有优势</p>
<h3 id="Grid-布局实现左中右"><a href="#Grid-布局实现左中右" class="headerlink" title="Grid 布局实现左中右"></a>Grid 布局实现左中右</h3><p>虽然有点大材小用，但是我们是为了和前面的布局方法做对比<br>你只需用两行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 30% 40% 30%;</span><br></pre></td></tr></table></figure></p>
<p>grid 布局的代码更省，子元素不需要各自设定，直接在父元素上设定了<img src="https://upload-images.jianshu.io/upload_images/7094266-beb5abb9ff73f97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Grid 左中右">当然这里的子元素要与对应的格子相配，即 30% 40% 30% 对应的是 div.container 里面的顺序</p>
<h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>这里的 fr 为分数单位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 1fr 1fr 1fr; // 3列均分</span><br><span class="line">grid-template-rows: 1fr 1fr 1fr; // 3行均分</span><br></pre></td></tr></table></figure></p>
<p>通过上面代码实现了一个3*3的网格<br>可以通过下面代码选择对应网格，并添加属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-column: 1; // or 2 or 3</span><br><span class="line">grid-row: 1; // or 2 or 3</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-fe08051eb5cf5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网格布局示例"></p>
<hr>
<p>以上只是 flex 布局和 grid 布局的小例子和基本用法<br>想要了解更多 grid 相关内容可以看这篇 <a href="https://www.jianshu.com/p/d183265a8dad" target="_blank" rel="noopener">博客</a><br>通过 flex 和 grid 布局配合使用，基本上可以解决所有 CSS 布局问题</p>
<p>本文仅供个人学习使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/09/04/AJAX-是什么鬼/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/AJAX-是什么鬼/" itemprop="url">AJAX 是什么鬼</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T20:57:25+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前写了一篇博客<a href="https://www.jianshu.com/p/2a2fe02917e7" target="_blank" rel="noopener">理解JSONP 上</a>关于AJAX出现之前如何发请求<br>简单回顾一下：</p>
<h4 id="1-用-form-可以发请求，缺点是会刷新页面或新开页面"><a href="#1-用-form-可以发请求，缺点是会刷新页面或新开页面" class="headerlink" title="1.用 form 可以发请求，缺点是会刷新页面或新开页面"></a>1.用 form 可以发请求，缺点是会刷新页面或新开页面</h4><p>form发送get请求：<img src="https://upload-images.jianshu.io/upload_images/7094266-8a9a80cde134701d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>输入密码后，点击提交，打开开发者工具可以看到一个get请求，点开找到Request Headers点击<strong>view source</strong> <img src="https://upload-images.jianshu.io/upload_images/7094266-2f497d2ed697fabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>同样可以用form发送post请求，与get请求区别是post请求没有查询参数<img src="https://upload-images.jianshu.io/upload_images/7094266-2a9955c21d5904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>post请求的第四部分 password在下面的 Form Data 的<strong>view source</strong> 里<img src="https://upload-images.jianshu.io/upload_images/7094266-c10130216b9836f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="2-用-a-可以发-get-请求，但是也会刷新页面或新开页面"><a href="#2-用-a-可以发-get-请求，但是也会刷新页面或新开页面" class="headerlink" title="2.用 a 可以发 get 请求，但是也会刷新页面或新开页面"></a>2.用 a 可以发 get 请求，但是也会刷新页面或新开页面</h4><p>点击click就发送请求<img src="https://upload-images.jianshu.io/upload_images/7094266-e8ecdf0d63d5c019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;ada&quot; href=&quot;/ada&quot;&gt;click&lt;/a&gt;</span><br><span class="line">//运行一个脚本，让网页自己点击（但是依然会刷新页面）</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ada.click()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示"><a href="#3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示" class="headerlink" title="3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示"></a>3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var image = document.createElement(&apos;img&apos;)</span><br><span class="line">  image.src = &apos;/ada&apos;</span><br><span class="line">  image.onload = function()&#123;</span><br><span class="line">    console.log(&apos;succsee&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  image.onerror = function()&#123;</span><br><span class="line">    console.log(&apos;fail&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-9b2b91b49a0575b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示"><a href="#4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示" class="headerlink" title="4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示"></a>4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var link = document.createElement(&apos;link&apos;)</span><br><span class="line">  link.rel = &apos;stylesheet&apos;</span><br><span class="line">  link.href = &apos;/ada&apos;</span><br><span class="line">  //需要将link放到页面中才能发送请求</span><br><span class="line">  document.head.appendChild(link)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-ff9dc05b89603af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="5-用-script-可以发-get-请求，但是只能以脚本的形式运行"><a href="#5-用-script-可以发-get-请求，但是只能以脚本的形式运行" class="headerlink" title="5.用 script 可以发 get 请求，但是只能以脚本的形式运行"></a>5.用 script 可以发 get 请求，但是只能以脚本的形式运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;)</span><br><span class="line">  script.src = &quot;/ada&quot;</span><br><span class="line">  //需要将script放到页面中才能发送请求</span><br><span class="line">  document.head.appendChild(script)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当然还有其他方法</p>
<hr>
<p>有关AJAX的学习推荐<a href="http://javascript.ruanyifeng.com/bom/ajax.html#toc0" target="_blank" rel="noopener">阮一峰博客</a><br><strong>微软的突破</strong><br>IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。<br>随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范<br><strong>AJAX</strong><br>Jesse James Garrett 将如下技术取名叫做 AJAX（Asynchronous JavaScript and XML）：异步的 JavaScript 和 XML<br><strong><em>1.使用 XMLHttpRequest 发请求<br>2.服务器返回 XML 格式的字符串<br>3.JS 解析 XML，并更新局部页面</em></strong></p>
<h4 id="同样我们用node服务器来尝试一下这三个条件-AJAX"><a href="#同样我们用node服务器来尝试一下这三个条件-AJAX" class="headerlink" title="同样我们用node服务器来尝试一下这三个条件(AJAX)"></a>同样我们用node服务器来尝试一下这三个条件(AJAX)</h4><p>新建html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    hi</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>Node代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;含查询字符串的路径\n&apos; + pathWithQuery)</span><br><span class="line">  if (path === &apos;/&apos;) &#123;</span><br><span class="line">    var string = fs.readFileSync(&apos;./index.html&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;找不到服务器&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于HTTP来说，响应的第四部分始终是string<img src="https://upload-images.jianshu.io/upload_images/7094266-01746a588b0abc36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在 html 里创建一个button，引入当前目录下的 js 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>Node代码//在原Node代码中插入，下同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注意这里是 /main.js 而不是 ./main.js，因为HTTP请求永远是绝对路径</span><br><span class="line">else if (path === &apos;/main.js&apos;) &#123;</span><br><span class="line">//这里当然是./main.js</span><br><span class="line">    var string = fs.readFileSync(&apos;./main.js&apos;, &apos;utf8&apos;)</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>首先满足1.使用 XMLHttpRequest 发请求</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class="line">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class="line">    request.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>2.服务器返回 XML 格式的字符串</strong><br>XML已经不流行了，但是我们依然可以尝试一下<br>找一个一个XML example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">else if (path === &apos;/ada&apos;) &#123;</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class="line">    response.write(`</span><br><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;note&gt;</span><br><span class="line">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;`)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-d5529f18c6d6d036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>3.JS 解析 XML，并更新局部页面</strong><br>浏览器是分步下载响应的，一般只要记住 <strong>readyState === 4</strong> 表示请求完成<img src="https://upload-images.jianshu.io/upload_images/7094266-a27d3791360b1d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以用 <strong>onreadystatechange</strong> 监听 readyState<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState === 4) &#123;</span><br><span class="line">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class="line"></span><br><span class="line">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">                console.log(&apos;success&apos;)</span><br><span class="line">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class="line">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class="line">                console.log(&apos;fail&apos;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class="line">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class="line">    request.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-6159a07fdb534df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如果把(path === ‘/ada’){}里改成400  //注意不要改错地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.statusCode = 400</span><br></pre></td></tr></table></figure></p>
<p>当然会返回 fail，可以看到 readyState 是不受状态码影响的<img src="https://upload-images.jianshu.io/upload_images/7094266-dc4181f8240aa1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>JS 是可以解析 XML的，但是现在XML已经被JSON取代了，我们可以简单打印出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(request.responseText)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-beb53639db92273c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<p><a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a><br>JSON是道格拉斯基于JavaScript发明的数据交换语言</p>
<ul>
<li>特点：<ul>
<li></li>
<li>只有 object、array、string、number、true、false、null 这几种类型</li>
<li>字符串首尾必须为双引号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JS         VS         JSON</span><br><span class="line">undefined/symbel      无</span><br><span class="line">null                  null</span><br><span class="line">[&apos;a&apos;,&apos;b&apos;]             [&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">function f()&#123;&#125;        无</span><br><span class="line">&#123;a:b&#125;                 &#123;&quot;a&quot;,&quot;b&quot;&#125;</span><br><span class="line">&apos;hello world&apos;         &quot;hello world&quot;</span><br><span class="line">var a = &#123;&#125;</span><br><span class="line">a.self = a            无法做到&#123;无变量等形式&#125;</span><br><span class="line">&#123;__proto__&#125;           没有原型链</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>用JSON替换XML</strong><br>Node代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">else if (path === &apos;/ada&apos;) &#123;</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class="line">//变XML为JSON，key和value都可以替换成自己喜欢的</span><br><span class="line">    response.write(`</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;note&quot;:&#123;</span><br><span class="line">        &quot;to&quot;: &quot;reader&quot;,</span><br><span class="line">        &quot;from&quot;: &quot;Ada&quot;,</span><br><span class="line">        &quot;heading&quot;: &quot;greet&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;hello word!&quot;</span><br><span class="line">    &#125;`)</span><br><span class="line">    response.end()</span><br></pre></td></tr></table></figure></p>
<p>js完整代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState === 4) &#123;</span><br><span class="line">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class="line"></span><br><span class="line">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">                console.log(&apos;success&apos;)</span><br><span class="line">                console.log(typeof request.responseText)</span><br><span class="line">                console.log(request.responseText)</span><br><span class="line">                let string = request.responseText</span><br><span class="line">                // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class="line">                let object = window.JSON.parse(string)</span><br><span class="line">                // JSON.parse 是浏览器提供的</span><br><span class="line">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class="line">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class="line">                console.log(&apos;fail&apos;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class="line">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class="line">    request.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-4f376b146466e10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<h2 id="同源政策"><a href="#同源政策" class="headerlink" title="同源政策"></a>同源政策</h2><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>文章开头提到的 form 和 a 等发送请求是没有同源政策的，而AJAX是可以读取响应内容的。</p>
<h2 id="因此只有-协议-端口-域名-一模一样（同源）才允许发-AJAX-请求"><a href="#因此只有-协议-端口-域名-一模一样（同源）才允许发-AJAX-请求" class="headerlink" title="因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求"></a><strong>因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求</strong></h2><h2 id="如何规避同源政策？跨域"><a href="#如何规避同源政策？跨域" class="headerlink" title="如何规避同源政策？跨域"></a>如何规避同源政策？跨域</h2><p>有关JSONP跨域在文章开头提供我的博客举过例子<br>这次我们用 <strong>CORS 跨域</strong></p>
<h2 id="什么是-CORS-Cross-Origin-Resource-Sharing-跨域资源共享"><a href="#什么是-CORS-Cross-Origin-Resource-Sharing-跨域资源共享" class="headerlink" title="什么是 CORS:Cross-Origin Resource Sharing(跨域资源共享)"></a>什么是 CORS:<strong>Cross-Origin Resource Sharing(跨域资源共享)</strong></h2><p>同样用<a href="https://www.jianshu.com/p/38a72bd0e37d" target="_blank" rel="noopener">理解JSONP 下</a>博客中创建过的网站来举例子<br>首先打开服务器端口<img src="https://upload-images.jianshu.io/upload_images/7094266-49fcd7432b2c7d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>把请求路径改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.open(&apos;GET&apos;, &apos;http://jack.com:8002/ada&apos;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-706af4f9ecdace99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击点我<img src="https://upload-images.jianshu.io/upload_images/7094266-7a4b7e5d44756b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">报错了，因为不是同源，响应完成却得不到任何内容</p>
<p><strong>解决方法，在Node代码中加入一句</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许 http://ada.com:8001 访问我</span><br><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://ada.com:8001&apos;)</span><br></pre></td></tr></table></figure></p>
<p>点击点我，即可向 ada.com:8001 发送请求并返回 jack.com:8002/ada 的响应内容<img src="https://upload-images.jianshu.io/upload_images/7094266-1797c104e4b05d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这就是用CORS实现AJAX跨域的过程</p>
<p>完整代码详见 <a href="https://github.com/Adashuai5/node-demo/tree/master/AJAX-demo" target="_blank" rel="noopener">github</a></p>
<hr>
<p>本文仅供个人学习使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/09/02/OOP-初探（给-MVC-添加类）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/OOP-初探（给-MVC-添加类）/" itemprop="url">OOP 初探（给 MVC 添加类）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T16:49:17+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象程序设计：Object-oriented-programming-OOP"><a href="#面向对象程序设计：Object-oriented-programming-OOP" class="headerlink" title="面向对象程序设计：Object-oriented programming(OOP)"></a>面向对象程序设计：Object-oriented programming(OOP)</h1><p><strong>命名空间：name space</strong><br>什么是命名空间？我们来看看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">MDN</a> 的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局命名空间</span><br><span class="line">var MYAPP = MYAPP || &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>这里补充有关逻辑运算符的知识</strong><br>逻辑运算符：且（&amp;&amp;）、或（||）<br><strong>&amp;&amp; 运算符返回第一个 falsy 值（停止运算），若无 falsy 值，则返回最后一个 truthy 值</strong><br>只有（0；NaN；null；undefined；空字符串(‘ ‘)）五个是 falsy 值，除此之外其他都是 truthy 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1) &amp;&amp; 0 // 1</span><br></pre></td></tr></table></figure></p>
<p>注意这里 console.log(1) 是返回值是 undefined （falsy 值），因此直接返回打印结果 1<br>而不是返回第二个 falsy 值 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &amp;&amp; console.log(n) // 0</span><br></pre></td></tr></table></figure></p>
<p>注意这里不会报错说 Uncaught ReferenceError: n is not defined<br>因为 0 已经是 falsy 值所以直接返回，运算停止后面代码不再执行</p>
<h2 id="运算符返回第一个-truthy-值（停止运算），若无-truthy-值，则返回最后一个-falsy-值"><a href="#运算符返回第一个-truthy-值（停止运算），若无-truthy-值，则返回最后一个-falsy-值" class="headerlink" title="|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值"></a><strong>|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值</strong></h2><p>因此上面代码等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 首先检查MYAPP是否已经被定义</span><br><span class="line">var MYAPP</span><br><span class="line">// 是的话，那么使用现有的MYAPP全局对象</span><br><span class="line">if(MYAPP)&#123;</span><br><span class="line">  MYAPP = MYAPP;</span><br><span class="line">// 创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  MYAPP = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以基于 MYAPP 这一 name 的空间来放置所有与 MYAPP 相关的子命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 子命名空间</span><br><span class="line">MYAPP.event = &#123;&#125;;</span><br><span class="line">MYAPP.commonMethod = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>在JavaScript中，命名空间只是另一个包含 方法，属性，对象 的对象</em></strong><br>我们常见的文件夹就类似一个命名空间</p>
<hr>
<p><strong>构造函数：constructor（类：class）</strong><br>JavaScript 基于原型，没有类的概念；但是我们可以定义一个类<br>下面代码就是一个新的类 Person<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123; &#125; </span><br><span class="line">// 或</span><br><span class="line">var Person = function()&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 中类的本质是函数，只是它有两个特点：<br><strong>1.函数体内部使用了this关键字，代表了所要生成的对象实例。<br>2.生成对象的时候，必须使用new命令<br>这两个特点就形成了所谓的构造函数</strong><br><em>为了与普通函数区别，构造函数名字的第一个字母通常大写，如这里的Person</em></p>
<p><strong>对象（类的实例）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123; &#125;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br></pre></td></tr></table></figure></p>
<p>以 Person 为类（模版），person1 和 person2 是 Person 新的实例：person1、person2 可以调用函数 Person</p>
<h1 id="为什么会有面向对象编程？"><a href="#为什么会有面向对象编程？" class="headerlink" title="为什么会有面向对象编程？"></a>为什么会有面向对象编程？</h1><p>你写了一个 person1 ，又写了一个 person2 ，然后又写了一个 person3 。。。<br>它们有很多重复的代码：这些代码结构一致（如我们之前的 <a href="https://zhuanlan.zhihu.com/p/42366912" target="_blank" rel="noopener">MVC 设计模式</a>），简直浪费内存（内存条那么贵）<br><strong>于是就有了 Person 这个构造函数作为对象的模板：把所有相同结构的代码用一个函数封装起来<br>可以让 person1 等只需要用 new 的方法调用这个 Person 传入参数来使用它的模版，person1 自身属性，再单独罗列即可</strong></p>
<p><strong>下面以之前有关MVC 的 <a href="https://zhuanlan.zhihu.com/p/42366912" target="_blank" rel="noopener">博客</a> 中的代码为例</strong><br>原来代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">! function () &#123;</span><br><span class="line">    // MVC 的 V</span><br><span class="line">    var view = document.querySelector(&apos;section.message&apos;)</span><br><span class="line">    //添加 M</span><br><span class="line">    var model = &#123;</span><br><span class="line">        init: function () &#123;</span><br><span class="line">            var APP_ID = &apos;2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz&apos;</span><br><span class="line">            var APP_KEY = &apos;iByF5Dy55tJodAoxC4cxwAwx&apos;</span><br><span class="line"></span><br><span class="line">            AV.init(&#123;</span><br><span class="line">                appId: APP_ID,</span><br><span class="line">                appKey: APP_KEY</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //获取所有数据</span><br><span class="line">        fetch: function () &#123;</span><br><span class="line">            var query = new AV.Query(&apos;Message&apos;)</span><br><span class="line">            return query.find() //Promise 对象</span><br><span class="line">        &#125;,</span><br><span class="line">        //创建数据</span><br><span class="line">        save: function (name,content) &#123;</span><br><span class="line">            var Message = AV.Object.extend(&apos;Message&apos;);</span><br><span class="line">            var message = new Message();</span><br><span class="line">            return message.save(&#123; //Promise 对象</span><br><span class="line">                name: name,</span><br><span class="line">                content: content</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // MVC 的 C</span><br><span class="line">    var controller = &#123;</span><br><span class="line">        view: null,</span><br><span class="line">        model: null,</span><br><span class="line">        messageList: null,</span><br><span class="line">        init: function (view, model) &#123;</span><br><span class="line">            this.view = view</span><br><span class="line">            this.model = model</span><br><span class="line">            this.messageList = view.querySelector(&apos;#messageList&apos;)</span><br><span class="line">            this.form = view.querySelector(&apos;form&apos;)</span><br><span class="line">            this.model.init()</span><br><span class="line">            this.loadMessages()</span><br><span class="line">            this.bindEvents()</span><br><span class="line">        &#125;,</span><br><span class="line">        loadMessages: function () &#123;</span><br><span class="line">            this.model.fetch().then((messages) =&gt; &#123;</span><br><span class="line">                let array = messages.map((item) =&gt; item.attributes)</span><br><span class="line">                array.forEach((item) =&gt; &#123;</span><br><span class="line">                    let li = document.createElement(&apos;li&apos;)</span><br><span class="line">                    li.innerText = `$&#123;item.name&#125; : $&#123;item.content&#125;`</span><br><span class="line">                    this.messageList.appendChild(li)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        bindEvents: function () &#123;</span><br><span class="line">            this.form.addEventListener(&apos;submit&apos;, (e) =&gt; &#123;</span><br><span class="line">                e.preventDefault()</span><br><span class="line">                this.saveMessage()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        saveMessage: function () &#123;</span><br><span class="line">            let myForm = this.form</span><br><span class="line">            let content = myForm.querySelector(&apos;input[name=content]&apos;).value</span><br><span class="line">            let name = myForm.querySelector(&apos;input[name=name]&apos;).value</span><br><span class="line">            this.model.save(name, content).then(function (object) &#123;</span><br><span class="line">                let li = document.createElement(&apos;li&apos;)</span><br><span class="line">                li.innerText = `$&#123;object.attributes.name&#125; : $&#123;object.attributes.content&#125;`</span><br><span class="line">                let messageList = document.querySelector(&apos;#messageList&apos;)</span><br><span class="line">                messageList.appendChild(li)</span><br><span class="line">                myForm.querySelector(&apos;input[name=content]&apos;).value = &apos;&apos;</span><br><span class="line">                console.log(object)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    controller.init(view, model)</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure></p>
<p><strong>把 M、V、C 三个模版单独分出</strong><br>M 的模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Model 办事，我放心</span><br><span class="line">// 通过全局函数 window 引入 Model 便于所有 model 调用</span><br><span class="line">// 提供三个参数：Options、resourceName 和 object</span><br><span class="line">window.Model = function (Options) &#123;</span><br><span class="line">    let resourceName = Options.resourceName</span><br><span class="line">    return &#123;</span><br><span class="line">        init: function () &#123;</span><br><span class="line">            var APP_ID = &apos;2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz&apos;</span><br><span class="line">            var APP_KEY = &apos;iByF5Dy55tJodAoxC4cxwAwx&apos;</span><br><span class="line"></span><br><span class="line">            AV.init(&#123;</span><br><span class="line">                appId: APP_ID,</span><br><span class="line">                appKey: APP_KEY</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fetch: function () &#123;</span><br><span class="line">            var query = new AV.Query(resourceName)</span><br><span class="line">            return query.find()</span><br><span class="line">        &#125;,</span><br><span class="line">        //创建数据</span><br><span class="line">        save: function (object) &#123;</span><br><span class="line">            var X = AV.Object.extend(resourceName)</span><br><span class="line">            var x = new X();</span><br><span class="line">            return x.save(object)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>V 就比较简单了，就一句话，但是封装后也可以调用以便减少代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.View = function(Selector)&#123;</span><br><span class="line">    return document.querySelector(Selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 C 是有一定难点的，需要对 this 的概念有所理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.Controller = function (options) &#123;</span><br><span class="line">    var init = options.init //这个 init 就是 controller 传进来的，记为 initB</span><br><span class="line">    // 4-21 return 一个 object</span><br><span class="line">    let object = &#123;</span><br><span class="line">        view: null,</span><br><span class="line">        model: null,</span><br><span class="line">        init: function (view, model) &#123; // 注意这里的 init 是 object 的属性,记为 initA</span><br><span class="line">            this.view = view</span><br><span class="line">            this.model = model</span><br><span class="line">            this.model.init()</span><br><span class="line">            // 3.initB.call(this)</span><br><span class="line">            init.call(this, view, model) // 这里的 init 当然是 initB，写成这样 init(view,model) 你就懂了</span><br><span class="line">            this.bindEvents.call(this)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    // 把除 init 外的所有 options 的参数传给 object</span><br><span class="line">    // init 是公共参数，而其他实例独有的参数需要传进来</span><br><span class="line">    for (let key in options) &#123;</span><br><span class="line">        if (key !== &apos;init&apos;) &#123;</span><br><span class="line">            object[key] = options[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例代码：现在可以直接调用 M、V、C 了，其他实例也是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">! function () &#123;</span><br><span class="line">	// MVC 的 V</span><br><span class="line">	// 这里 window.View 的 window 可以省略，是默认的</span><br><span class="line">	var view = View(&apos;section.message&apos;)</span><br><span class="line">	//添加 M</span><br><span class="line">	var model = Model(&#123;</span><br><span class="line">		resourceName: &apos;Message&apos;</span><br><span class="line">	&#125;)</span><br><span class="line">	// MVC 的 C</span><br><span class="line">	// 1.controller === object</span><br><span class="line">	var controller = Controller(&#123;</span><br><span class="line">		init: function () &#123;</span><br><span class="line">			this.messageList = view.querySelector(&apos;#messageList&apos;)</span><br><span class="line">			this.form = view.querySelector(&apos;form&apos;)</span><br><span class="line">			this.loadMessages()</span><br><span class="line">			// 这里的 this 是 object，但是 object 没有上面参数</span><br><span class="line">			// 所以才要 for...in...遍历一下，让 object 有这些 controller 独有的参数</span><br><span class="line">		&#125;,</span><br><span class="line">		loadMessages: function () &#123;</span><br><span class="line">			this.model.fetch().then((messages) =&gt; &#123;</span><br><span class="line">				let array = messages.map((item) =&gt; item.attributes)</span><br><span class="line">				array.forEach((item) =&gt; &#123;</span><br><span class="line">					let li = document.createElement(&apos;li&apos;)</span><br><span class="line">					li.innerText = `$&#123;item.name&#125; : $&#123;item.content&#125;`</span><br><span class="line">					this.messageList.appendChild(li)</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		bindEvents: function () &#123;</span><br><span class="line">			this.form.addEventListener(&apos;submit&apos;, (e) =&gt; &#123;</span><br><span class="line">				e.preventDefault()</span><br><span class="line">				this.saveMessage()</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		saveMessage: function () &#123;</span><br><span class="line">			let myForm = this.form</span><br><span class="line">			let content = myForm.querySelector(&apos;input[name=content]&apos;).value</span><br><span class="line">			let name = myForm.querySelector(&apos;input[name=name]&apos;).value</span><br><span class="line">			this.model.save(&#123;</span><br><span class="line">				name: name,</span><br><span class="line">				content: content</span><br><span class="line">			&#125;).then(function (object) &#123;</span><br><span class="line">				let li = document.createElement(&apos;li&apos;)</span><br><span class="line">				li.innerText = `$&#123;object.attributes.name&#125; : $&#123;object.attributes.content&#125;`</span><br><span class="line">				let messageList = document.querySelector(&apos;#messageList&apos;)</span><br><span class="line">				messageList.appendChild(li)</span><br><span class="line">				myForm.querySelector(&apos;input[name=content]&apos;).value = &apos;&apos;</span><br><span class="line">				console.log(object)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	// 2.controller.init(view, model)</span><br><span class="line">	controller.init(view, model)</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure></p>
<h1 id="关于-this"><a href="#关于-this" class="headerlink" title="关于 this"></a>关于 this</h1><p>我们以 C：controller 部分封装的代码的 this 为例：所有内容已经在代码中注明，我们来总结一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.controller === object</span><br><span class="line">2.controller.init(view, model)</span><br><span class="line">  写成 call 的形式：controller.init.call(controller, view, model)</span><br><span class="line"> // MDN 里 this 文档告诉我们：this 是 call 的第一个参数</span><br><span class="line">  显然 controller.init 里面的 this 当然是 controller</span><br><span class="line">  那它还是 object：即 controller.init 里面的 this 就是 object</span><br><span class="line">  相当于 object.init 里面的 this 是 object</span><br><span class="line">3.initB.call(this)</span><br><span class="line">  initB 里面的 this === call 后面的this</span><br><span class="line">  call 后面 this === 第二条里的 this</span><br><span class="line">  第二条里面的 this === object</span><br><span class="line">  =&gt; initB 里面的 this 就是 object</span><br></pre></td></tr></table></figure></p>
<p>想了解更多有关 this 知识，移步 <a href="https://www.jianshu.com/p/bd9d8bd248ab" target="_blank" rel="noopener">搞懂这些 你就理解 this 了</a></p>
<hr>
<p>本文仅供个人学习使用</p>
<p><strong>未完待续。。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adashuai5.com/2018/08/27/搞懂这些-你就理解-this-了/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yuanda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ada 的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/搞懂这些-你就理解-this-了/" itemprop="url">搞懂这些 你就理解 this 了</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T00:48:41+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>新人推荐先看阮大大的书的：<a href="https://wangdoc.com/javascript/oop/this.html#%E6%B6%B5%E4%B9%89" target="_blank" rel="noopener">相关章节</a><br>有关 this 的理解，方老师的这篇 <a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">文章</a> 已经很完美了</p>
<p><strong>你应该已经知道并熟记 this 是 call 的第一个参数</strong><br>下面是一些 this 的特殊情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 例 1</span><br><span class="line">button.onclick = function f1()&#123;</span><br><span class="line">    console.log(this) // 触发事件的元素。  button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1 结果：<br>f1.call(???)<br>this 是什么？去看 onclick 的源码呀 -&gt; 做不到<br>MDN 的开发者知道 onclick 的源码<br>MDN 的开发者写了文档<br>看文档呀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 例 2</span><br><span class="line">button.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(this) // 该元素的引用 button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2 结果：<br>去看 addEventListener 的源码呀 -&gt; 做不到<br>MDN 的开发者知道 addEventListener 的源码<br>MDN 的开发者写了文档<br>看文档呀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 例 3</span><br><span class="line">$(&apos;ul&apos;).on(&apos;click&apos;, &apos;li&apos; /*selector*/, function()&#123;</span><br><span class="line">    console.log(this) //this 则代表了与 selector 相匹配的元素。</span><br><span class="line">    // li 元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>3 结果：<br>去看 on 的源码呀 -&gt; 做不到<br>jQuery 的开发者知道 onclick 的源码<br>jQuery 的开发者写了文档<br>看文档呀</p>
<p><strong>特例：我可以传一个 this 给它</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick.call(&#123;name: &apos;ada&apos;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>由于 this 是 call 的第一个参数<br>这样子 button.onclick 的 this 就变成了 {name:’ada’}</p>
<p><strong>终极例题</strong><br>理解下面例子，基本上 this 就明白得差不多了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function X()&#123;</span><br><span class="line">    return object = &#123;</span><br><span class="line">        name: &apos;object&apos;,</span><br><span class="line">        options: null,</span><br><span class="line">        f1(x)&#123; </span><br><span class="line">            // 3 下面的 this ？不就是 f1.call()的 this，就是 2 里面的 this：object</span><br><span class="line">            this.options = x // 4 这里 x 是 options</span><br><span class="line">            this.f2() // 5 this.f2.call() 显然这里 this 也是 object</span><br><span class="line">        &#125;,</span><br><span class="line">        f2()&#123;</span><br><span class="line">            this.options.f2.call(this) // 6 这句代码4告诉我们是 options.f2.call(this) 我们把 this：object 传给了 options （特例）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    name: &apos;options&apos;,</span><br><span class="line">    f1()&#123;&#125;,</span><br><span class="line">    f2()&#123;</span><br><span class="line">        console.log(this) // 问 this 是啥 ? // 7  传过来的 object 啊</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = X() // 1 这里的 x 是啥？X() return 的 object</span><br><span class="line">x.f1(options) // 2 x.f1.call(x,options) 显然这里 this 就是 x === object</span><br></pre></td></tr></table></figure></p>
<p>问题：上面代码打印的 this 是什么？<br>正确答案：object ，思路已经在注释里，按数字顺序理解</p>
<hr>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/25991271" target="_blank" rel="noopener">你怎么还没搞懂 this？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhou Yuanda</p>
              <p class="site-description motion-element" itemprop="description">你是哥哥还是 MM</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yuanda</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
