{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/chic/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/font.styl","path":"css/font.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/layout.styl","path":"css/layout.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/media.styl","path":"css/media.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/normalize.styl","path":"css/normalize.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/css/variable.styl","path":"css/variable.styl","modified":1,"renderable":1},{"_id":"themes/chic/source/image/favicon.ico","path":"image/favicon.ico","modified":1,"renderable":1},{"_id":"themes/chic/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/chic/source/image/avatar.jpeg","path":"image/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":1,"renderable":1},{"_id":"themes/chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/chic/LICENSE.md","hash":"632b916dd7e4f5c11790ab808388cda6610210ed","modified":1585413445381},{"_id":"themes/chic/ChangeLogs.md","hash":"fab83fcf3eda5cc5b4a6092554e4c57b3a36630e","modified":1585413445380},{"_id":"themes/chic/README-CN.md","hash":"e0b616b7546d05a50bd7bf046858af8e221fd0fc","modified":1585413445381},{"_id":"themes/chic/_config.yml","hash":"1fc9de97a28f00f85cdaa0d01f28a57138485b4f","modified":1585418836042},{"_id":"themes/chic/README.md","hash":"3cf59b115947ccc2a203189984df66ec55e322f2","modified":1585413445383},{"_id":"themes/chic/package.json","hash":"55d477f0e6c76fa767b782ca0f5e0fede8d2ea28","modified":1585413445402},{"_id":"source/_posts/AJAX-是什么鬼.md","hash":"ed1ef7e3028249c75a5209359e1954e2d9e15888","modified":1585416587216},{"_id":"source/_posts/CSS常用布局-续篇.md","hash":"daa4c8505a1da153d29963daa1fd7363e337b076","modified":1585416623306},{"_id":"source/_posts/7个实用的-JavaScript-小技巧（译文）.md","hash":"2e0899da97202350ff14c2b052908062cf83e7d7","modified":1585417063625},{"_id":"source/_posts/CSS常用布局学习.md","hash":"87fc34ff4d36e910ef813f24cbfe0d89db6c3947","modified":1585416674291},{"_id":"source/_posts/HTML入门笔记.md","hash":"ffa66b1d7d733964c447d960b5b4c4fafb9adaf9","modified":1585416957495},{"_id":"source/_posts/Flutter-踩坑之环境搭建.md","hash":"f2a324250a245f0ef3d926412551d53f3e9fda14","modified":1585417163590},{"_id":"source/_posts/HTML常用的几个标签.md","hash":"91cab33c79799e5ea16dd34e02fd1bdd9707e1bf","modified":1585416941931},{"_id":"source/_posts/HTTP-学习之-Cookie.md","hash":"3e6219990109eb35134b9e9d8192e7ba20737714","modified":1585416964644},{"_id":"source/_posts/JavaScript原型和原型链.md","hash":"18ff6dd95f006dcd6e13768d2d5358a88536964c","modified":1585416971655},{"_id":"source/_posts/LeetCode-算法之旅.md","hash":"1b09a65e7dcafd23c4840862ff3c6dbff9073f5a","modified":1585416980168},{"_id":"source/_posts/OOP-初探（给-MVC-添加类）.md","hash":"de36e2ec8c501ce9c31365e794b13f4bf605e771","modified":1585417011927},{"_id":"source/_posts/MVC-初尝试之-V-和-C.md","hash":"4e26bb8b2455e4bdda380514b3faece8decb7c55","modified":1585417016443},{"_id":"source/_posts/Vue-项目编译时间过长问题.md","hash":"a599ea8d040ccd21a8fe86700f36edf31fcc2944","modified":1585417026868},{"_id":"source/_posts/Vue-全家桶学习总结.md","hash":"cf864f4dcd167a3ad579f4d270e21affe1df52fd","modified":1585417023122},{"_id":"source/_posts/Web-服务器.md","hash":"3388b844ee77df3cab362ab9a70520404e855f56","modified":1585417039490},{"_id":"source/_posts/hash-模式和-history-模式小记.md","hash":"4ac22d75c2f0ac79d54cfa95e6be22588c827beb","modified":1585931687433},{"_id":"source/_posts/git入门——在本地使用git.md","hash":"a02fe7757c420fe28da2fc2ba581c69802ee5f7e","modified":1585417174019},{"_id":"source/_posts/windows-7与-linux-双系统安装（免U盘）.md","hash":"6efd6421a6a02717622d3782207071d78322bc9e","modified":1585417045811},{"_id":"source/_posts/一些命令行入门学习的知识和细节.md","hash":"9637cd48b98d0f7c8252a739fafb92de7ae2833f","modified":1585416544837},{"_id":"source/_posts/windows-7与linux双系统安装（后续）.md","hash":"00264940aa999035f586f104bd888f958895812a","modified":1585417050189},{"_id":"source/_posts/一次性理解立即执行函数和闭包.md","hash":"b6057c356b6716d472fe78310aafac4e4b129d36","modified":1585416531654},{"_id":"source/_posts/从「从输入URL到页面加载」谈及Web性能优化.md","hash":"35226fa2a8cc0cf6102162329ab4393a6088b130","modified":1585417070283},{"_id":"source/_posts/实现一个-jQuery-的-API.md","hash":"15f60b1ea8170417e4e4199298a98994c0045a4b","modified":1585416517768},{"_id":"source/_posts/优先级-和-CSS-预处理.md","hash":"0bf453775bf4890aef1bad613cccec53ae57ab0f","modified":1585416549749},{"_id":"source/_posts/实现一个AJAX.md","hash":"ea68e970cc0f31e53b5ed2f079d3e4169f9262e1","modified":1585417126759},{"_id":"source/_posts/恢复github上不显示的绿块.md","hash":"e0f52133cb5b71a5816b7ea7f8f982914ec24b90","modified":1585417078456},{"_id":"source/_posts/有关-HTTP-协议（IP和端口）.md","hash":"40e1186b514066a7327dedbc46d8883c39cd0c53","modified":1585417141034},{"_id":"source/_posts/搞懂这些-你就理解-this-了.md","hash":"51e66432c723a73556652880873f623597e5d85d","modified":1585416194081},{"_id":"source/_posts/浅谈JS继承.md","hash":"64c4328685290d04a83ab1f1b460fc8c1d771c19","modified":1585417118842},{"_id":"source/_posts/理解HTTP.md","hash":"6937530a473df7eb211f2357c95b74f2600703f1","modified":1585416280859},{"_id":"source/_posts/理解JSONP-上.md","hash":"0696a850ac2f0294fdab597d8d16138b51d7b6c4","modified":1585416494295},{"_id":"source/_posts/正则表达式速记.md","hash":"fcd3f5ca102f32d6ffcf5ec1e1df14de55492f4f","modified":1585416567618},{"_id":"source/about/index.md","hash":"a96496d8bd4025844e71dafb65a8f421502b4383","modified":1585418714609},{"_id":"source/tag/index.md","hash":"18ba1abc4009d7f73887a903e85cb4b4084a4acc","modified":1585417328947},{"_id":"themes/chic/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1585413445336},{"_id":"themes/chic/.git/config","hash":"d165f08c3a662d9730a2b6db814bc0c5051b0046","modified":1585413445345},{"_id":"source/_posts/理解JSONP-下.md","hash":"92973448f612c2b636bc3e497aace4079898c711","modified":1585416500839},{"_id":"themes/chic/.git/index","hash":"69ed9204761a9fac2338bfbf01f28395129fafe8","modified":1585420317434},{"_id":"themes/chic/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1585413203899},{"_id":"source/_posts/理解虚拟-DOM.md","hash":"2ed913d104932a69e3cab3a65365af5c817bab37","modified":1585417097146},{"_id":"themes/chic/.git/packed-refs","hash":"b6485f4f442388c9b633901df5f971528fd1572e","modified":1585413445330},{"_id":"themes/chic/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1585413445384},{"_id":"themes/chic/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1585413445385},{"_id":"themes/chic/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1585413445386},{"_id":"themes/chic/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1585413445387},{"_id":"themes/chic/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1585413445386},{"_id":"themes/chic/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1585413445387},{"_id":"themes/chic/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1585413445388},{"_id":"themes/chic/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1585413445388},{"_id":"themes/chic/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1585413445389},{"_id":"themes/chic/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1585413445389},{"_id":"themes/chic/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1585413445390},{"_id":"themes/chic/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1585413445390},{"_id":"themes/chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1585413445399},{"_id":"themes/chic/layout/layout.ejs","hash":"c2ab5ebca1c0f7ac2fa7e5999f95788861dcefd7","modified":1585413445400},{"_id":"themes/chic/layout/index.ejs","hash":"b44f40dd5b866e1d6a840654aa8323054f061dac","modified":1585413445400},{"_id":"themes/chic/layout/page.ejs","hash":"92c2d419faea7ec7d984a3d960f5668608d36842","modified":1585413445401},{"_id":"themes/chic/layout/category.ejs","hash":"78c93c3a13f9678fa0f27061fa3a91a82edbcc17","modified":1585413445399},{"_id":"themes/chic/layout/post.ejs","hash":"a23f83d6c559ce88588472267468a54488d50e8e","modified":1585413445401},{"_id":"themes/chic/layout/tag.ejs","hash":"f6a48442749c2a743e47fde26bddabaaa2d7d95b","modified":1585413445402},{"_id":"themes/chic/scripts/imageTag.js","hash":"21c67e132584333eaa7b0c015fdd37d2e56ea934","modified":1585413445403},{"_id":"themes/chic/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1585413203909},{"_id":"themes/chic/.git/logs/HEAD","hash":"54718a7ee043627055046b6cba6882411ec35003","modified":1585413445339},{"_id":"themes/chic/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1585413203900},{"_id":"themes/chic/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1585413203902},{"_id":"themes/chic/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1585413203902},{"_id":"themes/chic/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1585413203900},{"_id":"themes/chic/.git/hooks/fsmonitor-watchman.sample","hash":"55a762007dd48d229ef89fe8d0882256dcbee41a","modified":1585413203901},{"_id":"themes/chic/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1585413203904},{"_id":"themes/chic/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1585413203906},{"_id":"themes/chic/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1585413203904},{"_id":"themes/chic/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1585413203903},{"_id":"themes/chic/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1585413203905},{"_id":"themes/chic/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1585413203907},{"_id":"themes/chic/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1585413203907},{"_id":"themes/chic/layout/_page/archive.ejs","hash":"074ef6ede857a3404a454684b2a3bf6121d53bf3","modified":1585413445391},{"_id":"themes/chic/layout/_page/category.ejs","hash":"607bbfd724c47649a5b4c54d0509194ec1f6bbbd","modified":1585413445392},{"_id":"themes/chic/layout/_page/page.ejs","hash":"90559c37712ec3d7cdd58ad15d14d5662816bce1","modified":1585413445392},{"_id":"themes/chic/layout/_page/tag.ejs","hash":"271bbaf9549a62cffbe7b5aab7afdabb4eea5ebc","modified":1585413445394},{"_id":"themes/chic/layout/_partial/footer.ejs","hash":"5ae3880e3badf8f413e503a7a2662c41219b3b82","modified":1585413445395},{"_id":"themes/chic/layout/_page/post.ejs","hash":"354e4a74681c10b3e6481c1a2ced03b606a0dd9f","modified":1585413445393},{"_id":"themes/chic/layout/_page/profile.ejs","hash":"0f8584965cdb9c2fabb4f81dae7973022b9ff422","modified":1585413445394},{"_id":"themes/chic/layout/_partial/paginator.ejs","hash":"8ad8d7752378f71708ce9d25e19f06f316eacce0","modified":1585413445397},{"_id":"themes/chic/layout/_partial/head.ejs","hash":"ff8fd108858018e92e632ec9db43a413079984f6","modified":1585413445396},{"_id":"themes/chic/layout/_partial/header.ejs","hash":"2d4be1a3899d4512892fb951e11c9cd47d38ed56","modified":1585413445397},{"_id":"themes/chic/layout/_partial/toc.ejs","hash":"ced91b79bfa99e4141b3e37e3ac22648729474d2","modified":1585413445398},{"_id":"themes/chic/layout/_plugins/mathjax.ejs","hash":"56722622edf8cb6e7bb138ad1d0329e2125d9c38","modified":1585413445398},{"_id":"themes/chic/source/css/custom.styl","hash":"730200ab0f2a18cb51633c707252d42d03a17fa1","modified":1585413445460},{"_id":"themes/chic/source/css/font.styl","hash":"9df612c7773050b99d2e281f1a6ff21db45d5d25","modified":1585413445460},{"_id":"themes/chic/source/css/layout.styl","hash":"5e43163d7da6e535d211522ed5ac93356d6447ee","modified":1585413445461},{"_id":"themes/chic/source/css/base.styl","hash":"b4fe58e7b149e5ee54bedf234d3c32d037749b65","modified":1585413445459},{"_id":"themes/chic/source/css/media.styl","hash":"512311f047b94f886163f664e1236f58798e5677","modified":1585413445461},{"_id":"themes/chic/source/css/normalize.styl","hash":"df9ca719f651c45a88ab4d6afa6d29edf51aeba9","modified":1585413445462},{"_id":"themes/chic/source/css/style.styl","hash":"f87c15993e8b7c3c0bd885b51a11377fa5d2cfe3","modified":1585413445463},{"_id":"themes/chic/source/css/variable.styl","hash":"4fbb2ffdc00cad2f5cd6ff0dd689836d6f20d227","modified":1585413445464},{"_id":"themes/chic/source/image/favicon.ico","hash":"89e0394c536364ac710d8401f6d97801f55aa0de","modified":1585418816272},{"_id":"themes/chic/source/js/script.js","hash":"b69c0facab01049908ad936d63ea705d33dea731","modified":1585413445577},{"_id":"themes/chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1585413445578},{"_id":"themes/chic/source/js/mathjax2.7.5.js","hash":"fd54df22584629c604511acf67c9e992d362a5e3","modified":1585413445577},{"_id":"themes/chic/.git/objects/pack/pack-e8e3fc46c1dd466a4a903fdbb018ddea9ed0f1d1.idx","hash":"bdf9d8287e060147e7b8b5056d21f529ddaa5209","modified":1585413445256},{"_id":"themes/chic/.git/refs/heads/master","hash":"06e6bc800607681123e2a766c8d8c6332dfad9ee","modified":1585413445339},{"_id":"themes/chic/source/css/_highlight/androidstudio.styl","hash":"4d67bdab6cc9c614486ca42f98199a04d053e7f0","modified":1585413445406},{"_id":"themes/chic/source/css/_highlight/arduino-light.styl","hash":"591962bfc758a521b4cb907750c19a1a2423b4d5","modified":1585413445407},{"_id":"themes/chic/source/css/_highlight/agate.styl","hash":"fc289ba8f47ead6331ec3a51533cfa93251c5634","modified":1585413445405},{"_id":"themes/chic/source/css/_highlight/arta.styl","hash":"262167aaebcf28de7f85af7ac77a76fa1fa284f7","modified":1585413445407},{"_id":"themes/chic/source/css/_highlight/ascetic.styl","hash":"ca087a3c70998c7ac6b0b42d5cf7a653b8707591","modified":1585413445408},{"_id":"themes/chic/source/css/_highlight/atelier-cave-light.styl","hash":"f47de0b9d66617728f68096ed48371dd6bb9e67a","modified":1585413445409},{"_id":"themes/chic/source/css/_highlight/atelier-cave-dark.styl","hash":"7e83c7f2acaaaa98864660afe2794745c36c8e51","modified":1585413445408},{"_id":"themes/chic/source/css/_highlight/atelier-dune-dark.styl","hash":"68584ed0e99c7d0e49ef8a2e67cd4dcdad359de4","modified":1585413445409},{"_id":"themes/chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"1cecd13e0d6b24042ff86372f0596c1441bb834a","modified":1585413445410},{"_id":"themes/chic/source/css/_highlight/atelier-dune-light.styl","hash":"657fe215931fd06e21b56374df699a94890f7ab4","modified":1585413445410},{"_id":"themes/chic/source/css/_highlight/atelier-estuary-light.styl","hash":"2b416a0567a53aa0fa8898b196ddd44315c1a5f3","modified":1585413445411},{"_id":"themes/chic/source/css/_highlight/atelier-forest-dark.styl","hash":"a741eba35cdfe2cfd67dfbf109655f253d6b4795","modified":1585413445412},{"_id":"themes/chic/source/css/_highlight/atelier-forest-light.styl","hash":"8d7c7242974aa2454fa792c5d7a47c5f9632355a","modified":1585413445413},{"_id":"themes/chic/source/css/_highlight/atelier-heath-light.styl","hash":"c1db353e8613607580d40b12ddc162d029560576","modified":1585413445414},{"_id":"themes/chic/source/css/_highlight/atelier-heath-dark.styl","hash":"f186b357dcebded89b7bcc77389b2cff76533d72","modified":1585413445414},{"_id":"themes/chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"802979cea895a0a384645cb30a43de9572cb0e3f","modified":1585413445415},{"_id":"themes/chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"8659eaae6a0c2e00b4b9199803e50adf4ff0128d","modified":1585413445416},{"_id":"themes/chic/source/css/_highlight/atelier-plateau-light.styl","hash":"96181544eeadc5b0749229f11607e7c01f81e078","modified":1585413445417},{"_id":"themes/chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"0d51ddc580ccb0a291271fa9632bc91dab632df6","modified":1585413445416},{"_id":"themes/chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"bbad7a9512b4873294e73ce806e36e43973e6ed8","modified":1585413445417},{"_id":"themes/chic/source/css/_highlight/atelier-savanna-light.styl","hash":"8a5207a0c30262a0bf5e1a41411a306f7a89a7e7","modified":1585413445418},{"_id":"themes/chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2f008271299042f2443bca98c9bcadbc8c45e837","modified":1585413445418},{"_id":"themes/chic/source/css/_highlight/atelier-seaside-light.styl","hash":"08e2df313c272d5c70c93e713639663c168180d0","modified":1585413445419},{"_id":"themes/chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"18dcb00ab9c62eb810d492047214331c51bb654f","modified":1585413445420},{"_id":"themes/chic/source/css/_highlight/brown-paper.styl","hash":"e45a5e2ae53c90334e9bc8be1e45f3c3aa3d785d","modified":1585413445421},{"_id":"themes/chic/source/css/_highlight/codepen-embed.styl","hash":"1de45e603e2c71c7f6b0c1372a3ba00b1bc153a8","modified":1585413445422},{"_id":"themes/chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"add3d88c9d12567dcfae7a8e49984d119fc72227","modified":1585413445420},{"_id":"themes/chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1585413445421},{"_id":"themes/chic/source/css/_highlight/dark.styl","hash":"98d7884806838a0b46132d759d60ac27c0c4bd9c","modified":1585413445423},{"_id":"themes/chic/source/css/_highlight/darkula.styl","hash":"8965ad6920601c275ca97e617beff5536925a266","modified":1585413445424},{"_id":"themes/chic/source/css/_highlight/color-brewer.styl","hash":"9c4905eab730d0b389e6972e907057577f7e25f1","modified":1585413445422},{"_id":"themes/chic/source/css/_highlight/docco.styl","hash":"7bd3389ce16d20488ab336d557056cc703c921c7","modified":1585413445424},{"_id":"themes/chic/source/css/_highlight/github.styl","hash":"a84eb710b302006120c3e7f8ca18f9e6fbc231c3","modified":1585413445426},{"_id":"themes/chic/source/css/_highlight/foundation.styl","hash":"28c59a31467c33bd51cbf3b6085782c2a724ff6c","modified":1585413445425},{"_id":"themes/chic/source/css/_highlight/far.styl","hash":"8da83d66724f2ce508a40f21b4f6dc0d704be562","modified":1585413445425},{"_id":"themes/chic/source/css/_highlight/googlecode.styl","hash":"7f5082ae008925a23eb713f160773fe647eb3ff7","modified":1585413445426},{"_id":"themes/chic/source/css/_highlight/github-gist.styl","hash":"71f4b0fca91a587e6eba15a5306dca963bb8f441","modified":1585413445426},{"_id":"themes/chic/source/css/_highlight/grayscale.styl","hash":"c83804abe39faebd80f8f4ff64fbd7137674cb1c","modified":1585413445427},{"_id":"themes/chic/source/css/_highlight/gruvbox-dark.styl","hash":"f66403ce77dcb16b1f98a5061b72f7581630d69f","modified":1585413445428},{"_id":"themes/chic/source/css/_highlight/highlightjs.styl","hash":"192611c56d6fe4da343718548de21c31a75919db","modified":1585413445429},{"_id":"themes/chic/source/css/_highlight/hopscotch.styl","hash":"dd3c78c42d4a865f11623235e5e5f6829d789706","modified":1585413445430},{"_id":"themes/chic/source/css/_highlight/hybrid.styl","hash":"4906456025787de04b48a87c42bb704c5ff67065","modified":1585413445430},{"_id":"themes/chic/source/css/_highlight/index.styl","hash":"36c44375229613a5bb9ee84a8e90214978070439","modified":1585413445431},{"_id":"themes/chic/source/css/_highlight/idea.styl","hash":"e284c1760e8da0848f56cd5601d867ceeb0192d7","modified":1585413445431},{"_id":"themes/chic/source/css/_highlight/ir-black.styl","hash":"aa31b30069ebee39e2c3ebb75e2c96ba8678eb14","modified":1585413445432},{"_id":"themes/chic/source/css/_highlight/kimbie.dark.styl","hash":"3b998c640eeb2c6192fee24bc78b4137de475dd7","modified":1585413445432},{"_id":"themes/chic/source/css/_highlight/kimbie.light.styl","hash":"e901738455ec9a1bddde7b62bbd8595de6033e1e","modified":1585413445433},{"_id":"themes/chic/source/css/_highlight/kimbie.styl","hash":"13113af220dfed09cb49d85102babb352c3eff97","modified":1585413445434},{"_id":"themes/chic/source/css/_highlight/magula.styl","hash":"ab179306c12a1cf2949482beaca328e379ef034a","modified":1585413445434},{"_id":"themes/chic/source/css/_highlight/mono-blue.styl","hash":"14fb8678739b77f35771b6d63101ddbf1e7a9fbc","modified":1585413445435},{"_id":"themes/chic/source/css/_highlight/monokai-sublime.styl","hash":"84a27bd29d939105d65f4164c219d6cc2e09ae60","modified":1585413445435},{"_id":"themes/chic/source/css/_highlight/monokai.styl","hash":"c3a3bfae1eb864505fbc8748db734600057af1af","modified":1585413445436},{"_id":"themes/chic/source/css/_highlight/obsidian.styl","hash":"efba069860181d2b709e1548dd16cf102ca267fa","modified":1585413445436},{"_id":"themes/chic/source/css/_highlight/paraiso-dark.styl","hash":"50f1cee8a5b3b165b4184ead0a99dc564b62ef4f","modified":1585413445437},{"_id":"themes/chic/source/css/_highlight/paraiso-light.styl","hash":"e428e8202b01e83b0f018a96058d806e7f4c76bf","modified":1585413445437},{"_id":"themes/chic/source/css/_highlight/paraiso.styl","hash":"846a06a57fa0b3db7f83ec7ac2bf34911f32cf66","modified":1585413445438},{"_id":"themes/chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1585413445438},{"_id":"themes/chic/source/css/_highlight/pojoaque.styl","hash":"37436c1018394f799a1f3dfd326309da8df89742","modified":1585413445439},{"_id":"themes/chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1585413445440},{"_id":"themes/chic/source/css/_highlight/railscasts.styl","hash":"5dc9ce33cecee87fe9ca8f2ed9342602194484ec","modified":1585413445439},{"_id":"themes/chic/source/css/_highlight/rainbow.styl","hash":"95246afef181bd96f9adb1a2e84fb3ef302d4598","modified":1585413445440},{"_id":"themes/chic/source/css/_highlight/school-book.styl","hash":"6d685307f4362d3b2b0868f7b0a94b930db66e6a","modified":1585413445441},{"_id":"themes/chic/source/css/_highlight/solarized-dark.styl","hash":"9fc9400d3a8cae97eb5761c284140acb0f847538","modified":1585413445441},{"_id":"themes/chic/source/css/_highlight/solarized-light.styl","hash":"bb04944fc06c12ecd7b56ad933dbedde60c2259a","modified":1585413445442},{"_id":"themes/chic/source/css/_highlight/sunburst.styl","hash":"e6e4c009b10b9805f0c593446bf013edec47d146","modified":1585413445442},{"_id":"themes/chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"92f4423d4964fcfe34ff7ca6cb21012b5738c697","modified":1585413445443},{"_id":"themes/chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"e6b025b247e4027fb3c1b7833588f5a5b04a549c","modified":1585413445443},{"_id":"themes/chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"8b16876cf205111d5d5454100de712bc3ea8f477","modified":1585413445444},{"_id":"themes/chic/source/css/_highlight/tomorrow.styl","hash":"502335f0fac07ed74ca78207bcf3ef8dd2252cf6","modified":1585413445447},{"_id":"themes/chic/source/css/_highlight/tomorrow-night.styl","hash":"eb8441364bb1664ecebde77b965dc36c91133aa0","modified":1585413445446},{"_id":"themes/chic/source/css/_lib/looper.css","hash":"f4ee39f122059c1e7793b8dc1d72fcbc5fa5ea15","modified":1585413445449},{"_id":"themes/chic/source/css/_highlight/vs.styl","hash":"14fbb0c43af440a290280b26968c8a5c0786b27f","modified":1585413445448},{"_id":"themes/chic/source/css/_lib/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1585413445450},{"_id":"themes/chic/source/css/_highlight/xcode.styl","hash":"5fa8999c7f807c1aae29c7a1cdf681678576fb69","modified":1585413445448},{"_id":"themes/chic/source/css/_highlight/zenburn.styl","hash":"f63534764dd6598e81177d64714a184f98153b11","modified":1585413445449},{"_id":"themes/chic/source/css/_page/category.styl","hash":"9b0c89a525b2b4f0163f6ff1bf1d208277c8bb1f","modified":1585413445455},{"_id":"themes/chic/source/css/_page/page.styl","hash":"b2cf99b15965f6851129d52d23f26ed91dc2ede7","modified":1585413445456},{"_id":"themes/chic/source/css/_page/archive.styl","hash":"edc8ee7f34629c59fd4d31f2889d5c069e9d63ac","modified":1585413445455},{"_id":"themes/chic/source/css/_page/tag.styl","hash":"715f3fb46c9ccd7c1b701bcf5aac87051ecb3d17","modified":1585413445457},{"_id":"themes/chic/source/css/_partial/footer.styl","hash":"578a744914f05bab4eae73838076b1cdb8130929","modified":1585413445458},{"_id":"themes/chic/source/css/_page/profile.styl","hash":"da31d90eb4529499f9e43eed612967a81f8244c1","modified":1585413445456},{"_id":"themes/chic/source/css/_partial/header.styl","hash":"9e4d9b67cc2dbbb92b190be3f9ebcd77e093f057","modified":1585413445458},{"_id":"themes/chic/source/css/_partial/paginator.styl","hash":"fbe7e3ce8234e5e1a18764113f997b98d777ee5f","modified":1585413445458},{"_id":"themes/chic/source/fonts/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1585413445467},{"_id":"themes/chic/source/fonts/iconfont/demo_index.html","hash":"55c47c8924542a89da4741fcce7eca7e5f881e77","modified":1585413445468},{"_id":"themes/chic/source/fonts/iconfont/iconfont.css","hash":"496a69ed5e5232feecfd8e1390877b77003e405c","modified":1585413445469},{"_id":"themes/chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1585413445470},{"_id":"themes/chic/source/fonts/iconfont/iconfont.json","hash":"cb99651b9be2f87afcd5989480dd7360b4bf4643","modified":1585413445472},{"_id":"themes/chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1585413445471},{"_id":"themes/chic/source/fonts/iconfont/iconfont.svg","hash":"8f1d735e4fae3757dac1866dc3e30147140811e2","modified":1585413445472},{"_id":"themes/chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1585413445473},{"_id":"themes/chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1585413445474},{"_id":"themes/chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1585413445475},{"_id":"themes/chic/.git/logs/refs/heads/master","hash":"54718a7ee043627055046b6cba6882411ec35003","modified":1585413445340},{"_id":"themes/chic/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1585413445335},{"_id":"themes/chic/source/css/_page/_post/post_copyright.styl","hash":"e1851fabb110414a624a1be634129dc6b0ce8d03","modified":1585413445452},{"_id":"themes/chic/source/css/_page/_post/post_code.styl","hash":"7b57bafe7e8e375372055f4a775bb42a3c190c95","modified":1585413445451},{"_id":"themes/chic/source/css/_page/_post/post_content.styl","hash":"8fa506bf4dd38c7cb6d5f48445ab170de4cd6868","modified":1585413445452},{"_id":"themes/chic/source/css/_page/_post/post_header.styl","hash":"6ea0ede34416dfaddda04a903f658325572f91a4","modified":1585413445453},{"_id":"themes/chic/source/css/_page/_post/post_tags.styl","hash":"bd16f8c0e5ee2e302b61b861470ab993b6af709b","modified":1585413445454},{"_id":"themes/chic/source/css/_page/_post/post_nav.styl","hash":"9c73772ad0d2b1e67007aa2816ee9b97d5152ffa","modified":1585413445453},{"_id":"themes/chic/source/css/_page/_post/post_toc.styl","hash":"6c64f313146416a17b087d0a2fc90362cd977776","modified":1585413445454},{"_id":"themes/chic/source/image/avatar.jpeg","hash":"101f0deb282e6f5905b308c6c8d190776d253460","modified":1585416007730},{"_id":"themes/chic/.git/logs/refs/remotes/origin/HEAD","hash":"54718a7ee043627055046b6cba6882411ec35003","modified":1585413445335},{"_id":"themes/chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1585413445574},{"_id":"themes/chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1585413445568},{"_id":"themes/chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1585413445528},{"_id":"themes/chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1585413445503},{"_id":"themes/chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1585413445562},{"_id":"themes/chic/.git/objects/pack/pack-e8e3fc46c1dd466a4a903fdbb018ddea9ed0f1d1.pack","hash":"a2e197a0ee29e869c9bd209e78e1e349a0a60a54","modified":1585413445254},{"_id":"public/rss2.xml","hash":"453f29c49d5e270e0b38a7573e4e57eeb5e794b1","modified":1585931729218},{"_id":"public/tag/index.html","hash":"03fa37cdd09723061217b383b1964e6cfc2743c6","modified":1585931729232},{"_id":"public/about/index.html","hash":"6275ce2109c73eb8e4f52f39116b07acadf4f359","modified":1585931729232},{"_id":"public/2019/11/14/Vue-项目编译时间过长问题/index.html","hash":"dabb9f8e2cdb5dd170c986677c96370fbcab3376","modified":1585931729232},{"_id":"public/2019/06/12/Flutter-踩坑之环境搭建/index.html","hash":"3069c1c1ed17378b12800846f409f20853b88425","modified":1585931729232},{"_id":"public/2019/03/28/LeetCode-算法之旅/index.html","hash":"df10cff13ff1e6b366f68e5af4f441496197b015","modified":1585931729232},{"_id":"public/2018/12/20/优先级-和-CSS-预处理/index.html","hash":"25e35bf77fae82509e54e6f98797d454bc01bbcf","modified":1585931729232},{"_id":"public/2018/09/16/HTTP-学习之-Cookie/index.html","hash":"19e9f03021ab23df4895132890f2f73f3099ce31","modified":1585931729232},{"_id":"public/2018/09/10/CSS常用布局-续篇/index.html","hash":"9fe824db9eae0f8c282cc2445fcc2f727824255e","modified":1585931729232},{"_id":"public/2018/08/27/搞懂这些-你就理解-this-了/index.html","hash":"0b93025500f8b192b8d5af959e09ae14c66f00b7","modified":1585931729232},{"_id":"public/2018/07/29/实现一个-jQuery-的-API/index.html","hash":"afa748b9fed5a04fc3ff6689bb73623ad4e84b85","modified":1585931729232},{"_id":"public/2018/07/16/恢复github上不显示的绿块/index.html","hash":"19c4a89f86816cf6fb4b5f7225f95bf740af7bc9","modified":1585931729232},{"_id":"public/2018/07/12/JavaScript原型和原型链/index.html","hash":"d4b12e023bb5b1567c83ecaa76258204537b160a","modified":1585931729232},{"_id":"public/2018/06/22/CSS常用布局学习/index.html","hash":"f9afc0bf02da5f8a9b6af418d6c187c2d858b07d","modified":1585931729232},{"_id":"public/2018/06/13/HTML常用的几个标签/index.html","hash":"eada7c35c19e5679030a055e22a61f2ade101db1","modified":1585931729233},{"_id":"public/2018/06/11/HTML入门笔记/index.html","hash":"5741c95b8b31643948f421595c0d022b1f74b706","modified":1585931729233},{"_id":"public/2018/06/08/有关-HTTP-协议（IP和端口）/index.html","hash":"159893859b5bb6f8ad2e8801f213f065346948f7","modified":1585931729233},{"_id":"public/2018/06/05/git入门——在本地使用git/index.html","hash":"55cfed288bfd86a3688cfbe63d371644a5c970bf","modified":1585931729233},{"_id":"public/2018/06/03/windows-7与-linux-双系统安装（免U盘）/index.html","hash":"236e1a407039ed756f2850ad156dd403c5634791","modified":1585931729233},{"_id":"public/2018/06/03/一些命令行入门学习的知识和细节/index.html","hash":"dcb2690c1e9dc621b505df82c8f15b9e19fda556","modified":1585931729233},{"_id":"public/2018/05/27/windows-7与linux双系统安装（后续）/index.html","hash":"451653349ca73860f0cf49504f36179e7e7423bc","modified":1585931729233},{"_id":"public/archives/index.html","hash":"6faf99a27035dd77bcb6af38e79cdea51ee70489","modified":1585931729233},{"_id":"public/archives/page/2/index.html","hash":"44d56314742aea53d6ef61fbf98761414b737944","modified":1585931729233},{"_id":"public/archives/page/3/index.html","hash":"572769e07d4793263dac924d1b238a3b1a611836","modified":1585931729233},{"_id":"public/archives/page/4/index.html","hash":"c59a98436ef28119a69268471dd14d73ed881654","modified":1585931729233},{"_id":"public/archives/2018/index.html","hash":"a9d809c7e65e54d631f1a990f3268b7cf376f466","modified":1585931729233},{"_id":"public/archives/2018/page/2/index.html","hash":"7d40e54d664b8e6714bb545e1d3b759b87a030f3","modified":1585931729233},{"_id":"public/archives/2018/page/3/index.html","hash":"749458c58768886deeba4ff9c75997b07c150ea2","modified":1585931729233},{"_id":"public/archives/2018/05/index.html","hash":"8160ded81e1b7b33bb1db9b6c4360cba44834853","modified":1585931729233},{"_id":"public/archives/2018/06/index.html","hash":"73c4860af475db744d39599efbfb074fc83ec813","modified":1585931729233},{"_id":"public/archives/2018/07/index.html","hash":"2bca729dbfba070f8757a4444306376aa12032aa","modified":1585931729233},{"_id":"public/archives/2018/08/index.html","hash":"78727dc794ddb9e16dd0aea1ca210199e44401b7","modified":1585931729233},{"_id":"public/archives/2018/09/index.html","hash":"1ea97f3040f62a1630550d557ec39130f353c45a","modified":1585931729234},{"_id":"public/archives/2018/10/index.html","hash":"4c075083cc8432432c6ac824d73d6a5ae599d754","modified":1585931729234},{"_id":"public/archives/2018/11/index.html","hash":"88074a4f480f5fddc9a5b7177aac91152de0911e","modified":1585931729234},{"_id":"public/archives/2018/12/index.html","hash":"90d9c93d1e7656a190d5de22fac75663b42cfb31","modified":1585931729234},{"_id":"public/archives/2019/index.html","hash":"a05088a082ce4aea851c22e0f74a3ea36d881e86","modified":1585931729234},{"_id":"public/archives/2019/02/index.html","hash":"6e398b2bea33c71068db9517c0b9141329c5be41","modified":1585931729234},{"_id":"public/archives/2019/03/index.html","hash":"e2ec79f068d8c501a132fa7729ae60b540fbf4ac","modified":1585931729234},{"_id":"public/archives/2019/05/index.html","hash":"e48ef626cdba00bdf40251abf0a3daaa4cde69f4","modified":1585931729234},{"_id":"public/archives/2019/06/index.html","hash":"895c56d69f3f929bda61682c53268589939d9edc","modified":1585931729234},{"_id":"public/archives/2019/11/index.html","hash":"03aadb7b114bc3bd91981d375082362f7b8b17bf","modified":1585931729234},{"_id":"public/tags/HTTP/index.html","hash":"6257d5649c4884743322593a936977a5321f6157","modified":1585931729234},{"_id":"public/tags/CSS/index.html","hash":"07d07c5a5131b94b375a35e39bd38f4e4cdc3221","modified":1585931729234},{"_id":"public/tags/JavaScript/index.html","hash":"433a320ce7706bdbd5dcc4c08a4fa86c1c897572","modified":1585931729234},{"_id":"public/tags/HTML/index.html","hash":"689682d13606a8d5b8542beb29bb1fce4093e13a","modified":1585931729235},{"_id":"public/tags/Flutter/index.html","hash":"2b47af511b4e8b817b274b4ff16d7aa2260f8eaa","modified":1585931729235},{"_id":"public/tags/算法/index.html","hash":"c986e1269a2ff3af89193f3e0739672c90c9ea71","modified":1585931729235},{"_id":"public/tags/设计模式/index.html","hash":"d6e65185ff2a4c7c1f15e1673050c316f4111d32","modified":1585931729235},{"_id":"public/tags/Vue/index.html","hash":"a2fb8a91a5aca15313f7c619eb0bbbed41ce8474","modified":1585931729235},{"_id":"public/tags/Node-js/index.html","hash":"8f1e89e2ccafc620807a05d17813247da66c9855","modified":1585931729235},{"_id":"public/tags/git/index.html","hash":"7654b004ed1e184e5db23f75d0136a70e54b462e","modified":1585931729235},{"_id":"public/tags/linux/index.html","hash":"6b0f05b9f7754ffcf36255606baf60a2d9513576","modified":1585931729235},{"_id":"public/tags/命令行/index.html","hash":"8c9a0067f5d6b067cd1169e6f946c65d5491dd77","modified":1585931729235},{"_id":"public/tags/Web-性能优化/index.html","hash":"04f459b0a84d588351a70664383dc02c2a03e091","modified":1585931729235},{"_id":"public/tags/RegExp/index.html","hash":"637a859859822f31c3734efe0b8b471fcf67c068","modified":1585931729236},{"_id":"public/index.html","hash":"6af12fa268f2465fece76b6b8f65bb040a5b27c1","modified":1585931729236},{"_id":"public/page/2/index.html","hash":"6af12fa268f2465fece76b6b8f65bb040a5b27c1","modified":1585931729236},{"_id":"public/page/3/index.html","hash":"6af12fa268f2465fece76b6b8f65bb040a5b27c1","modified":1585931729236},{"_id":"public/page/4/index.html","hash":"6af12fa268f2465fece76b6b8f65bb040a5b27c1","modified":1585931729236},{"_id":"public/2019/05/06/7个实用的-JavaScript-小技巧（译文）/index.html","hash":"84bd12a6725ed261ef897b8e1cd790bac4c447de","modified":1585931729236},{"_id":"public/2019/02/26/Vue-全家桶学习总结/index.html","hash":"382081005ee5c5f7eadcb7859e4f6625633ed638","modified":1585931729236},{"_id":"public/2018/12/29/从「从输入URL到页面加载」谈及Web性能优化/index.html","hash":"6272d74f5162f98c0b3c5a7e6f9d8d587f187294","modified":1585931729236},{"_id":"public/2018/11/02/浅谈JS继承/index.html","hash":"48a5ff26415d1a0ee3cdd90733c29d76080fcf84","modified":1585931729236},{"_id":"public/2018/10/28/正则表达式速记/index.html","hash":"eebae0be67b79d31c23aa384c587337526454447","modified":1585931729236},{"_id":"public/2018/09/27/理解虚拟-DOM/index.html","hash":"1b527483e0cd89afc7dc7607bff293174034f34e","modified":1585931729236},{"_id":"public/2018/09/04/AJAX-是什么鬼/index.html","hash":"b303545addafe119d670a9c60a154b08b826f99b","modified":1585931729236},{"_id":"public/2018/09/02/OOP-初探（给-MVC-添加类）/index.html","hash":"54b49e16975383ed2472859b3a7966d5177d9602","modified":1585931729236},{"_id":"public/2018/08/20/一次性理解立即执行函数和闭包/index.html","hash":"023236ea6dd3f9f58e20c1e4fff9d7a7b3ab64a3","modified":1585931729236},{"_id":"public/2018/08/18/MVC-初尝试之-V-和-C/index.html","hash":"90f4eed16898afa6274eba22a919ed8d01430688","modified":1585931729236},{"_id":"public/2018/08/12/实现一个AJAX/index.html","hash":"6411e4d5f2200d1dca9c58a9f52a3b2613833160","modified":1585931729236},{"_id":"public/2018/08/12/理解JSONP-下/index.html","hash":"3831d6abfe02122d2d57b3b4ef8064ca88ccf764","modified":1585931729236},{"_id":"public/2018/08/11/Web-服务器/index.html","hash":"8efbc162bd0b42a0365544fca12990f983a05a78","modified":1585931729236},{"_id":"public/2018/08/11/理解JSONP-上/index.html","hash":"a6e0d480fbbb7ee2553ddf427322d39ec7db2600","modified":1585931729237},{"_id":"public/2018/06/07/理解HTTP/index.html","hash":"f428a6beab729394c7cd82a35ab0117b7a050487","modified":1585931729237},{"_id":"public/2019/11/28/hash-模式和-history-模式小记/index.html","hash":"f52454b202e5a144bb7b7bab49ca38153bfd7875","modified":1585931729249},{"_id":"public/image/favicon.ico","hash":"89e0394c536364ac710d8401f6d97801f55aa0de","modified":1585931729253},{"_id":"public/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1585931729253},{"_id":"public/fonts/iconfont/iconfont.svg","hash":"8f1d735e4fae3757dac1866dc3e30147140811e2","modified":1585931729253},{"_id":"public/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1585931729254},{"_id":"public/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1585931729254},{"_id":"public/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1585931729254},{"_id":"public/css/font.css","hash":"87059edd1f2bfc4296f5599e73208893f2b06458","modified":1585931729700},{"_id":"public/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1585931729701},{"_id":"public/css/layout.css","hash":"c81e2e01ff5e95a3e613064b8490045ff936c305","modified":1585931729701},{"_id":"public/css/base.css","hash":"ea2d491ce6242c6b7087a2652a1135694c292137","modified":1585931729701},{"_id":"public/css/media.css","hash":"5023ee404900a47d61ca0591b2d4e9eace0fe88e","modified":1585931729701},{"_id":"public/css/normalize.css","hash":"2d4b663b6a4c68295b6ba240fa2dd9fb3863093c","modified":1585931729701},{"_id":"public/js/script.js","hash":"93694e4e16893f83611daa5ba3723b14ecc80abb","modified":1585931729701},{"_id":"public/css/variable.css","hash":"cb4180b3bbad471e30cf52ebb40e998d58a30d7d","modified":1585931729701},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1585931729701},{"_id":"public/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1585931729701},{"_id":"public/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1585931729701},{"_id":"public/fonts/iconfont/iconfont.json","hash":"3123aa840109e385d58a75d34e88a2d621e1ada8","modified":1585931729701},{"_id":"public/css/style.css","hash":"534ca54902458408412998bd6254ecfb3c50ad35","modified":1585931729701},{"_id":"public/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1585931729702},{"_id":"public/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1585931729702},{"_id":"public/fonts/iconfont/demo_index.html","hash":"923ca70033f2c848c317e08f387ceb5c6ce9de44","modified":1585931729702},{"_id":"public/image/avatar.jpeg","hash":"101f0deb282e6f5905b308c6c8d190776d253460","modified":1585931729718},{"_id":"public/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1585931729803},{"_id":"public/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1585931729813},{"_id":"public/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1585931729835},{"_id":"public/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1585931729838},{"_id":"public/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1585931729859}],"Category":[],"Data":[],"Page":[{"title":"tag","date":"2020-03-28T17:41:29.000Z","layout":"tag","_content":"","source":"tag/index.md","raw":"---\ntitle: tag\ndate: 2020-03-29 01:41:29\nlayout: tag\n---\n","updated":"2020-03-28T17:42:08.947Z","path":"tag/index.html","comments":1,"_id":"ck8keswy90000ws99ftafpnom","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2020-03-28T18:04:50.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-03-29 02:04:50\nlayout: about\n---\n","updated":"2020-03-28T18:05:14.609Z","path":"about/index.html","comments":1,"_id":"ck8keswyg0002ws99ux8aw55e","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AJAX 是什么鬼","date":"2018-09-04T12:57:25.000Z","_content":"\n之前写了一篇博客[理解 JSONP 上](https://www.jianshu.com/p/2a2fe02917e7)关于 AJAX 出现之前如何发请求\n简单回顾一下：\n\n#### 1.用 form 可以发请求，缺点是会刷新页面或新开页面\n\nform 发送 get 请求：![](https://upload-images.jianshu.io/upload_images/7094266-8a9a80cde134701d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n输入密码后，点击提交，打开开发者工具可以看到一个 get 请求，点开找到 Request Headers 点击**view source** ![](https://upload-images.jianshu.io/upload_images/7094266-2f497d2ed697fabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n同样可以用 form 发送 post 请求，与 get 请求区别是 post 请求没有查询参数![](https://upload-images.jianshu.io/upload_images/7094266-2a9955c21d5904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\npost 请求的第四部分 password 在下面的 Form Data 的**view source** 里![](https://upload-images.jianshu.io/upload_images/7094266-c10130216b9836f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 2.用 a 可以发 get 请求，但是也会刷新页面或新开页面\n\n点击 click 就发送请求![](https://upload-images.jianshu.io/upload_images/7094266-e8ecdf0d63d5c019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n<a id=\"ada\" href=\"/ada\">click</a>\n//运行一个脚本，让网页自己点击（但是依然会刷新页面）\n<script>\n  ada.click()\n</script>\n```\n\n#### 3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示\n\n```\n<script>\n  var image = document.createElement('img')\n  image.src = '/ada'\n  image.onload = function(){\n    console.log('succsee')\n  }\n  image.onerror = function(){\n    console.log('fail')\n  }\n</script>\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-9b2b91b49a0575b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示\n\n```\n<script>\n  var link = document.createElement('link')\n  link.rel = 'stylesheet'\n  link.href = '/ada'\n  //需要将link放到页面中才能发送请求\n  document.head.appendChild(link)\n</script>\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ff9dc05b89603af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 5.用 script 可以发 get 请求，但是只能以脚本的形式运行\n\n```\n<script>\n  var script = document.createElement('script')\n  script.src = \"/ada\"\n  //需要将script放到页面中才能发送请求\n  document.head.appendChild(script)\n</script>\n```\n\n当然还有其他方法\n\n---\n\n有关 AJAX 的学习推荐[阮一峰博客](http://javascript.ruanyifeng.com/bom/ajax.html#toc0)\n**微软的突破**\nIE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。\n随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范\n**AJAX**\nJesse James Garrett 将如下技术取名叫做 AJAX（Asynchronous JavaScript and XML）：异步的 JavaScript 和 XML\n**_1.使用 XMLHttpRequest 发请求 2.服务器返回 XML 格式的字符串\n3.JS 解析 XML，并更新局部页面_**\n\n#### 同样我们用 node 服务器来尝试一下这三个条件(AJAX)\n\n新建 html\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    hi\n</body>\n</html>\n```\n\nNode 代码\n\n```\nconsole.log('含查询字符串的路径\\n' + pathWithQuery)\n  if (path === '/') {\n    var string = fs.readFileSync('./index.html', 'utf8')\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write(string)\n    response.end()\n  } else{\n    response.statusCode = 404\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write('找不到服务器')\n    response.end()\n  }\n```\n\n对于 HTTP 来说，响应的第四部分始终是 string![](https://upload-images.jianshu.io/upload_images/7094266-01746a588b0abc36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在 html 里创建一个 button，引入当前目录下的 js 文件\n\n```\n<body>\n    <button id=\"myButton\">点我</button>\n    <script src=\"./main.js\"></script>\n</body>\n```\n\nNode 代码//在原 Node 代码中插入，下同\n\n```\n//注意这里是 /main.js 而不是 ./main.js，因为HTTP请求永远是绝对路径\nelse if (path === '/main.js') {\n//这里当然是./main.js\n    var string = fs.readFileSync('./main.js', 'utf8')\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/javascript; charset=utf-8')\n    response.write(string)\n    response.end()\n}\n```\n\n**首先满足 1.使用 XMLHttpRequest 发请求**\n\n```\nmyButton.addEventListener('click', (e) => {\n    let request = new XMLHttpRequest()\n    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)\n    request.open('GET', '/ada')\n    request.send()\n})\n```\n\n**2.服务器返回 XML 格式的字符串**\nXML 已经不流行了，但是我们依然可以尝试一下\n找一个一个 XML example\n\n```\nelse if (path === '/ada') {\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/xml; charset=utf-8')\n    response.write(`\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <note>\n    <to>Tove</to>\n    <from>Jani</from>\n    <heading>Reminder</heading>\n    <body>Don't forget me this weekend!</body>\n</note>`)\n    response.end()\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d5529f18c6d6d036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**3.JS 解析 XML，并更新局部页面**\n浏览器是分步下载响应的，一般只要记住 **readyState === 4** 表示请求完成![](https://upload-images.jianshu.io/upload_images/7094266-a27d3791360b1d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以用 **onreadystatechange** 监听 readyState\n\n```\nmyButton.addEventListener('click', (e) => {\n    let request = new XMLHttpRequest()\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            console.log('请求响应都完成了')\n\n            if (request.status >= 200 && request.status < 300) {\n                console.log('success')\n                //响应值在300-400之间浏览器会重新发送请求\n            } else if (request.status >= 400) {\n                console.log('fail')\n            }\n\n        }\n    }\n    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)\n    request.open('GET', '/ada')\n    request.send()\n})\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-6159a07fdb534df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果把(path === '/ada'){}里改成 400 //注意不要改错地方\n\n```\nresponse.statusCode = 400\n```\n\n当然会返回 fail，可以看到 readyState 是不受状态码影响的![](https://upload-images.jianshu.io/upload_images/7094266-dc4181f8240aa1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nJS 是可以解析 XML 的，但是现在 XML 已经被 JSON 取代了，我们可以简单打印出来\n\n```\nconsole.log(request.responseText)\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-beb53639db92273c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n[JSON](https://www.json.org/)\nJSON 是道格拉斯基于 JavaScript 发明的数据交换语言\n\n- 特点：\n  -\n  - 只有 object、array、string、number、true、false、null 这几种类型\n  - 字符串首尾必须为双引号\n\n```\nJS         VS         JSON\nundefined/symbel      无\nnull                  null\n['a','b']             [\"a\",\"b\"]\nfunction f(){}        无\n{a:b}                 {\"a\",\"b\"}\n'hello world'         \"hello world\"\nvar a = {}\na.self = a            无法做到{无变量等形式}\n{__proto__}           没有原型链\n```\n\n**用 JSON 替换 XML**\nNode 代码：\n\n```\nelse if (path === '/ada') {\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/xml; charset=utf-8')\n//变XML为JSON，key和value都可以替换成自己喜欢的\n    response.write(`\n    {\n        \"note\":{\n        \"to\": \"reader\",\n        \"from\": \"Ada\",\n        \"heading\": \"greet\",\n        \"content\": \"hello word!\"\n    }`)\n    response.end()\n```\n\njs 完整代码\n\n```\nmyButton.addEventListener('click', (e) => {\n    let request = new XMLHttpRequest()\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            console.log('请求响应都完成了')\n\n            if (request.status >= 200 && request.status < 300) {\n                console.log('success')\n                console.log(typeof request.responseText)\n                console.log(request.responseText)\n                let string = request.responseText\n                // 把符合 JSON 语法的字符串转换成 JS 对应的值\n                let object = window.JSON.parse(string)\n                // JSON.parse 是浏览器提供的\n                //响应值在300-400之间浏览器会重新发送请求\n            } else if (request.status >= 400) {\n                console.log('fail')\n            }\n\n        }\n    }\n    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)\n    request.open('GET', '/ada')\n    request.send()\n})\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4f376b146466e10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 同源政策\n\n同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。\n同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。\n文章开头提到的 form 和 a 等发送请求是没有同源政策的，而 AJAX 是可以读取响应内容的。\n**因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求**\n\n---\n\n## 如何规避同源政策？跨域\n\n有关 JSONP 跨域在文章开头提供我的博客举过例子\n这次我们用 **CORS 跨域**\n什么是 CORS:**Cross-Origin Resource Sharing(跨域资源共享)**\n\n---\n\n同样用[理解 JSONP 下](https://www.jianshu.com/p/38a72bd0e37d)博客中创建过的网站来举例子\n首先打开服务器端口![](https://upload-images.jianshu.io/upload_images/7094266-49fcd7432b2c7d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n把请求路径改为\n\n```\nrequest.open('GET', 'http://jack.com:8002/ada')\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-706af4f9ecdace99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n点击点我![](https://upload-images.jianshu.io/upload_images/7094266-7a4b7e5d44756b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)报错了，因为不是同源，响应完成却得不到任何内容\n\n**解决方法，在 Node 代码中加入一句**\n\n```\n//允许 http://ada.com:8001 访问我\nresponse.setHeader('Access-Control-Allow-Origin','http://ada.com:8001')\n```\n\n点击点我，即可向 ada.com:8001 发送请求并返回 jack.com:8002/ada 的响应内容![](https://upload-images.jianshu.io/upload_images/7094266-1797c104e4b05d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这就是用 CORS 实现 AJAX 跨域的过程\n\n完整代码详见 [github](https://github.com/Adashuai5/node-demo/tree/master/AJAX-demo)\n\n---\n\n本文仅供个人学习使用\n","source":"_posts/AJAX-是什么鬼.md","raw":"---\ntitle: AJAX 是什么鬼\ndate: 2018-09-04 20:57:25\ntags: HTTP\n---\n\n之前写了一篇博客[理解 JSONP 上](https://www.jianshu.com/p/2a2fe02917e7)关于 AJAX 出现之前如何发请求\n简单回顾一下：\n\n#### 1.用 form 可以发请求，缺点是会刷新页面或新开页面\n\nform 发送 get 请求：![](https://upload-images.jianshu.io/upload_images/7094266-8a9a80cde134701d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n输入密码后，点击提交，打开开发者工具可以看到一个 get 请求，点开找到 Request Headers 点击**view source** ![](https://upload-images.jianshu.io/upload_images/7094266-2f497d2ed697fabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n同样可以用 form 发送 post 请求，与 get 请求区别是 post 请求没有查询参数![](https://upload-images.jianshu.io/upload_images/7094266-2a9955c21d5904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\npost 请求的第四部分 password 在下面的 Form Data 的**view source** 里![](https://upload-images.jianshu.io/upload_images/7094266-c10130216b9836f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 2.用 a 可以发 get 请求，但是也会刷新页面或新开页面\n\n点击 click 就发送请求![](https://upload-images.jianshu.io/upload_images/7094266-e8ecdf0d63d5c019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n<a id=\"ada\" href=\"/ada\">click</a>\n//运行一个脚本，让网页自己点击（但是依然会刷新页面）\n<script>\n  ada.click()\n</script>\n```\n\n#### 3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示\n\n```\n<script>\n  var image = document.createElement('img')\n  image.src = '/ada'\n  image.onload = function(){\n    console.log('succsee')\n  }\n  image.onerror = function(){\n    console.log('fail')\n  }\n</script>\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-9b2b91b49a0575b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示\n\n```\n<script>\n  var link = document.createElement('link')\n  link.rel = 'stylesheet'\n  link.href = '/ada'\n  //需要将link放到页面中才能发送请求\n  document.head.appendChild(link)\n</script>\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ff9dc05b89603af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 5.用 script 可以发 get 请求，但是只能以脚本的形式运行\n\n```\n<script>\n  var script = document.createElement('script')\n  script.src = \"/ada\"\n  //需要将script放到页面中才能发送请求\n  document.head.appendChild(script)\n</script>\n```\n\n当然还有其他方法\n\n---\n\n有关 AJAX 的学习推荐[阮一峰博客](http://javascript.ruanyifeng.com/bom/ajax.html#toc0)\n**微软的突破**\nIE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。\n随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范\n**AJAX**\nJesse James Garrett 将如下技术取名叫做 AJAX（Asynchronous JavaScript and XML）：异步的 JavaScript 和 XML\n**_1.使用 XMLHttpRequest 发请求 2.服务器返回 XML 格式的字符串\n3.JS 解析 XML，并更新局部页面_**\n\n#### 同样我们用 node 服务器来尝试一下这三个条件(AJAX)\n\n新建 html\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    hi\n</body>\n</html>\n```\n\nNode 代码\n\n```\nconsole.log('含查询字符串的路径\\n' + pathWithQuery)\n  if (path === '/') {\n    var string = fs.readFileSync('./index.html', 'utf8')\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write(string)\n    response.end()\n  } else{\n    response.statusCode = 404\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write('找不到服务器')\n    response.end()\n  }\n```\n\n对于 HTTP 来说，响应的第四部分始终是 string![](https://upload-images.jianshu.io/upload_images/7094266-01746a588b0abc36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在 html 里创建一个 button，引入当前目录下的 js 文件\n\n```\n<body>\n    <button id=\"myButton\">点我</button>\n    <script src=\"./main.js\"></script>\n</body>\n```\n\nNode 代码//在原 Node 代码中插入，下同\n\n```\n//注意这里是 /main.js 而不是 ./main.js，因为HTTP请求永远是绝对路径\nelse if (path === '/main.js') {\n//这里当然是./main.js\n    var string = fs.readFileSync('./main.js', 'utf8')\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/javascript; charset=utf-8')\n    response.write(string)\n    response.end()\n}\n```\n\n**首先满足 1.使用 XMLHttpRequest 发请求**\n\n```\nmyButton.addEventListener('click', (e) => {\n    let request = new XMLHttpRequest()\n    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)\n    request.open('GET', '/ada')\n    request.send()\n})\n```\n\n**2.服务器返回 XML 格式的字符串**\nXML 已经不流行了，但是我们依然可以尝试一下\n找一个一个 XML example\n\n```\nelse if (path === '/ada') {\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/xml; charset=utf-8')\n    response.write(`\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <note>\n    <to>Tove</to>\n    <from>Jani</from>\n    <heading>Reminder</heading>\n    <body>Don't forget me this weekend!</body>\n</note>`)\n    response.end()\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d5529f18c6d6d036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**3.JS 解析 XML，并更新局部页面**\n浏览器是分步下载响应的，一般只要记住 **readyState === 4** 表示请求完成![](https://upload-images.jianshu.io/upload_images/7094266-a27d3791360b1d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以用 **onreadystatechange** 监听 readyState\n\n```\nmyButton.addEventListener('click', (e) => {\n    let request = new XMLHttpRequest()\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            console.log('请求响应都完成了')\n\n            if (request.status >= 200 && request.status < 300) {\n                console.log('success')\n                //响应值在300-400之间浏览器会重新发送请求\n            } else if (request.status >= 400) {\n                console.log('fail')\n            }\n\n        }\n    }\n    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)\n    request.open('GET', '/ada')\n    request.send()\n})\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-6159a07fdb534df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果把(path === '/ada'){}里改成 400 //注意不要改错地方\n\n```\nresponse.statusCode = 400\n```\n\n当然会返回 fail，可以看到 readyState 是不受状态码影响的![](https://upload-images.jianshu.io/upload_images/7094266-dc4181f8240aa1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nJS 是可以解析 XML 的，但是现在 XML 已经被 JSON 取代了，我们可以简单打印出来\n\n```\nconsole.log(request.responseText)\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-beb53639db92273c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n[JSON](https://www.json.org/)\nJSON 是道格拉斯基于 JavaScript 发明的数据交换语言\n\n- 特点：\n  -\n  - 只有 object、array、string、number、true、false、null 这几种类型\n  - 字符串首尾必须为双引号\n\n```\nJS         VS         JSON\nundefined/symbel      无\nnull                  null\n['a','b']             [\"a\",\"b\"]\nfunction f(){}        无\n{a:b}                 {\"a\",\"b\"}\n'hello world'         \"hello world\"\nvar a = {}\na.self = a            无法做到{无变量等形式}\n{__proto__}           没有原型链\n```\n\n**用 JSON 替换 XML**\nNode 代码：\n\n```\nelse if (path === '/ada') {\n    response.statusCode = 200\n    response.setHeader('Content-Type', 'text/xml; charset=utf-8')\n//变XML为JSON，key和value都可以替换成自己喜欢的\n    response.write(`\n    {\n        \"note\":{\n        \"to\": \"reader\",\n        \"from\": \"Ada\",\n        \"heading\": \"greet\",\n        \"content\": \"hello word!\"\n    }`)\n    response.end()\n```\n\njs 完整代码\n\n```\nmyButton.addEventListener('click', (e) => {\n    let request = new XMLHttpRequest()\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            console.log('请求响应都完成了')\n\n            if (request.status >= 200 && request.status < 300) {\n                console.log('success')\n                console.log(typeof request.responseText)\n                console.log(request.responseText)\n                let string = request.responseText\n                // 把符合 JSON 语法的字符串转换成 JS 对应的值\n                let object = window.JSON.parse(string)\n                // JSON.parse 是浏览器提供的\n                //响应值在300-400之间浏览器会重新发送请求\n            } else if (request.status >= 400) {\n                console.log('fail')\n            }\n\n        }\n    }\n    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)\n    request.open('GET', '/ada')\n    request.send()\n})\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4f376b146466e10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 同源政策\n\n同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。\n同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。\n文章开头提到的 form 和 a 等发送请求是没有同源政策的，而 AJAX 是可以读取响应内容的。\n**因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求**\n\n---\n\n## 如何规避同源政策？跨域\n\n有关 JSONP 跨域在文章开头提供我的博客举过例子\n这次我们用 **CORS 跨域**\n什么是 CORS:**Cross-Origin Resource Sharing(跨域资源共享)**\n\n---\n\n同样用[理解 JSONP 下](https://www.jianshu.com/p/38a72bd0e37d)博客中创建过的网站来举例子\n首先打开服务器端口![](https://upload-images.jianshu.io/upload_images/7094266-49fcd7432b2c7d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n把请求路径改为\n\n```\nrequest.open('GET', 'http://jack.com:8002/ada')\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-706af4f9ecdace99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n点击点我![](https://upload-images.jianshu.io/upload_images/7094266-7a4b7e5d44756b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)报错了，因为不是同源，响应完成却得不到任何内容\n\n**解决方法，在 Node 代码中加入一句**\n\n```\n//允许 http://ada.com:8001 访问我\nresponse.setHeader('Access-Control-Allow-Origin','http://ada.com:8001')\n```\n\n点击点我，即可向 ada.com:8001 发送请求并返回 jack.com:8002/ada 的响应内容![](https://upload-images.jianshu.io/upload_images/7094266-1797c104e4b05d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这就是用 CORS 实现 AJAX 跨域的过程\n\n完整代码详见 [github](https://github.com/Adashuai5/node-demo/tree/master/AJAX-demo)\n\n---\n\n本文仅供个人学习使用\n","slug":"AJAX-是什么鬼","published":1,"updated":"2020-03-28T17:29:47.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyc0001ws99isv7oria","content":"<p>之前写了一篇博客<a href=\"https://www.jianshu.com/p/2a2fe02917e7\" target=\"_blank\" rel=\"noopener\">理解 JSONP 上</a>关于 AJAX 出现之前如何发请求<br>简单回顾一下：</p>\n<h4 id=\"1-用-form-可以发请求，缺点是会刷新页面或新开页面\"><a href=\"#1-用-form-可以发请求，缺点是会刷新页面或新开页面\" class=\"headerlink\" title=\"1.用 form 可以发请求，缺点是会刷新页面或新开页面\"></a>1.用 form 可以发请求，缺点是会刷新页面或新开页面</h4><p>form 发送 get 请求：<img src=\"https://upload-images.jianshu.io/upload_images/7094266-8a9a80cde134701d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>输入密码后，点击提交，打开开发者工具可以看到一个 get 请求，点开找到 Request Headers 点击<strong>view source</strong> <img src=\"https://upload-images.jianshu.io/upload_images/7094266-2f497d2ed697fabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>同样可以用 form 发送 post 请求，与 get 请求区别是 post 请求没有查询参数<img src=\"https://upload-images.jianshu.io/upload_images/7094266-2a9955c21d5904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>post 请求的第四部分 password 在下面的 Form Data 的<strong>view source</strong> 里<img src=\"https://upload-images.jianshu.io/upload_images/7094266-c10130216b9836f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"2-用-a-可以发-get-请求，但是也会刷新页面或新开页面\"><a href=\"#2-用-a-可以发-get-请求，但是也会刷新页面或新开页面\" class=\"headerlink\" title=\"2.用 a 可以发 get 请求，但是也会刷新页面或新开页面\"></a>2.用 a 可以发 get 请求，但是也会刷新页面或新开页面</h4><p>点击 click 就发送请求<img src=\"https://upload-images.jianshu.io/upload_images/7094266-e8ecdf0d63d5c019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a id=&quot;ada&quot; href=&quot;/ada&quot;&gt;click&lt;/a&gt;</span><br><span class=\"line\">//运行一个脚本，让网页自己点击（但是依然会刷新页面）</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  ada.click()</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示\"><a href=\"#3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示\" class=\"headerlink\" title=\"3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示\"></a>3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var image = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">  image.src = &apos;/ada&apos;</span><br><span class=\"line\">  image.onload = function()&#123;</span><br><span class=\"line\">    console.log(&apos;succsee&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  image.onerror = function()&#123;</span><br><span class=\"line\">    console.log(&apos;fail&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-9b2b91b49a0575b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示\"><a href=\"#4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示\" class=\"headerlink\" title=\"4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示\"></a>4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var link = document.createElement(&apos;link&apos;)</span><br><span class=\"line\">  link.rel = &apos;stylesheet&apos;</span><br><span class=\"line\">  link.href = &apos;/ada&apos;</span><br><span class=\"line\">  //需要将link放到页面中才能发送请求</span><br><span class=\"line\">  document.head.appendChild(link)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ff9dc05b89603af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"5-用-script-可以发-get-请求，但是只能以脚本的形式运行\"><a href=\"#5-用-script-可以发-get-请求，但是只能以脚本的形式运行\" class=\"headerlink\" title=\"5.用 script 可以发 get 请求，但是只能以脚本的形式运行\"></a>5.用 script 可以发 get 请求，但是只能以脚本的形式运行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var script = document.createElement(&apos;script&apos;)</span><br><span class=\"line\">  script.src = &quot;/ada&quot;</span><br><span class=\"line\">  //需要将script放到页面中才能发送请求</span><br><span class=\"line\">  document.head.appendChild(script)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当然还有其他方法</p>\n<hr>\n<p>有关 AJAX 的学习推荐<a href=\"http://javascript.ruanyifeng.com/bom/ajax.html#toc0\" target=\"_blank\" rel=\"noopener\">阮一峰博客</a><br><strong>微软的突破</strong><br>IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。<br>随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范<br><strong>AJAX</strong><br>Jesse James Garrett 将如下技术取名叫做 AJAX（Asynchronous JavaScript and XML）：异步的 JavaScript 和 XML<br><strong><em>1.使用 XMLHttpRequest 发请求 2.服务器返回 XML 格式的字符串<br>3.JS 解析 XML，并更新局部页面</em></strong></p>\n<h4 id=\"同样我们用-node-服务器来尝试一下这三个条件-AJAX\"><a href=\"#同样我们用-node-服务器来尝试一下这三个条件-AJAX\" class=\"headerlink\" title=\"同样我们用 node 服务器来尝试一下这三个条件(AJAX)\"></a>同样我们用 node 服务器来尝试一下这三个条件(AJAX)</h4><p>新建 html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    hi</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;含查询字符串的路径\\n&apos; + pathWithQuery)</span><br><span class=\"line\">  if (path === &apos;/&apos;) &#123;</span><br><span class=\"line\">    var string = fs.readFileSync(&apos;./index.html&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125; else&#123;</span><br><span class=\"line\">    response.statusCode = 404</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(&apos;找不到服务器&apos;)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>对于 HTTP 来说，响应的第四部分始终是 string<img src=\"https://upload-images.jianshu.io/upload_images/7094266-01746a588b0abc36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>在 html 里创建一个 button，引入当前目录下的 js 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码//在原 Node 代码中插入，下同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意这里是 /main.js 而不是 ./main.js，因为HTTP请求永远是绝对路径</span><br><span class=\"line\">else if (path === &apos;/main.js&apos;) &#123;</span><br><span class=\"line\">//这里当然是./main.js</span><br><span class=\"line\">    var string = fs.readFileSync(&apos;./main.js&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>首先满足 1.使用 XMLHttpRequest 发请求</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class=\"line\">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class=\"line\">    request.send()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>2.服务器返回 XML 格式的字符串</strong><br>XML 已经不流行了，但是我们依然可以尝试一下<br>找一个一个 XML example</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if (path === &apos;/ada&apos;) &#123;</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(`</span><br><span class=\"line\">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">    &lt;note&gt;</span><br><span class=\"line\">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class=\"line\">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class=\"line\">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;`)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d5529f18c6d6d036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>3.JS 解析 XML，并更新局部页面</strong><br>浏览器是分步下载响应的，一般只要记住 <strong>readyState === 4</strong> 表示请求完成<img src=\"https://upload-images.jianshu.io/upload_images/7094266-a27d3791360b1d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以用 <strong>onreadystatechange</strong> 监听 readyState</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                console.log(&apos;success&apos;)</span><br><span class=\"line\">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                console.log(&apos;fail&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class=\"line\">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class=\"line\">    request.send()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-6159a07fdb534df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>如果把(path === ‘/ada’){}里改成 400 //注意不要改错地方</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.statusCode = 400</span><br></pre></td></tr></table></figure>\n<p>当然会返回 fail，可以看到 readyState 是不受状态码影响的<img src=\"https://upload-images.jianshu.io/upload_images/7094266-dc4181f8240aa1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>JS 是可以解析 XML 的，但是现在 XML 已经被 JSON 取代了，我们可以简单打印出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(request.responseText)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-beb53639db92273c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p><a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener\">JSON</a><br>JSON 是道格拉斯基于 JavaScript 发明的数据交换语言</p>\n<ul>\n<li>特点：<br>-<ul>\n<li>只有 object、array、string、number、true、false、null 这几种类型</li>\n<li>字符串首尾必须为双引号</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS         VS         JSON</span><br><span class=\"line\">undefined/symbel      无</span><br><span class=\"line\">null                  null</span><br><span class=\"line\">[&apos;a&apos;,&apos;b&apos;]             [&quot;a&quot;,&quot;b&quot;]</span><br><span class=\"line\">function f()&#123;&#125;        无</span><br><span class=\"line\">&#123;a:b&#125;                 &#123;&quot;a&quot;,&quot;b&quot;&#125;</span><br><span class=\"line\">&apos;hello world&apos;         &quot;hello world&quot;</span><br><span class=\"line\">var a = &#123;&#125;</span><br><span class=\"line\">a.self = a            无法做到&#123;无变量等形式&#125;</span><br><span class=\"line\">&#123;__proto__&#125;           没有原型链</span><br></pre></td></tr></table></figure>\n<p><strong>用 JSON 替换 XML</strong><br>Node 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if (path === &apos;/ada&apos;) &#123;</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class=\"line\">//变XML为JSON，key和value都可以替换成自己喜欢的</span><br><span class=\"line\">    response.write(`</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;note&quot;:&#123;</span><br><span class=\"line\">        &quot;to&quot;: &quot;reader&quot;,</span><br><span class=\"line\">        &quot;from&quot;: &quot;Ada&quot;,</span><br><span class=\"line\">        &quot;heading&quot;: &quot;greet&quot;,</span><br><span class=\"line\">        &quot;content&quot;: &quot;hello word!&quot;</span><br><span class=\"line\">    &#125;`)</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>js 完整代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                console.log(&apos;success&apos;)</span><br><span class=\"line\">                console.log(typeof request.responseText)</span><br><span class=\"line\">                console.log(request.responseText)</span><br><span class=\"line\">                let string = request.responseText</span><br><span class=\"line\">                // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class=\"line\">                let object = window.JSON.parse(string)</span><br><span class=\"line\">                // JSON.parse 是浏览器提供的</span><br><span class=\"line\">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                console.log(&apos;fail&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class=\"line\">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class=\"line\">    request.send()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4f376b146466e10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<h2 id=\"同源政策\"><a href=\"#同源政策\" class=\"headerlink\" title=\"同源政策\"></a>同源政策</h2><p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>文章开头提到的 form 和 a 等发送请求是没有同源政策的，而 AJAX 是可以读取响应内容的。<br><strong>因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求</strong></p>\n<hr>\n<h2 id=\"如何规避同源政策？跨域\"><a href=\"#如何规避同源政策？跨域\" class=\"headerlink\" title=\"如何规避同源政策？跨域\"></a>如何规避同源政策？跨域</h2><p>有关 JSONP 跨域在文章开头提供我的博客举过例子<br>这次我们用 <strong>CORS 跨域</strong><br>什么是 CORS:<strong>Cross-Origin Resource Sharing(跨域资源共享)</strong></p>\n<hr>\n<p>同样用<a href=\"https://www.jianshu.com/p/38a72bd0e37d\" target=\"_blank\" rel=\"noopener\">理解 JSONP 下</a>博客中创建过的网站来举例子<br>首先打开服务器端口<img src=\"https://upload-images.jianshu.io/upload_images/7094266-49fcd7432b2c7d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>把请求路径改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.open(&apos;GET&apos;, &apos;http://jack.com:8002/ada&apos;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-706af4f9ecdace99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>点击点我<img src=\"https://upload-images.jianshu.io/upload_images/7094266-7a4b7e5d44756b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">报错了，因为不是同源，响应完成却得不到任何内容</p>\n<p><strong>解决方法，在 Node 代码中加入一句</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//允许 http://ada.com:8001 访问我</span><br><span class=\"line\">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://ada.com:8001&apos;)</span><br></pre></td></tr></table></figure>\n<p>点击点我，即可向 ada.com:8001 发送请求并返回 jack.com:8002/ada 的响应内容<img src=\"https://upload-images.jianshu.io/upload_images/7094266-1797c104e4b05d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>这就是用 CORS 实现 AJAX 跨域的过程</p>\n<p>完整代码详见 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/AJAX-demo\">github</a></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前写了一篇博客<a href=\"https://www.jianshu.com/p/2a2fe02917e7\" target=\"_blank\" rel=\"noopener\">理解 JSONP 上</a>关于 AJAX 出现之前如何发请求<br>简单回顾一下：</p>\n<h4 id=\"1-用-form-可以发请求，缺点是会刷新页面或新开页面\"><a href=\"#1-用-form-可以发请求，缺点是会刷新页面或新开页面\" class=\"headerlink\" title=\"1.用 form 可以发请求，缺点是会刷新页面或新开页面\"></a>1.用 form 可以发请求，缺点是会刷新页面或新开页面</h4><p>form 发送 get 请求：<img src=\"https://upload-images.jianshu.io/upload_images/7094266-8a9a80cde134701d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>输入密码后，点击提交，打开开发者工具可以看到一个 get 请求，点开找到 Request Headers 点击<strong>view source</strong> <img src=\"https://upload-images.jianshu.io/upload_images/7094266-2f497d2ed697fabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>同样可以用 form 发送 post 请求，与 get 请求区别是 post 请求没有查询参数<img src=\"https://upload-images.jianshu.io/upload_images/7094266-2a9955c21d5904d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>post 请求的第四部分 password 在下面的 Form Data 的<strong>view source</strong> 里<img src=\"https://upload-images.jianshu.io/upload_images/7094266-c10130216b9836f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"2-用-a-可以发-get-请求，但是也会刷新页面或新开页面\"><a href=\"#2-用-a-可以发-get-请求，但是也会刷新页面或新开页面\" class=\"headerlink\" title=\"2.用 a 可以发 get 请求，但是也会刷新页面或新开页面\"></a>2.用 a 可以发 get 请求，但是也会刷新页面或新开页面</h4><p>点击 click 就发送请求<img src=\"https://upload-images.jianshu.io/upload_images/7094266-e8ecdf0d63d5c019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a id=&quot;ada&quot; href=&quot;/ada&quot;&gt;click&lt;/a&gt;</span><br><span class=\"line\">//运行一个脚本，让网页自己点击（但是依然会刷新页面）</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  ada.click()</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示\"><a href=\"#3-用-img-可以发-get-请求，它不会刷新页面，但是只能以图片的形式展示\" class=\"headerlink\" title=\"3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示\"></a>3.用 img 可以发 get 请求，它不会刷新页面，但是只能以图片的形式展示</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var image = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">  image.src = &apos;/ada&apos;</span><br><span class=\"line\">  image.onload = function()&#123;</span><br><span class=\"line\">    console.log(&apos;succsee&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  image.onerror = function()&#123;</span><br><span class=\"line\">    console.log(&apos;fail&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-9b2b91b49a0575b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示\"><a href=\"#4-用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示\" class=\"headerlink\" title=\"4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示\"></a>4.用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var link = document.createElement(&apos;link&apos;)</span><br><span class=\"line\">  link.rel = &apos;stylesheet&apos;</span><br><span class=\"line\">  link.href = &apos;/ada&apos;</span><br><span class=\"line\">  //需要将link放到页面中才能发送请求</span><br><span class=\"line\">  document.head.appendChild(link)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ff9dc05b89603af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"5-用-script-可以发-get-请求，但是只能以脚本的形式运行\"><a href=\"#5-用-script-可以发-get-请求，但是只能以脚本的形式运行\" class=\"headerlink\" title=\"5.用 script 可以发 get 请求，但是只能以脚本的形式运行\"></a>5.用 script 可以发 get 请求，但是只能以脚本的形式运行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  var script = document.createElement(&apos;script&apos;)</span><br><span class=\"line\">  script.src = &quot;/ada&quot;</span><br><span class=\"line\">  //需要将script放到页面中才能发送请求</span><br><span class=\"line\">  document.head.appendChild(script)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当然还有其他方法</p>\n<hr>\n<p>有关 AJAX 的学习推荐<a href=\"http://javascript.ruanyifeng.com/bom/ajax.html#toc0\" target=\"_blank\" rel=\"noopener\">阮一峰博客</a><br><strong>微软的突破</strong><br>IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。<br>随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范<br><strong>AJAX</strong><br>Jesse James Garrett 将如下技术取名叫做 AJAX（Asynchronous JavaScript and XML）：异步的 JavaScript 和 XML<br><strong><em>1.使用 XMLHttpRequest 发请求 2.服务器返回 XML 格式的字符串<br>3.JS 解析 XML，并更新局部页面</em></strong></p>\n<h4 id=\"同样我们用-node-服务器来尝试一下这三个条件-AJAX\"><a href=\"#同样我们用-node-服务器来尝试一下这三个条件-AJAX\" class=\"headerlink\" title=\"同样我们用 node 服务器来尝试一下这三个条件(AJAX)\"></a>同样我们用 node 服务器来尝试一下这三个条件(AJAX)</h4><p>新建 html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    hi</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;含查询字符串的路径\\n&apos; + pathWithQuery)</span><br><span class=\"line\">  if (path === &apos;/&apos;) &#123;</span><br><span class=\"line\">    var string = fs.readFileSync(&apos;./index.html&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125; else&#123;</span><br><span class=\"line\">    response.statusCode = 404</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(&apos;找不到服务器&apos;)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>对于 HTTP 来说，响应的第四部分始终是 string<img src=\"https://upload-images.jianshu.io/upload_images/7094266-01746a588b0abc36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>在 html 里创建一个 button，引入当前目录下的 js 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码//在原 Node 代码中插入，下同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意这里是 /main.js 而不是 ./main.js，因为HTTP请求永远是绝对路径</span><br><span class=\"line\">else if (path === &apos;/main.js&apos;) &#123;</span><br><span class=\"line\">//这里当然是./main.js</span><br><span class=\"line\">    var string = fs.readFileSync(&apos;./main.js&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>首先满足 1.使用 XMLHttpRequest 发请求</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class=\"line\">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class=\"line\">    request.send()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>2.服务器返回 XML 格式的字符串</strong><br>XML 已经不流行了，但是我们依然可以尝试一下<br>找一个一个 XML example</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if (path === &apos;/ada&apos;) &#123;</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(`</span><br><span class=\"line\">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">    &lt;note&gt;</span><br><span class=\"line\">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class=\"line\">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class=\"line\">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class=\"line\">    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class=\"line\">&lt;/note&gt;`)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d5529f18c6d6d036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>3.JS 解析 XML，并更新局部页面</strong><br>浏览器是分步下载响应的，一般只要记住 <strong>readyState === 4</strong> 表示请求完成<img src=\"https://upload-images.jianshu.io/upload_images/7094266-a27d3791360b1d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以用 <strong>onreadystatechange</strong> 监听 readyState</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                console.log(&apos;success&apos;)</span><br><span class=\"line\">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                console.log(&apos;fail&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class=\"line\">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class=\"line\">    request.send()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-6159a07fdb534df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>如果把(path === ‘/ada’){}里改成 400 //注意不要改错地方</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.statusCode = 400</span><br></pre></td></tr></table></figure>\n<p>当然会返回 fail，可以看到 readyState 是不受状态码影响的<img src=\"https://upload-images.jianshu.io/upload_images/7094266-dc4181f8240aa1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>JS 是可以解析 XML 的，但是现在 XML 已经被 JSON 取代了，我们可以简单打印出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(request.responseText)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-beb53639db92273c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p><a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener\">JSON</a><br>JSON 是道格拉斯基于 JavaScript 发明的数据交换语言</p>\n<ul>\n<li>特点：<br>-<ul>\n<li>只有 object、array、string、number、true、false、null 这几种类型</li>\n<li>字符串首尾必须为双引号</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS         VS         JSON</span><br><span class=\"line\">undefined/symbel      无</span><br><span class=\"line\">null                  null</span><br><span class=\"line\">[&apos;a&apos;,&apos;b&apos;]             [&quot;a&quot;,&quot;b&quot;]</span><br><span class=\"line\">function f()&#123;&#125;        无</span><br><span class=\"line\">&#123;a:b&#125;                 &#123;&quot;a&quot;,&quot;b&quot;&#125;</span><br><span class=\"line\">&apos;hello world&apos;         &quot;hello world&quot;</span><br><span class=\"line\">var a = &#123;&#125;</span><br><span class=\"line\">a.self = a            无法做到&#123;无变量等形式&#125;</span><br><span class=\"line\">&#123;__proto__&#125;           没有原型链</span><br></pre></td></tr></table></figure>\n<p><strong>用 JSON 替换 XML</strong><br>Node 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">else if (path === &apos;/ada&apos;) &#123;</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/xml; charset=utf-8&apos;)</span><br><span class=\"line\">//变XML为JSON，key和value都可以替换成自己喜欢的</span><br><span class=\"line\">    response.write(`</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;note&quot;:&#123;</span><br><span class=\"line\">        &quot;to&quot;: &quot;reader&quot;,</span><br><span class=\"line\">        &quot;from&quot;: &quot;Ada&quot;,</span><br><span class=\"line\">        &quot;heading&quot;: &quot;greet&quot;,</span><br><span class=\"line\">        &quot;content&quot;: &quot;hello word!&quot;</span><br><span class=\"line\">    &#125;`)</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>js 完整代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            console.log(&apos;请求响应都完成了&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                console.log(&apos;success&apos;)</span><br><span class=\"line\">                console.log(typeof request.responseText)</span><br><span class=\"line\">                console.log(request.responseText)</span><br><span class=\"line\">                let string = request.responseText</span><br><span class=\"line\">                // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class=\"line\">                let object = window.JSON.parse(string)</span><br><span class=\"line\">                // JSON.parse 是浏览器提供的</span><br><span class=\"line\">                //响应值在300-400之间浏览器会重新发送请求</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                console.log(&apos;fail&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //初始化请求，参数为:method,url,async(异步状态下才是AJAX),user,password(后三个参数一般默认)</span><br><span class=\"line\">    request.open(&apos;GET&apos;, &apos;/ada&apos;)</span><br><span class=\"line\">    request.send()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4f376b146466e10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<h2 id=\"同源政策\"><a href=\"#同源政策\" class=\"headerlink\" title=\"同源政策\"></a>同源政策</h2><p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>文章开头提到的 form 和 a 等发送请求是没有同源政策的，而 AJAX 是可以读取响应内容的。<br><strong>因此只有 协议+端口+域名 一模一样（同源）才允许发 AJAX 请求</strong></p>\n<hr>\n<h2 id=\"如何规避同源政策？跨域\"><a href=\"#如何规避同源政策？跨域\" class=\"headerlink\" title=\"如何规避同源政策？跨域\"></a>如何规避同源政策？跨域</h2><p>有关 JSONP 跨域在文章开头提供我的博客举过例子<br>这次我们用 <strong>CORS 跨域</strong><br>什么是 CORS:<strong>Cross-Origin Resource Sharing(跨域资源共享)</strong></p>\n<hr>\n<p>同样用<a href=\"https://www.jianshu.com/p/38a72bd0e37d\" target=\"_blank\" rel=\"noopener\">理解 JSONP 下</a>博客中创建过的网站来举例子<br>首先打开服务器端口<img src=\"https://upload-images.jianshu.io/upload_images/7094266-49fcd7432b2c7d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>把请求路径改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.open(&apos;GET&apos;, &apos;http://jack.com:8002/ada&apos;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-706af4f9ecdace99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>点击点我<img src=\"https://upload-images.jianshu.io/upload_images/7094266-7a4b7e5d44756b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">报错了，因为不是同源，响应完成却得不到任何内容</p>\n<p><strong>解决方法，在 Node 代码中加入一句</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//允许 http://ada.com:8001 访问我</span><br><span class=\"line\">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://ada.com:8001&apos;)</span><br></pre></td></tr></table></figure>\n<p>点击点我，即可向 ada.com:8001 发送请求并返回 jack.com:8002/ada 的响应内容<img src=\"https://upload-images.jianshu.io/upload_images/7094266-1797c104e4b05d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>这就是用 CORS 实现 AJAX 跨域的过程</p>\n<p>完整代码详见 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/AJAX-demo\">github</a></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n"},{"title":"CSS 常用布局 续篇","date":"2018-09-10T02:32:52.000Z","_content":"\n几个月前初学 CSS 布局，写了一篇关于 [CSS 常用布局学习](https://www.jianshu.com/p/59c9477816b8) 的博客，介绍了一些传统的依靠 position 和 float 等实现简单的布局方式的例子，这些布局只能简单得实现基本功能，十分不便。\n今天，作为引申，我们用同样例子，来使用上篇中简单提到的 flex 布局的方案实现。与此同时，我将推荐最近学习的 grid 布局，它十分强大，可以方便得解决各种布局方案，且十分便于理解。\n\n### Flex 实现左中右布局\n\n主要是在父元素中使用以下代码\n\n```\ndisplay: flex;\nflex-direction:row;\n```\n\n相对于传统布局，是不是简便得多![Flex 左中右](https://upload-images.jianshu.io/upload_images/7094266-f0d2834c90f115a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### Flex 实现垂直居中\n\n```\ndisplay: flex;\njustify-content:center;\nalign-items:center;\n```\n\n![Flex 垂直居中](https://upload-images.jianshu.io/upload_images/7094266-42ece01a2af28519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到 flex 布局十分方便\n想要了解更多 flex 布局相关技巧可以阅读阮大大 [博客](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html) 当然你可以看 MDN\n\n前面介绍的都是一维布局，但是在复杂的二维布局方面，无疑是为解决布局而创建的 CSS 网格布局更为专业\n学习网格布局事实上是学习对应英文的过程，所以英语好真的很有优势\n\n### Grid 布局实现左中右\n\n虽然有点大材小用，但是我们是为了和前面的布局方法做对比\n你只需用两行代码\n\n```\ndisplay: grid;\ngrid-template-columns: 30% 40% 30%;\n```\n\ngrid 布局的代码更省，子元素不需要各自设定，直接在父元素上设定了![Grid 左中右](https://upload-images.jianshu.io/upload_images/7094266-beb5abb9ff73f97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)当然这里的子元素要与对应的格子相配，即 30% 40% 30% 对应的是 div.container 里面的顺序\n\n### 网格布局\n\n这里的 fr 为分数单位\n\n```\ndisplay: grid;\ngrid-template-columns: 1fr 1fr 1fr; // 3列均分\ngrid-template-rows: 1fr 1fr 1fr; // 3行均分\n```\n\n通过上面代码实现了一个 3\\*3 的网格\n可以通过下面代码选择对应网格，并添加属性\n\n```\ngrid-column: 1; // or 2 or 3\ngrid-row: 1; // or 2 or 3\n```\n\n![网格布局示例](https://upload-images.jianshu.io/upload_images/7094266-fe08051eb5cf5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n以上只是 flex 布局和 grid 布局的小例子和基本用法\n想要了解更多 grid 相关内容可以看这篇 [博客](https://www.jianshu.com/p/d183265a8dad)\n通过 flex 和 grid 布局配合使用，基本上可以解决所有 CSS 布局问题\n\n本文仅供个人学习使用\n","source":"_posts/CSS常用布局-续篇.md","raw":"---\ntitle: CSS 常用布局 续篇\ndate: 2018-09-10 10:32:52\ntags: CSS\n---\n\n几个月前初学 CSS 布局，写了一篇关于 [CSS 常用布局学习](https://www.jianshu.com/p/59c9477816b8) 的博客，介绍了一些传统的依靠 position 和 float 等实现简单的布局方式的例子，这些布局只能简单得实现基本功能，十分不便。\n今天，作为引申，我们用同样例子，来使用上篇中简单提到的 flex 布局的方案实现。与此同时，我将推荐最近学习的 grid 布局，它十分强大，可以方便得解决各种布局方案，且十分便于理解。\n\n### Flex 实现左中右布局\n\n主要是在父元素中使用以下代码\n\n```\ndisplay: flex;\nflex-direction:row;\n```\n\n相对于传统布局，是不是简便得多![Flex 左中右](https://upload-images.jianshu.io/upload_images/7094266-f0d2834c90f115a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### Flex 实现垂直居中\n\n```\ndisplay: flex;\njustify-content:center;\nalign-items:center;\n```\n\n![Flex 垂直居中](https://upload-images.jianshu.io/upload_images/7094266-42ece01a2af28519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到 flex 布局十分方便\n想要了解更多 flex 布局相关技巧可以阅读阮大大 [博客](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html) 当然你可以看 MDN\n\n前面介绍的都是一维布局，但是在复杂的二维布局方面，无疑是为解决布局而创建的 CSS 网格布局更为专业\n学习网格布局事实上是学习对应英文的过程，所以英语好真的很有优势\n\n### Grid 布局实现左中右\n\n虽然有点大材小用，但是我们是为了和前面的布局方法做对比\n你只需用两行代码\n\n```\ndisplay: grid;\ngrid-template-columns: 30% 40% 30%;\n```\n\ngrid 布局的代码更省，子元素不需要各自设定，直接在父元素上设定了![Grid 左中右](https://upload-images.jianshu.io/upload_images/7094266-beb5abb9ff73f97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)当然这里的子元素要与对应的格子相配，即 30% 40% 30% 对应的是 div.container 里面的顺序\n\n### 网格布局\n\n这里的 fr 为分数单位\n\n```\ndisplay: grid;\ngrid-template-columns: 1fr 1fr 1fr; // 3列均分\ngrid-template-rows: 1fr 1fr 1fr; // 3行均分\n```\n\n通过上面代码实现了一个 3\\*3 的网格\n可以通过下面代码选择对应网格，并添加属性\n\n```\ngrid-column: 1; // or 2 or 3\ngrid-row: 1; // or 2 or 3\n```\n\n![网格布局示例](https://upload-images.jianshu.io/upload_images/7094266-fe08051eb5cf5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n以上只是 flex 布局和 grid 布局的小例子和基本用法\n想要了解更多 grid 相关内容可以看这篇 [博客](https://www.jianshu.com/p/d183265a8dad)\n通过 flex 和 grid 布局配合使用，基本上可以解决所有 CSS 布局问题\n\n本文仅供个人学习使用\n","slug":"CSS常用布局-续篇","published":1,"updated":"2020-03-28T17:30:23.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyh0003ws999z0r81cf","content":"<p>几个月前初学 CSS 布局，写了一篇关于 <a href=\"https://www.jianshu.com/p/59c9477816b8\" target=\"_blank\" rel=\"noopener\">CSS 常用布局学习</a> 的博客，介绍了一些传统的依靠 position 和 float 等实现简单的布局方式的例子，这些布局只能简单得实现基本功能，十分不便。<br>今天，作为引申，我们用同样例子，来使用上篇中简单提到的 flex 布局的方案实现。与此同时，我将推荐最近学习的 grid 布局，它十分强大，可以方便得解决各种布局方案，且十分便于理解。</p>\n<h3 id=\"Flex-实现左中右布局\"><a href=\"#Flex-实现左中右布局\" class=\"headerlink\" title=\"Flex 实现左中右布局\"></a>Flex 实现左中右布局</h3><p>主要是在父元素中使用以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction:row;</span><br></pre></td></tr></table></figure>\n<p>相对于传统布局，是不是简便得多<img src=\"https://upload-images.jianshu.io/upload_images/7094266-f0d2834c90f115a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Flex 左中右\"></p>\n<h3 id=\"Flex-实现垂直居中\"><a href=\"#Flex-实现垂直居中\" class=\"headerlink\" title=\"Flex 实现垂直居中\"></a>Flex 实现垂直居中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: flex;</span><br><span class=\"line\">justify-content:center;</span><br><span class=\"line\">align-items:center;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-42ece01a2af28519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Flex 垂直居中\"></p>\n<p>可以看到 flex 布局十分方便<br>想要了解更多 flex 布局相关技巧可以阅读阮大大 <a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">博客</a> 当然你可以看 MDN</p>\n<p>前面介绍的都是一维布局，但是在复杂的二维布局方面，无疑是为解决布局而创建的 CSS 网格布局更为专业<br>学习网格布局事实上是学习对应英文的过程，所以英语好真的很有优势</p>\n<h3 id=\"Grid-布局实现左中右\"><a href=\"#Grid-布局实现左中右\" class=\"headerlink\" title=\"Grid 布局实现左中右\"></a>Grid 布局实现左中右</h3><p>虽然有点大材小用，但是我们是为了和前面的布局方法做对比<br>你只需用两行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-template-columns: 30% 40% 30%;</span><br></pre></td></tr></table></figure>\n<p>grid 布局的代码更省，子元素不需要各自设定，直接在父元素上设定了<img src=\"https://upload-images.jianshu.io/upload_images/7094266-beb5abb9ff73f97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Grid 左中右\">当然这里的子元素要与对应的格子相配，即 30% 40% 30% 对应的是 div.container 里面的顺序</p>\n<h3 id=\"网格布局\"><a href=\"#网格布局\" class=\"headerlink\" title=\"网格布局\"></a>网格布局</h3><p>这里的 fr 为分数单位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-template-columns: 1fr 1fr 1fr; // 3列均分</span><br><span class=\"line\">grid-template-rows: 1fr 1fr 1fr; // 3行均分</span><br></pre></td></tr></table></figure>\n<p>通过上面代码实现了一个 3*3 的网格<br>可以通过下面代码选择对应网格，并添加属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid-column: 1; // or 2 or 3</span><br><span class=\"line\">grid-row: 1; // or 2 or 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fe08051eb5cf5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网格布局示例\"></p>\n<hr>\n<p>以上只是 flex 布局和 grid 布局的小例子和基本用法<br>想要了解更多 grid 相关内容可以看这篇 <a href=\"https://www.jianshu.com/p/d183265a8dad\" target=\"_blank\" rel=\"noopener\">博客</a><br>通过 flex 和 grid 布局配合使用，基本上可以解决所有 CSS 布局问题</p>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>几个月前初学 CSS 布局，写了一篇关于 <a href=\"https://www.jianshu.com/p/59c9477816b8\" target=\"_blank\" rel=\"noopener\">CSS 常用布局学习</a> 的博客，介绍了一些传统的依靠 position 和 float 等实现简单的布局方式的例子，这些布局只能简单得实现基本功能，十分不便。<br>今天，作为引申，我们用同样例子，来使用上篇中简单提到的 flex 布局的方案实现。与此同时，我将推荐最近学习的 grid 布局，它十分强大，可以方便得解决各种布局方案，且十分便于理解。</p>\n<h3 id=\"Flex-实现左中右布局\"><a href=\"#Flex-实现左中右布局\" class=\"headerlink\" title=\"Flex 实现左中右布局\"></a>Flex 实现左中右布局</h3><p>主要是在父元素中使用以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: flex;</span><br><span class=\"line\">flex-direction:row;</span><br></pre></td></tr></table></figure>\n<p>相对于传统布局，是不是简便得多<img src=\"https://upload-images.jianshu.io/upload_images/7094266-f0d2834c90f115a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Flex 左中右\"></p>\n<h3 id=\"Flex-实现垂直居中\"><a href=\"#Flex-实现垂直居中\" class=\"headerlink\" title=\"Flex 实现垂直居中\"></a>Flex 实现垂直居中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: flex;</span><br><span class=\"line\">justify-content:center;</span><br><span class=\"line\">align-items:center;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-42ece01a2af28519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Flex 垂直居中\"></p>\n<p>可以看到 flex 布局十分方便<br>想要了解更多 flex 布局相关技巧可以阅读阮大大 <a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">博客</a> 当然你可以看 MDN</p>\n<p>前面介绍的都是一维布局，但是在复杂的二维布局方面，无疑是为解决布局而创建的 CSS 网格布局更为专业<br>学习网格布局事实上是学习对应英文的过程，所以英语好真的很有优势</p>\n<h3 id=\"Grid-布局实现左中右\"><a href=\"#Grid-布局实现左中右\" class=\"headerlink\" title=\"Grid 布局实现左中右\"></a>Grid 布局实现左中右</h3><p>虽然有点大材小用，但是我们是为了和前面的布局方法做对比<br>你只需用两行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-template-columns: 30% 40% 30%;</span><br></pre></td></tr></table></figure>\n<p>grid 布局的代码更省，子元素不需要各自设定，直接在父元素上设定了<img src=\"https://upload-images.jianshu.io/upload_images/7094266-beb5abb9ff73f97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Grid 左中右\">当然这里的子元素要与对应的格子相配，即 30% 40% 30% 对应的是 div.container 里面的顺序</p>\n<h3 id=\"网格布局\"><a href=\"#网格布局\" class=\"headerlink\" title=\"网格布局\"></a>网格布局</h3><p>这里的 fr 为分数单位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-template-columns: 1fr 1fr 1fr; // 3列均分</span><br><span class=\"line\">grid-template-rows: 1fr 1fr 1fr; // 3行均分</span><br></pre></td></tr></table></figure>\n<p>通过上面代码实现了一个 3*3 的网格<br>可以通过下面代码选择对应网格，并添加属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid-column: 1; // or 2 or 3</span><br><span class=\"line\">grid-row: 1; // or 2 or 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fe08051eb5cf5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网格布局示例\"></p>\n<hr>\n<p>以上只是 flex 布局和 grid 布局的小例子和基本用法<br>想要了解更多 grid 相关内容可以看这篇 <a href=\"https://www.jianshu.com/p/d183265a8dad\" target=\"_blank\" rel=\"noopener\">博客</a><br>通过 flex 和 grid 布局配合使用，基本上可以解决所有 CSS 布局问题</p>\n<p>本文仅供个人学习使用</p>\n"},{"title":"7 个实用的 JavaScript 小技巧（译文）","date":"2019-05-06T15:52:09.000Z","_content":"\n本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。\n原文：[7 Useful JavaScript Tricks](https://davidwalsh.name/javascript-tricks)\n以下为译文：\n和其他编程语言一样，JavaScript 有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 JavaScript 小技巧！\n\n# 数组去重\n\n获取[数组的唯一值](https://davidwalsh.name/array-unique)可能比你想象中要简单：\n\n```\nvar j = [...new Set([1, 2, 3, 3])]\n>> [1, 2, 3]\n```\n\n我超爱（...）和 Set！\n\n# 数组配合布尔\n\n要从一个数组中[过滤 falsy 值](https://davidwalsh.name/array-boolean)？你或许不知道有这种技巧：\n\n```\nmyArray\n    .map(item => {\n        // ...\n        // 记得 return\n    })\n    // 摆脱这些空值\n    .filter(Boolean);\n```\n\n只需传递 Boolean 就能去除这些 falsy 值！\n\n# 创建一个空的对象\n\n当然，似乎你可以通过像 {} 这样来创建一个空对象，但实际上这样创建的对象还是有\\_\\_proto\\_\\_、hasOwnProperty 以及其他对象的方法。下面是一种[创造一个纯对象](https://davidwalsh.name/object-create-null)的方法：\n\n```\nlet dict = Object.create(null);\n\n// dict.__proto__ === \"undefined\"\n// 在你添加动态属性之前为空\n```\n\n这个对象上绝对没有你没有放入的键或方法！\n\n# 合并对象\n\nJavaScript [合并多个对象](https://davidwalsh.name/merge-objects)的需求由来已久，尤其是当我们创建带有选项的类和小部件时：\n\n```\nconst person = { name: 'David Walsh', gender: 'Male' };\nconst tools = { computer: 'Mac', editor: 'Atom' };\nconst attributes = { handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' };\n\nconst summary = {...person, ...tools, ...attributes};\n/*\nObject {\n  \"computer\": \"Mac\",\n  \"editor\": \"Atom\",\n  \"eyes\": \"Blue\",\n  \"gender\": \"Male\",\n  \"hair\": \"Brown\",\n  \"handsomeness\": \"Extreme\",\n  \"name\": \"David Walsh\",\n}\n*/\n```\n\n这三个点让任务变得简单多了！\n\n# 强制函数传参\n\n能够为函数参数设置默认值是 JavaScript 的一个很棒的补充。请查看这个技巧，[要求为给定的参数](<[https://davidwalsh.name/javascript-function-parameters](https://davidwalsh.name/javascript-function-parameters)>)传递值：\n\n```\nconst isRequired = () => { throw new Error('param is required'); };\n\nconst hello = (name = isRequired()) => { console.log(`hello ${name}`) };\n\n// 由于没给 hello() 传 name，该代码会报错\n\n// 下面代码也会报错\nhello(undefined);\n\n// 来看看符合要求的写法\nhello(null);\nhello('David');\n```\n\n这是一些下一级验证和 JavaScript 用法\n\n# 解构别名\n\n[解构赋值](https://davidwalsh.name/destructuring-alias)是一个非常受欢迎的 JavaScript 升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：\n\n```\nconst obj = { x: 1 };\n\n// Grabs obj.x as { x }\nconst { x } = obj;\n\n// Grabs obj.x as { otherName }\nconst { x: otherName } = obj;\n```\n\n有效避免了与现有变量的命名冲突！\n\n# 获取查询字符串参数\n\n多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 [URLSearchParams](<[https://davidwalsh.name/query-string-javascript](https://davidwalsh.name/query-string-javascript)>) API\n\n```\n// 假设 \"?post=1234&action=edit\"\n\nvar urlParams = new URLSearchParams(window.location.search);\n\nconsole.log(urlParams.has('post')); // true\nconsole.log(urlParams.get('action')); // \"edit\"\nconsole.log(urlParams.getAll('action')); // [\"edit\"]\nconsole.log(urlParams.toString()); // \"?post=1234&action=edit\"\nconsole.log(urlParams.append('active', '1')); // \"?post=1234&action=edit&active=1\"\n```\n\n是不是比之前简单多了。\n\n这些年 JavaScript 已经发生了很大的变化，但我最喜欢的部分是我们现在看到 JavaScript 语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需!\n\n你最喜欢的 JavaScript 技巧是什么呢？\n","source":"_posts/7个实用的-JavaScript-小技巧（译文）.md","raw":"---\ntitle: 7 个实用的 JavaScript 小技巧（译文）\ndate: 2019-05-06 23:52:09\ntags: JavaScript\n---\n\n本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。\n原文：[7 Useful JavaScript Tricks](https://davidwalsh.name/javascript-tricks)\n以下为译文：\n和其他编程语言一样，JavaScript 有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 JavaScript 小技巧！\n\n# 数组去重\n\n获取[数组的唯一值](https://davidwalsh.name/array-unique)可能比你想象中要简单：\n\n```\nvar j = [...new Set([1, 2, 3, 3])]\n>> [1, 2, 3]\n```\n\n我超爱（...）和 Set！\n\n# 数组配合布尔\n\n要从一个数组中[过滤 falsy 值](https://davidwalsh.name/array-boolean)？你或许不知道有这种技巧：\n\n```\nmyArray\n    .map(item => {\n        // ...\n        // 记得 return\n    })\n    // 摆脱这些空值\n    .filter(Boolean);\n```\n\n只需传递 Boolean 就能去除这些 falsy 值！\n\n# 创建一个空的对象\n\n当然，似乎你可以通过像 {} 这样来创建一个空对象，但实际上这样创建的对象还是有\\_\\_proto\\_\\_、hasOwnProperty 以及其他对象的方法。下面是一种[创造一个纯对象](https://davidwalsh.name/object-create-null)的方法：\n\n```\nlet dict = Object.create(null);\n\n// dict.__proto__ === \"undefined\"\n// 在你添加动态属性之前为空\n```\n\n这个对象上绝对没有你没有放入的键或方法！\n\n# 合并对象\n\nJavaScript [合并多个对象](https://davidwalsh.name/merge-objects)的需求由来已久，尤其是当我们创建带有选项的类和小部件时：\n\n```\nconst person = { name: 'David Walsh', gender: 'Male' };\nconst tools = { computer: 'Mac', editor: 'Atom' };\nconst attributes = { handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' };\n\nconst summary = {...person, ...tools, ...attributes};\n/*\nObject {\n  \"computer\": \"Mac\",\n  \"editor\": \"Atom\",\n  \"eyes\": \"Blue\",\n  \"gender\": \"Male\",\n  \"hair\": \"Brown\",\n  \"handsomeness\": \"Extreme\",\n  \"name\": \"David Walsh\",\n}\n*/\n```\n\n这三个点让任务变得简单多了！\n\n# 强制函数传参\n\n能够为函数参数设置默认值是 JavaScript 的一个很棒的补充。请查看这个技巧，[要求为给定的参数](<[https://davidwalsh.name/javascript-function-parameters](https://davidwalsh.name/javascript-function-parameters)>)传递值：\n\n```\nconst isRequired = () => { throw new Error('param is required'); };\n\nconst hello = (name = isRequired()) => { console.log(`hello ${name}`) };\n\n// 由于没给 hello() 传 name，该代码会报错\n\n// 下面代码也会报错\nhello(undefined);\n\n// 来看看符合要求的写法\nhello(null);\nhello('David');\n```\n\n这是一些下一级验证和 JavaScript 用法\n\n# 解构别名\n\n[解构赋值](https://davidwalsh.name/destructuring-alias)是一个非常受欢迎的 JavaScript 升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：\n\n```\nconst obj = { x: 1 };\n\n// Grabs obj.x as { x }\nconst { x } = obj;\n\n// Grabs obj.x as { otherName }\nconst { x: otherName } = obj;\n```\n\n有效避免了与现有变量的命名冲突！\n\n# 获取查询字符串参数\n\n多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 [URLSearchParams](<[https://davidwalsh.name/query-string-javascript](https://davidwalsh.name/query-string-javascript)>) API\n\n```\n// 假设 \"?post=1234&action=edit\"\n\nvar urlParams = new URLSearchParams(window.location.search);\n\nconsole.log(urlParams.has('post')); // true\nconsole.log(urlParams.get('action')); // \"edit\"\nconsole.log(urlParams.getAll('action')); // [\"edit\"]\nconsole.log(urlParams.toString()); // \"?post=1234&action=edit\"\nconsole.log(urlParams.append('active', '1')); // \"?post=1234&action=edit&active=1\"\n```\n\n是不是比之前简单多了。\n\n这些年 JavaScript 已经发生了很大的变化，但我最喜欢的部分是我们现在看到 JavaScript 语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需!\n\n你最喜欢的 JavaScript 技巧是什么呢？\n","slug":"7个实用的-JavaScript-小技巧（译文）","published":1,"updated":"2020-03-28T17:37:43.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyi0004ws99yfyssdvp","content":"<p>本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。<br>原文：<a href=\"https://davidwalsh.name/javascript-tricks\" target=\"_blank\" rel=\"noopener\">7 Useful JavaScript Tricks</a><br>以下为译文：<br>和其他编程语言一样，JavaScript 有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 JavaScript 小技巧！</p>\n<h1 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h1><p>获取<a href=\"https://davidwalsh.name/array-unique\" target=\"_blank\" rel=\"noopener\">数组的唯一值</a>可能比你想象中要简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var j = [...new Set([1, 2, 3, 3])]</span><br><span class=\"line\">&gt;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>我超爱（…）和 Set！</p>\n<h1 id=\"数组配合布尔\"><a href=\"#数组配合布尔\" class=\"headerlink\" title=\"数组配合布尔\"></a>数组配合布尔</h1><p>要从一个数组中<a href=\"https://davidwalsh.name/array-boolean\" target=\"_blank\" rel=\"noopener\">过滤 falsy 值</a>？你或许不知道有这种技巧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myArray</span><br><span class=\"line\">    .map(item =&gt; &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        // 记得 return</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 摆脱这些空值</span><br><span class=\"line\">    .filter(Boolean);</span><br></pre></td></tr></table></figure>\n<p>只需传递 Boolean 就能去除这些 falsy 值！</p>\n<h1 id=\"创建一个空的对象\"><a href=\"#创建一个空的对象\" class=\"headerlink\" title=\"创建一个空的对象\"></a>创建一个空的对象</h1><p>当然，似乎你可以通过像 {} 这样来创建一个空对象，但实际上这样创建的对象还是有__proto__、hasOwnProperty 以及其他对象的方法。下面是一种<a href=\"https://davidwalsh.name/object-create-null\" target=\"_blank\" rel=\"noopener\">创造一个纯对象</a>的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let dict = Object.create(null);</span><br><span class=\"line\"></span><br><span class=\"line\">// dict.__proto__ === &quot;undefined&quot;</span><br><span class=\"line\">// 在你添加动态属性之前为空</span><br></pre></td></tr></table></figure>\n<p>这个对象上绝对没有你没有放入的键或方法！</p>\n<h1 id=\"合并对象\"><a href=\"#合并对象\" class=\"headerlink\" title=\"合并对象\"></a>合并对象</h1><p>JavaScript <a href=\"https://davidwalsh.name/merge-objects\" target=\"_blank\" rel=\"noopener\">合并多个对象</a>的需求由来已久，尤其是当我们创建带有选项的类和小部件时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123; name: &apos;David Walsh&apos;, gender: &apos;Male&apos; &#125;;</span><br><span class=\"line\">const tools = &#123; computer: &apos;Mac&apos;, editor: &apos;Atom&apos; &#125;;</span><br><span class=\"line\">const attributes = &#123; handsomeness: &apos;Extreme&apos;, hair: &apos;Brown&apos;, eyes: &apos;Blue&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const summary = &#123;...person, ...tools, ...attributes&#125;;</span><br><span class=\"line\">/*</span><br><span class=\"line\">Object &#123;</span><br><span class=\"line\">  &quot;computer&quot;: &quot;Mac&quot;,</span><br><span class=\"line\">  &quot;editor&quot;: &quot;Atom&quot;,</span><br><span class=\"line\">  &quot;eyes&quot;: &quot;Blue&quot;,</span><br><span class=\"line\">  &quot;gender&quot;: &quot;Male&quot;,</span><br><span class=\"line\">  &quot;hair&quot;: &quot;Brown&quot;,</span><br><span class=\"line\">  &quot;handsomeness&quot;: &quot;Extreme&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;David Walsh&quot;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>这三个点让任务变得简单多了！</p>\n<h1 id=\"强制函数传参\"><a href=\"#强制函数传参\" class=\"headerlink\" title=\"强制函数传参\"></a>强制函数传参</h1><p>能够为函数参数设置默认值是 JavaScript 的一个很棒的补充。请查看这个技巧，<a href=\"[https://davidwalsh.name/javascript-function-parameters](https://davidwalsh.name/javascript-function-parameters\">要求为给定的参数</a>&gt;)传递值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const isRequired = () =&gt; &#123; throw new Error(&apos;param is required&apos;); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于没给 hello() 传 name，该代码会报错</span><br><span class=\"line\"></span><br><span class=\"line\">// 下面代码也会报错</span><br><span class=\"line\">hello(undefined);</span><br><span class=\"line\"></span><br><span class=\"line\">// 来看看符合要求的写法</span><br><span class=\"line\">hello(null);</span><br><span class=\"line\">hello(&apos;David&apos;);</span><br></pre></td></tr></table></figure>\n<p>这是一些下一级验证和 JavaScript 用法</p>\n<h1 id=\"解构别名\"><a href=\"#解构别名\" class=\"headerlink\" title=\"解构别名\"></a>解构别名</h1><p><a href=\"https://davidwalsh.name/destructuring-alias\" target=\"_blank\" rel=\"noopener\">解构赋值</a>是一个非常受欢迎的 JavaScript 升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123; x: 1 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Grabs obj.x as &#123; x &#125;</span><br><span class=\"line\">const &#123; x &#125; = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// Grabs obj.x as &#123; otherName &#125;</span><br><span class=\"line\">const &#123; x: otherName &#125; = obj;</span><br></pre></td></tr></table></figure>\n<p>有效避免了与现有变量的命名冲突！</p>\n<h1 id=\"获取查询字符串参数\"><a href=\"#获取查询字符串参数\" class=\"headerlink\" title=\"获取查询字符串参数\"></a>获取查询字符串参数</h1><p>多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 <a href=\"[https://davidwalsh.name/query-string-javascript](https://davidwalsh.name/query-string-javascript\">URLSearchParams</a>&gt;) API</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 假设 &quot;?post=1234&amp;action=edit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var urlParams = new URLSearchParams(window.location.search);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(urlParams.has(&apos;post&apos;)); // true</span><br><span class=\"line\">console.log(urlParams.get(&apos;action&apos;)); // &quot;edit&quot;</span><br><span class=\"line\">console.log(urlParams.getAll(&apos;action&apos;)); // [&quot;edit&quot;]</span><br><span class=\"line\">console.log(urlParams.toString()); // &quot;?post=1234&amp;action=edit&quot;</span><br><span class=\"line\">console.log(urlParams.append(&apos;active&apos;, &apos;1&apos;)); // &quot;?post=1234&amp;action=edit&amp;active=1&quot;</span><br></pre></td></tr></table></figure>\n<p>是不是比之前简单多了。</p>\n<p>这些年 JavaScript 已经发生了很大的变化，但我最喜欢的部分是我们现在看到 JavaScript 语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需!</p>\n<p>你最喜欢的 JavaScript 技巧是什么呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文为译文，第一次尝试翻译英文博客，很多地方翻译得不好。本文内容十分简单，可直接查看英文原文，或直接看代码部分。文章每一部分都有拓展（暂未翻译），可点击查看。<br>原文：<a href=\"https://davidwalsh.name/javascript-tricks\" target=\"_blank\" rel=\"noopener\">7 Useful JavaScript Tricks</a><br>以下为译文：<br>和其他编程语言一样，JavaScript 有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 JavaScript 小技巧！</p>\n<h1 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h1><p>获取<a href=\"https://davidwalsh.name/array-unique\" target=\"_blank\" rel=\"noopener\">数组的唯一值</a>可能比你想象中要简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var j = [...new Set([1, 2, 3, 3])]</span><br><span class=\"line\">&gt;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>我超爱（…）和 Set！</p>\n<h1 id=\"数组配合布尔\"><a href=\"#数组配合布尔\" class=\"headerlink\" title=\"数组配合布尔\"></a>数组配合布尔</h1><p>要从一个数组中<a href=\"https://davidwalsh.name/array-boolean\" target=\"_blank\" rel=\"noopener\">过滤 falsy 值</a>？你或许不知道有这种技巧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myArray</span><br><span class=\"line\">    .map(item =&gt; &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        // 记得 return</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 摆脱这些空值</span><br><span class=\"line\">    .filter(Boolean);</span><br></pre></td></tr></table></figure>\n<p>只需传递 Boolean 就能去除这些 falsy 值！</p>\n<h1 id=\"创建一个空的对象\"><a href=\"#创建一个空的对象\" class=\"headerlink\" title=\"创建一个空的对象\"></a>创建一个空的对象</h1><p>当然，似乎你可以通过像 {} 这样来创建一个空对象，但实际上这样创建的对象还是有__proto__、hasOwnProperty 以及其他对象的方法。下面是一种<a href=\"https://davidwalsh.name/object-create-null\" target=\"_blank\" rel=\"noopener\">创造一个纯对象</a>的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let dict = Object.create(null);</span><br><span class=\"line\"></span><br><span class=\"line\">// dict.__proto__ === &quot;undefined&quot;</span><br><span class=\"line\">// 在你添加动态属性之前为空</span><br></pre></td></tr></table></figure>\n<p>这个对象上绝对没有你没有放入的键或方法！</p>\n<h1 id=\"合并对象\"><a href=\"#合并对象\" class=\"headerlink\" title=\"合并对象\"></a>合并对象</h1><p>JavaScript <a href=\"https://davidwalsh.name/merge-objects\" target=\"_blank\" rel=\"noopener\">合并多个对象</a>的需求由来已久，尤其是当我们创建带有选项的类和小部件时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123; name: &apos;David Walsh&apos;, gender: &apos;Male&apos; &#125;;</span><br><span class=\"line\">const tools = &#123; computer: &apos;Mac&apos;, editor: &apos;Atom&apos; &#125;;</span><br><span class=\"line\">const attributes = &#123; handsomeness: &apos;Extreme&apos;, hair: &apos;Brown&apos;, eyes: &apos;Blue&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const summary = &#123;...person, ...tools, ...attributes&#125;;</span><br><span class=\"line\">/*</span><br><span class=\"line\">Object &#123;</span><br><span class=\"line\">  &quot;computer&quot;: &quot;Mac&quot;,</span><br><span class=\"line\">  &quot;editor&quot;: &quot;Atom&quot;,</span><br><span class=\"line\">  &quot;eyes&quot;: &quot;Blue&quot;,</span><br><span class=\"line\">  &quot;gender&quot;: &quot;Male&quot;,</span><br><span class=\"line\">  &quot;hair&quot;: &quot;Brown&quot;,</span><br><span class=\"line\">  &quot;handsomeness&quot;: &quot;Extreme&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;David Walsh&quot;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>这三个点让任务变得简单多了！</p>\n<h1 id=\"强制函数传参\"><a href=\"#强制函数传参\" class=\"headerlink\" title=\"强制函数传参\"></a>强制函数传参</h1><p>能够为函数参数设置默认值是 JavaScript 的一个很棒的补充。请查看这个技巧，<a href=\"[https://davidwalsh.name/javascript-function-parameters](https://davidwalsh.name/javascript-function-parameters\">要求为给定的参数</a>&gt;)传递值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const isRequired = () =&gt; &#123; throw new Error(&apos;param is required&apos;); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于没给 hello() 传 name，该代码会报错</span><br><span class=\"line\"></span><br><span class=\"line\">// 下面代码也会报错</span><br><span class=\"line\">hello(undefined);</span><br><span class=\"line\"></span><br><span class=\"line\">// 来看看符合要求的写法</span><br><span class=\"line\">hello(null);</span><br><span class=\"line\">hello(&apos;David&apos;);</span><br></pre></td></tr></table></figure>\n<p>这是一些下一级验证和 JavaScript 用法</p>\n<h1 id=\"解构别名\"><a href=\"#解构别名\" class=\"headerlink\" title=\"解构别名\"></a>解构别名</h1><p><a href=\"https://davidwalsh.name/destructuring-alias\" target=\"_blank\" rel=\"noopener\">解构赋值</a>是一个非常受欢迎的 JavaScript 升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123; x: 1 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Grabs obj.x as &#123; x &#125;</span><br><span class=\"line\">const &#123; x &#125; = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// Grabs obj.x as &#123; otherName &#125;</span><br><span class=\"line\">const &#123; x: otherName &#125; = obj;</span><br></pre></td></tr></table></figure>\n<p>有效避免了与现有变量的命名冲突！</p>\n<h1 id=\"获取查询字符串参数\"><a href=\"#获取查询字符串参数\" class=\"headerlink\" title=\"获取查询字符串参数\"></a>获取查询字符串参数</h1><p>多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 <a href=\"[https://davidwalsh.name/query-string-javascript](https://davidwalsh.name/query-string-javascript\">URLSearchParams</a>&gt;) API</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 假设 &quot;?post=1234&amp;action=edit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var urlParams = new URLSearchParams(window.location.search);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(urlParams.has(&apos;post&apos;)); // true</span><br><span class=\"line\">console.log(urlParams.get(&apos;action&apos;)); // &quot;edit&quot;</span><br><span class=\"line\">console.log(urlParams.getAll(&apos;action&apos;)); // [&quot;edit&quot;]</span><br><span class=\"line\">console.log(urlParams.toString()); // &quot;?post=1234&amp;action=edit&quot;</span><br><span class=\"line\">console.log(urlParams.append(&apos;active&apos;, &apos;1&apos;)); // &quot;?post=1234&amp;action=edit&amp;active=1&quot;</span><br></pre></td></tr></table></figure>\n<p>是不是比之前简单多了。</p>\n<p>这些年 JavaScript 已经发生了很大的变化，但我最喜欢的部分是我们现在看到 JavaScript 语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需!</p>\n<p>你最喜欢的 JavaScript 技巧是什么呢？</p>\n"},{"title":"CSS 常用布局学习","date":"2018-06-22T14:35:31.000Z","_content":"\n最近开始学习 CSS，了解了一些基础和常规写法。CSS 的知识十分复杂，是值得不断发掘和完善的一个前端模块。对于新人来说，最好的方法就是尝试，去模仿，遇到问题再去深入，一点一点得增加对 CSS 的基础的理解。\n\nCSS 布局对于新人来说，是一个比较基础的难点，首先我们应该理解一些常用的布局属性\n\n[学习 CSS 布局](http://zh.learnlayout.com/)  通过这以网站，学习**'display'**，**'position'**  以及  **'float' **等属性，加深对其认识。\n\n![](https://upload-images.jianshu.io/upload_images/7094266-da5183cded1d63d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n下面介绍几种常用的布局方法\n\n# 1.左右布局\n\n1.1.用  **'float' **实现左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-36b825766bb976e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n只要设定两个布局块的宽度总和为 '**container'(容器) **的宽，那么俩个 class 的 float 属性可均为  **'float:left;' **\n\n也可以用以下方法让右边块级元素自适应左边达到左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-95e2ada432bbbcee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n即给  **'right'**  的宽度加上  **'margin-left'**\n\n1.2.用** 'position' **实现左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5711c22ce85c4def.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n父元素设置为**position:relative;**\n\nleft 设置固定宽度，设定为**绝对定位'position:absolute'**。\n\nright 设置为**相对定位'position:relative'**。\n\nright 设置左边距，**'margin-left' **为左侧栏的宽度。\n\n# 2.左中右布局\n\n2.1.用  **'float' **实现左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4af2cbc2a81b81ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其原理与  **'float' **左右布局一样，且也可以用自适应。\n\n值得注意的是  **'middle' **所在块与  **'left' **所在块一样，要用  **'float:left;' **\n\n而  **'right'**  所在块可以用  **'float:left'**  或  **'float:right;'**  以及自适应。\n\n2.2.用** 'position' **实现左中右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-83bd3380ae9c53c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n原理与前面类似，值得注意的是，我们要调整一下 html 的布局，保证  **'right' **列 div 在  **'middle' **列 div 前，不然会出现第三块换行显示的情况，此问题涉及**文档流**\n\n**文档流：**文档内元素的流动方向：内联元素从左往右，宽度不够另起一行继续；块级元素，每一块占一行，从上到下依次往下\n\n所以同理，2.1.中**'middle' **若用自适应，也要调整 html 与上面一样\n\n# 3.水平居中\n\n其实前面已经用到了水平居中的方法\n\n**margin: 0 auto;**  常用于块级元素\n\n![](https://upload-images.jianshu.io/upload_images/7094266-467bc19891cc934f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然还有其他水平居中及垂直居中的方法，网上有很多相关博客。如[16 种方法实现水平居中垂直居中](http://louiszhai.github.io/2016/03/12/css-center/)\n\n---\n\n另外，如何实现将垂直元素变成水平，也可以用**'float:left;'**\n\n方法如下：\n\n1.给所有的子元素加  **float:left**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ef4aadee77723993.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.给父元素加  **clearfix 类  **（其目的是去掉**float:left **产生的 bug，一定会有 bug，因此一定要加上）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d7be5e5d7ed3302e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**clearfix 类**写法如下\n\n![](https://upload-images.jianshu.io/upload_images/7094266-0b746da3ed8fa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n通过上述知识，相信你对**'display'**，**'position'**  以及  **'float'**  等属性已经有所认识。后续学习过程中了解了  **'flex'**属性（其实[学习 CSS 布局](https://link.zhihu.com/?target=http%3A//zh.learnlayout.com/toc.html)里提到了，有兴趣可以看 MDN 文档，但是看文档很多时候不能快速理解）推荐看看大佬们的博客，这里推荐阮一峰老师关于**'flex'布局**的[博客](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)，上述 1，2 种布局方式现已经不提倡，**'flex'**是个强大的属性，**'flex'布局**应作为布局的首选。\n\n本文主要用于个人学习使用，如有侵权请联系我删除\n\n主要参考：\n\n[学习 CSS 布局](http://zh.learnlayout.com/toc.html)\n\n[CSS 常见布局](https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-layout.html)\n\n[DIV + CSS 页面基本布局总结](https://www.jianshu.com/p/c6673f8a6a5a)\n\n[16 种方法实现水平居中垂直居中](http://louiszhai.github.io/2016/03/12/css-center/)\n","source":"_posts/CSS常用布局学习.md","raw":"---\ntitle: CSS 常用布局学习\ndate: 2018-06-22 22:35:31\ntags: CSS\n---\n\n最近开始学习 CSS，了解了一些基础和常规写法。CSS 的知识十分复杂，是值得不断发掘和完善的一个前端模块。对于新人来说，最好的方法就是尝试，去模仿，遇到问题再去深入，一点一点得增加对 CSS 的基础的理解。\n\nCSS 布局对于新人来说，是一个比较基础的难点，首先我们应该理解一些常用的布局属性\n\n[学习 CSS 布局](http://zh.learnlayout.com/)  通过这以网站，学习**'display'**，**'position'**  以及  **'float' **等属性，加深对其认识。\n\n![](https://upload-images.jianshu.io/upload_images/7094266-da5183cded1d63d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n下面介绍几种常用的布局方法\n\n# 1.左右布局\n\n1.1.用  **'float' **实现左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-36b825766bb976e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n只要设定两个布局块的宽度总和为 '**container'(容器) **的宽，那么俩个 class 的 float 属性可均为  **'float:left;' **\n\n也可以用以下方法让右边块级元素自适应左边达到左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-95e2ada432bbbcee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n即给  **'right'**  的宽度加上  **'margin-left'**\n\n1.2.用** 'position' **实现左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5711c22ce85c4def.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n父元素设置为**position:relative;**\n\nleft 设置固定宽度，设定为**绝对定位'position:absolute'**。\n\nright 设置为**相对定位'position:relative'**。\n\nright 设置左边距，**'margin-left' **为左侧栏的宽度。\n\n# 2.左中右布局\n\n2.1.用  **'float' **实现左右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4af2cbc2a81b81ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其原理与  **'float' **左右布局一样，且也可以用自适应。\n\n值得注意的是  **'middle' **所在块与  **'left' **所在块一样，要用  **'float:left;' **\n\n而  **'right'**  所在块可以用  **'float:left'**  或  **'float:right;'**  以及自适应。\n\n2.2.用** 'position' **实现左中右布局\n\n![](https://upload-images.jianshu.io/upload_images/7094266-83bd3380ae9c53c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n原理与前面类似，值得注意的是，我们要调整一下 html 的布局，保证  **'right' **列 div 在  **'middle' **列 div 前，不然会出现第三块换行显示的情况，此问题涉及**文档流**\n\n**文档流：**文档内元素的流动方向：内联元素从左往右，宽度不够另起一行继续；块级元素，每一块占一行，从上到下依次往下\n\n所以同理，2.1.中**'middle' **若用自适应，也要调整 html 与上面一样\n\n# 3.水平居中\n\n其实前面已经用到了水平居中的方法\n\n**margin: 0 auto;**  常用于块级元素\n\n![](https://upload-images.jianshu.io/upload_images/7094266-467bc19891cc934f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然还有其他水平居中及垂直居中的方法，网上有很多相关博客。如[16 种方法实现水平居中垂直居中](http://louiszhai.github.io/2016/03/12/css-center/)\n\n---\n\n另外，如何实现将垂直元素变成水平，也可以用**'float:left;'**\n\n方法如下：\n\n1.给所有的子元素加  **float:left**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ef4aadee77723993.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.给父元素加  **clearfix 类  **（其目的是去掉**float:left **产生的 bug，一定会有 bug，因此一定要加上）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d7be5e5d7ed3302e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**clearfix 类**写法如下\n\n![](https://upload-images.jianshu.io/upload_images/7094266-0b746da3ed8fa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n通过上述知识，相信你对**'display'**，**'position'**  以及  **'float'**  等属性已经有所认识。后续学习过程中了解了  **'flex'**属性（其实[学习 CSS 布局](https://link.zhihu.com/?target=http%3A//zh.learnlayout.com/toc.html)里提到了，有兴趣可以看 MDN 文档，但是看文档很多时候不能快速理解）推荐看看大佬们的博客，这里推荐阮一峰老师关于**'flex'布局**的[博客](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)，上述 1，2 种布局方式现已经不提倡，**'flex'**是个强大的属性，**'flex'布局**应作为布局的首选。\n\n本文主要用于个人学习使用，如有侵权请联系我删除\n\n主要参考：\n\n[学习 CSS 布局](http://zh.learnlayout.com/toc.html)\n\n[CSS 常见布局](https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-layout.html)\n\n[DIV + CSS 页面基本布局总结](https://www.jianshu.com/p/c6673f8a6a5a)\n\n[16 种方法实现水平居中垂直居中](http://louiszhai.github.io/2016/03/12/css-center/)\n","slug":"CSS常用布局学习","published":1,"updated":"2020-03-28T17:31:14.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyj0005ws996dt0zv8s","content":"<p>最近开始学习 CSS，了解了一些基础和常规写法。CSS 的知识十分复杂，是值得不断发掘和完善的一个前端模块。对于新人来说，最好的方法就是尝试，去模仿，遇到问题再去深入，一点一点得增加对 CSS 的基础的理解。</p>\n<p>CSS 布局对于新人来说，是一个比较基础的难点，首先我们应该理解一些常用的布局属性</p>\n<p><a href=\"http://zh.learnlayout.com/\" target=\"_blank\" rel=\"noopener\">学习 CSS 布局</a>  通过这以网站，学习<strong>‘display’</strong>，<strong>‘position’</strong>  以及  <strong>‘float’ </strong>等属性，加深对其认识。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-da5183cded1d63d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p>下面介绍几种常用的布局方法</p>\n<h1 id=\"1-左右布局\"><a href=\"#1-左右布局\" class=\"headerlink\" title=\"1.左右布局\"></a>1.左右布局</h1><p>1.1.用  <strong>‘float’ </strong>实现左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-36b825766bb976e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>只要设定两个布局块的宽度总和为 ‘<strong>container’(容器) </strong>的宽，那么俩个 class 的 float 属性可均为  <strong>‘float:left;’ </strong></p>\n<p>也可以用以下方法让右边块级元素自适应左边达到左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-95e2ada432bbbcee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>即给  <strong>‘right’</strong>  的宽度加上  <strong>‘margin-left’</strong></p>\n<p>1.2.用<strong> ‘position’ </strong>实现左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5711c22ce85c4def.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>父元素设置为<strong>position:relative;</strong></p>\n<p>left 设置固定宽度，设定为<strong>绝对定位’position:absolute’</strong>。</p>\n<p>right 设置为<strong>相对定位’position:relative’</strong>。</p>\n<p>right 设置左边距，<strong>‘margin-left’ </strong>为左侧栏的宽度。</p>\n<h1 id=\"2-左中右布局\"><a href=\"#2-左中右布局\" class=\"headerlink\" title=\"2.左中右布局\"></a>2.左中右布局</h1><p>2.1.用  <strong>‘float’ </strong>实现左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4af2cbc2a81b81ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其原理与  <strong>‘float’ </strong>左右布局一样，且也可以用自适应。</p>\n<p>值得注意的是  <strong>‘middle’ </strong>所在块与  <strong>‘left’ </strong>所在块一样，要用  <strong>‘float:left;’ </strong></p>\n<p>而  <strong>‘right’</strong>  所在块可以用  <strong>‘float:left’</strong>  或  <strong>‘float:right;’</strong>  以及自适应。</p>\n<p>2.2.用<strong> ‘position’ </strong>实现左中右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-83bd3380ae9c53c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>原理与前面类似，值得注意的是，我们要调整一下 html 的布局，保证  <strong>‘right’ </strong>列 div 在  <strong>‘middle’ </strong>列 div 前，不然会出现第三块换行显示的情况，此问题涉及<strong>文档流</strong></p>\n<p><strong>文档流：</strong>文档内元素的流动方向：内联元素从左往右，宽度不够另起一行继续；块级元素，每一块占一行，从上到下依次往下</p>\n<p>所以同理，2.1.中<strong>‘middle’ </strong>若用自适应，也要调整 html 与上面一样</p>\n<h1 id=\"3-水平居中\"><a href=\"#3-水平居中\" class=\"headerlink\" title=\"3.水平居中\"></a>3.水平居中</h1><p>其实前面已经用到了水平居中的方法</p>\n<p><strong>margin: 0 auto;</strong>  常用于块级元素</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-467bc19891cc934f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当然还有其他水平居中及垂直居中的方法，网上有很多相关博客。如<a href=\"http://louiszhai.github.io/2016/03/12/css-center/\" target=\"_blank\" rel=\"noopener\">16 种方法实现水平居中垂直居中</a></p>\n<hr>\n<p>另外，如何实现将垂直元素变成水平，也可以用<strong>‘float:left;’</strong></p>\n<p>方法如下：</p>\n<p>1.给所有的子元素加  <strong>float:left</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ef4aadee77723993.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>2.给父元素加  <strong>clearfix 类  </strong>（其目的是去掉<strong>float:left </strong>产生的 bug，一定会有 bug，因此一定要加上）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d7be5e5d7ed3302e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>clearfix 类</strong>写法如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0b746da3ed8fa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p>通过上述知识，相信你对<strong>‘display’</strong>，<strong>‘position’</strong>  以及  <strong>‘float’</strong>  等属性已经有所认识。后续学习过程中了解了  <strong>‘flex’</strong>属性（其实<a href=\"https://link.zhihu.com/?target=http%3A//zh.learnlayout.com/toc.html\" target=\"_blank\" rel=\"noopener\">学习 CSS 布局</a>里提到了，有兴趣可以看 MDN 文档，但是看文档很多时候不能快速理解）推荐看看大佬们的博客，这里推荐阮一峰老师关于<strong>‘flex’布局</strong>的<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">博客</a>，上述 1，2 种布局方式现已经不提倡，<strong>‘flex’</strong>是个强大的属性，<strong>‘flex’布局</strong>应作为布局的首选。</p>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除</p>\n<p>主要参考：</p>\n<p><a href=\"http://zh.learnlayout.com/toc.html\" target=\"_blank\" rel=\"noopener\">学习 CSS 布局</a></p>\n<p><a href=\"https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-layout.html\" target=\"_blank\" rel=\"noopener\">CSS 常见布局</a></p>\n<p><a href=\"https://www.jianshu.com/p/c6673f8a6a5a\" target=\"_blank\" rel=\"noopener\">DIV + CSS 页面基本布局总结</a></p>\n<p><a href=\"http://louiszhai.github.io/2016/03/12/css-center/\" target=\"_blank\" rel=\"noopener\">16 种方法实现水平居中垂直居中</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近开始学习 CSS，了解了一些基础和常规写法。CSS 的知识十分复杂，是值得不断发掘和完善的一个前端模块。对于新人来说，最好的方法就是尝试，去模仿，遇到问题再去深入，一点一点得增加对 CSS 的基础的理解。</p>\n<p>CSS 布局对于新人来说，是一个比较基础的难点，首先我们应该理解一些常用的布局属性</p>\n<p><a href=\"http://zh.learnlayout.com/\" target=\"_blank\" rel=\"noopener\">学习 CSS 布局</a>  通过这以网站，学习<strong>‘display’</strong>，<strong>‘position’</strong>  以及  <strong>‘float’ </strong>等属性，加深对其认识。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-da5183cded1d63d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p>下面介绍几种常用的布局方法</p>\n<h1 id=\"1-左右布局\"><a href=\"#1-左右布局\" class=\"headerlink\" title=\"1.左右布局\"></a>1.左右布局</h1><p>1.1.用  <strong>‘float’ </strong>实现左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-36b825766bb976e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>只要设定两个布局块的宽度总和为 ‘<strong>container’(容器) </strong>的宽，那么俩个 class 的 float 属性可均为  <strong>‘float:left;’ </strong></p>\n<p>也可以用以下方法让右边块级元素自适应左边达到左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-95e2ada432bbbcee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>即给  <strong>‘right’</strong>  的宽度加上  <strong>‘margin-left’</strong></p>\n<p>1.2.用<strong> ‘position’ </strong>实现左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5711c22ce85c4def.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>父元素设置为<strong>position:relative;</strong></p>\n<p>left 设置固定宽度，设定为<strong>绝对定位’position:absolute’</strong>。</p>\n<p>right 设置为<strong>相对定位’position:relative’</strong>。</p>\n<p>right 设置左边距，<strong>‘margin-left’ </strong>为左侧栏的宽度。</p>\n<h1 id=\"2-左中右布局\"><a href=\"#2-左中右布局\" class=\"headerlink\" title=\"2.左中右布局\"></a>2.左中右布局</h1><p>2.1.用  <strong>‘float’ </strong>实现左右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4af2cbc2a81b81ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其原理与  <strong>‘float’ </strong>左右布局一样，且也可以用自适应。</p>\n<p>值得注意的是  <strong>‘middle’ </strong>所在块与  <strong>‘left’ </strong>所在块一样，要用  <strong>‘float:left;’ </strong></p>\n<p>而  <strong>‘right’</strong>  所在块可以用  <strong>‘float:left’</strong>  或  <strong>‘float:right;’</strong>  以及自适应。</p>\n<p>2.2.用<strong> ‘position’ </strong>实现左中右布局</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-83bd3380ae9c53c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>原理与前面类似，值得注意的是，我们要调整一下 html 的布局，保证  <strong>‘right’ </strong>列 div 在  <strong>‘middle’ </strong>列 div 前，不然会出现第三块换行显示的情况，此问题涉及<strong>文档流</strong></p>\n<p><strong>文档流：</strong>文档内元素的流动方向：内联元素从左往右，宽度不够另起一行继续；块级元素，每一块占一行，从上到下依次往下</p>\n<p>所以同理，2.1.中<strong>‘middle’ </strong>若用自适应，也要调整 html 与上面一样</p>\n<h1 id=\"3-水平居中\"><a href=\"#3-水平居中\" class=\"headerlink\" title=\"3.水平居中\"></a>3.水平居中</h1><p>其实前面已经用到了水平居中的方法</p>\n<p><strong>margin: 0 auto;</strong>  常用于块级元素</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-467bc19891cc934f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当然还有其他水平居中及垂直居中的方法，网上有很多相关博客。如<a href=\"http://louiszhai.github.io/2016/03/12/css-center/\" target=\"_blank\" rel=\"noopener\">16 种方法实现水平居中垂直居中</a></p>\n<hr>\n<p>另外，如何实现将垂直元素变成水平，也可以用<strong>‘float:left;’</strong></p>\n<p>方法如下：</p>\n<p>1.给所有的子元素加  <strong>float:left</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ef4aadee77723993.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>2.给父元素加  <strong>clearfix 类  </strong>（其目的是去掉<strong>float:left </strong>产生的 bug，一定会有 bug，因此一定要加上）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d7be5e5d7ed3302e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>clearfix 类</strong>写法如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0b746da3ed8fa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p>通过上述知识，相信你对<strong>‘display’</strong>，<strong>‘position’</strong>  以及  <strong>‘float’</strong>  等属性已经有所认识。后续学习过程中了解了  <strong>‘flex’</strong>属性（其实<a href=\"https://link.zhihu.com/?target=http%3A//zh.learnlayout.com/toc.html\" target=\"_blank\" rel=\"noopener\">学习 CSS 布局</a>里提到了，有兴趣可以看 MDN 文档，但是看文档很多时候不能快速理解）推荐看看大佬们的博客，这里推荐阮一峰老师关于<strong>‘flex’布局</strong>的<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">博客</a>，上述 1，2 种布局方式现已经不提倡，<strong>‘flex’</strong>是个强大的属性，<strong>‘flex’布局</strong>应作为布局的首选。</p>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除</p>\n<p>主要参考：</p>\n<p><a href=\"http://zh.learnlayout.com/toc.html\" target=\"_blank\" rel=\"noopener\">学习 CSS 布局</a></p>\n<p><a href=\"https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-layout.html\" target=\"_blank\" rel=\"noopener\">CSS 常见布局</a></p>\n<p><a href=\"https://www.jianshu.com/p/c6673f8a6a5a\" target=\"_blank\" rel=\"noopener\">DIV + CSS 页面基本布局总结</a></p>\n<p><a href=\"http://louiszhai.github.io/2016/03/12/css-center/\" target=\"_blank\" rel=\"noopener\">16 种方法实现水平居中垂直居中</a></p>\n"},{"title":"HTML 入门笔记","date":"2018-06-11T12:30:39.000Z","_content":"\n**HTML（HyperText Markup Language）**超文本标记语言\n\n**W3C 万维网联盟**（**World Wide Web Consortium）**  是万维网的主要国际标准组织\n\n---\n\n# **如何学习标签**？\n\n知道它的意思就记住了，如：\n\n```\n替代：alternatives (alt)\n\n段落：paragraph (p)\n\n锚元素：anchor (a)\n\n有序列表：ordered list (ol)；list item (li)\n\n无序列表：unordered list (ul)；list item (li)\n\n描述列表：description list (dl)；描述术语：description term (dt)；描述定义：description definition (dd)\n```\n\n[导航：navigation (nav)](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav)\n**常用标签**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a36df6ef936eeaca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n什么是 [空元素](https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0)：可以理解为通常不含闭标签的元素，如<br>\n\n可以出现在 head 元素内的元素  [link](https://github.com/joshbuchea/HEAD#elements)\n\n**noscrip**t**：**如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在 HTML 元素中定义脚本未被执行时的替代内容。\n\n<strong> HTML 标签没有**块级元素**和**内联元素**的区别，因为它无法控制。**HTML 不管样式**，只管内容，CSS 会管样式的。写标签时一定不能管样式 。（[内联元素（行内元素）](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente)）</strong>\n\n**HTML 内联框架（Inline elements）元素   [iframe](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe) **表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中。  表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中\n\n[块级元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements)  默认 display 为 block，如 div\n\n![](https://upload-images.jianshu.io/upload_images/7094266-dbe2604159a53d9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[可替换元素](https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element)  是表示超出 CSS 范围的元素;  它们是表示独立于 CSS 格式模型的外部对象\n\n典型的替换元素是：iframe、video、embed（嵌入）、img\n\nHTML 表格（table）由标签定义。每个表格行都用 tr 标签定义。表头 th 是用标签定义的。默认情况下，表格标题以粗体居中。表格数据/单元格用 td 标签定义\n\n![](https://upload-images.jianshu.io/upload_images/7094266-40be247e9d24e463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n之前在 IFE 的学习：[笔记](http://ife.baidu.com/note/detail/id/1037)\n\n内容很乱很多，后续还应该循序渐进。最重要的是以用带记，遇到了把它记下来，多用几次自然就记住了。\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n","source":"_posts/HTML入门笔记.md","raw":"---\ntitle: HTML 入门笔记\ndate: 2018-06-11 20:30:39\ntags: HTML\n---\n\n**HTML（HyperText Markup Language）**超文本标记语言\n\n**W3C 万维网联盟**（**World Wide Web Consortium）**  是万维网的主要国际标准组织\n\n---\n\n# **如何学习标签**？\n\n知道它的意思就记住了，如：\n\n```\n替代：alternatives (alt)\n\n段落：paragraph (p)\n\n锚元素：anchor (a)\n\n有序列表：ordered list (ol)；list item (li)\n\n无序列表：unordered list (ul)；list item (li)\n\n描述列表：description list (dl)；描述术语：description term (dt)；描述定义：description definition (dd)\n```\n\n[导航：navigation (nav)](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav)\n**常用标签**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a36df6ef936eeaca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n什么是 [空元素](https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0)：可以理解为通常不含闭标签的元素，如<br>\n\n可以出现在 head 元素内的元素  [link](https://github.com/joshbuchea/HEAD#elements)\n\n**noscrip**t**：**如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在 HTML 元素中定义脚本未被执行时的替代内容。\n\n<strong> HTML 标签没有**块级元素**和**内联元素**的区别，因为它无法控制。**HTML 不管样式**，只管内容，CSS 会管样式的。写标签时一定不能管样式 。（[内联元素（行内元素）](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente)）</strong>\n\n**HTML 内联框架（Inline elements）元素   [iframe](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe) **表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中。  表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中\n\n[块级元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements)  默认 display 为 block，如 div\n\n![](https://upload-images.jianshu.io/upload_images/7094266-dbe2604159a53d9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[可替换元素](https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element)  是表示超出 CSS 范围的元素;  它们是表示独立于 CSS 格式模型的外部对象\n\n典型的替换元素是：iframe、video、embed（嵌入）、img\n\nHTML 表格（table）由标签定义。每个表格行都用 tr 标签定义。表头 th 是用标签定义的。默认情况下，表格标题以粗体居中。表格数据/单元格用 td 标签定义\n\n![](https://upload-images.jianshu.io/upload_images/7094266-40be247e9d24e463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n之前在 IFE 的学习：[笔记](http://ife.baidu.com/note/detail/id/1037)\n\n内容很乱很多，后续还应该循序渐进。最重要的是以用带记，遇到了把它记下来，多用几次自然就记住了。\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n","slug":"HTML入门笔记","published":1,"updated":"2020-03-28T17:35:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyk0006ws990euxzjv4","content":"<p><strong>HTML（HyperText Markup Language）</strong>超文本标记语言</p>\n<p><strong>W3C 万维网联盟</strong>（<strong>World Wide Web Consortium）</strong>  是万维网的主要国际标准组织</p>\n<hr>\n<h1 id=\"如何学习标签？\"><a href=\"#如何学习标签？\" class=\"headerlink\" title=\"如何学习标签？\"></a><strong>如何学习标签</strong>？</h1><p>知道它的意思就记住了，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">替代：alternatives (alt)</span><br><span class=\"line\"></span><br><span class=\"line\">段落：paragraph (p)</span><br><span class=\"line\"></span><br><span class=\"line\">锚元素：anchor (a)</span><br><span class=\"line\"></span><br><span class=\"line\">有序列表：ordered list (ol)；list item (li)</span><br><span class=\"line\"></span><br><span class=\"line\">无序列表：unordered list (ul)；list item (li)</span><br><span class=\"line\"></span><br><span class=\"line\">描述列表：description list (dl)；描述术语：description term (dt)；描述定义：description definition (dd)</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav\" target=\"_blank\" rel=\"noopener\">导航：navigation (nav)</a><br><strong>常用标签</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a36df6ef936eeaca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>什么是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0\" target=\"_blank\" rel=\"noopener\">空元素</a>：可以理解为通常不含闭标签的元素，如<br></p>\n<p>可以出现在 head 元素内的元素  <a href=\"https://github.com/joshbuchea/HEAD#elements\">link</a></p>\n<p><strong>noscrip</strong>t<strong>：</strong>如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在 HTML 元素中定义脚本未被执行时的替代内容。</p>\n<p><strong> HTML 标签没有<strong>块级元素</strong>和<strong>内联元素</strong>的区别，因为它无法控制。<strong>HTML 不管样式</strong>，只管内容，CSS 会管样式的。写标签时一定不能管样式 。（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente\" target=\"_blank\" rel=\"noopener\">内联元素（行内元素）</a>）</strong></p>\n<p><strong>HTML 内联框架（Inline elements）元素   <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe\" target=\"_blank\" rel=\"noopener\">iframe</a> </strong>表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中。  表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements\" target=\"_blank\" rel=\"noopener\">块级元素</a>  默认 display 为 block，如 div</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-dbe2604159a53d9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element\" target=\"_blank\" rel=\"noopener\">可替换元素</a>  是表示超出 CSS 范围的元素;  它们是表示独立于 CSS 格式模型的外部对象</p>\n<p>典型的替换元素是：iframe、video、embed（嵌入）、img</p>\n<p>HTML 表格（table）由标签定义。每个表格行都用 tr 标签定义。表头 th 是用标签定义的。默认情况下，表格标题以粗体居中。表格数据/单元格用 td 标签定义</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-40be247e9d24e463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>之前在 IFE 的学习：<a href=\"http://ife.baidu.com/note/detail/id/1037\" target=\"_blank\" rel=\"noopener\">笔记</a></p>\n<p>内容很乱很多，后续还应该循序渐进。最重要的是以用带记，遇到了把它记下来，多用几次自然就记住了。</p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>HTML（HyperText Markup Language）</strong>超文本标记语言</p>\n<p><strong>W3C 万维网联盟</strong>（<strong>World Wide Web Consortium）</strong>  是万维网的主要国际标准组织</p>\n<hr>\n<h1 id=\"如何学习标签？\"><a href=\"#如何学习标签？\" class=\"headerlink\" title=\"如何学习标签？\"></a><strong>如何学习标签</strong>？</h1><p>知道它的意思就记住了，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">替代：alternatives (alt)</span><br><span class=\"line\"></span><br><span class=\"line\">段落：paragraph (p)</span><br><span class=\"line\"></span><br><span class=\"line\">锚元素：anchor (a)</span><br><span class=\"line\"></span><br><span class=\"line\">有序列表：ordered list (ol)；list item (li)</span><br><span class=\"line\"></span><br><span class=\"line\">无序列表：unordered list (ul)；list item (li)</span><br><span class=\"line\"></span><br><span class=\"line\">描述列表：description list (dl)；描述术语：description term (dt)；描述定义：description definition (dd)</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav\" target=\"_blank\" rel=\"noopener\">导航：navigation (nav)</a><br><strong>常用标签</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a36df6ef936eeaca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>什么是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0\" target=\"_blank\" rel=\"noopener\">空元素</a>：可以理解为通常不含闭标签的元素，如<br></p>\n<p>可以出现在 head 元素内的元素  <a href=\"https://github.com/joshbuchea/HEAD#elements\">link</a></p>\n<p><strong>noscrip</strong>t<strong>：</strong>如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在 HTML 元素中定义脚本未被执行时的替代内容。</p>\n<p><strong> HTML 标签没有<strong>块级元素</strong>和<strong>内联元素</strong>的区别，因为它无法控制。<strong>HTML 不管样式</strong>，只管内容，CSS 会管样式的。写标签时一定不能管样式 。（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente\" target=\"_blank\" rel=\"noopener\">内联元素（行内元素）</a>）</strong></p>\n<p><strong>HTML 内联框架（Inline elements）元素   <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe\" target=\"_blank\" rel=\"noopener\">iframe</a> </strong>表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中。  表示嵌套的浏览上下文，有效地将另一个 HTML 页面嵌入到当前页面中</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements\" target=\"_blank\" rel=\"noopener\">块级元素</a>  默认 display 为 block，如 div</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-dbe2604159a53d9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element\" target=\"_blank\" rel=\"noopener\">可替换元素</a>  是表示超出 CSS 范围的元素;  它们是表示独立于 CSS 格式模型的外部对象</p>\n<p>典型的替换元素是：iframe、video、embed（嵌入）、img</p>\n<p>HTML 表格（table）由标签定义。每个表格行都用 tr 标签定义。表头 th 是用标签定义的。默认情况下，表格标题以粗体居中。表格数据/单元格用 td 标签定义</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-40be247e9d24e463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>之前在 IFE 的学习：<a href=\"http://ife.baidu.com/note/detail/id/1037\" target=\"_blank\" rel=\"noopener\">笔记</a></p>\n<p>内容很乱很多，后续还应该循序渐进。最重要的是以用带记，遇到了把它记下来，多用几次自然就记住了。</p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n"},{"title":"Flutter 踩坑之环境搭建","date":"2019-06-12T14:09:03.000Z","_content":"\n对于前端来说， flutter 学习的难点在于环境搭建\n在跟随 [技术胖：Flutter 开发环境搭建 Windows 版](https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwindows%E7%89%88) 时\n出现以下 ✗ Android license status unknown 的环境错误\n\n![](https://upload-images.jianshu.io/upload_images/7094266-e2d7d273e10ecf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在 [✗ Android license status unknown.](https://github.com/flutter/flutter/issues/16025#) issue 内找到答案\n\n# 解决思路\n\n在下方路径内找到 sdkmanager.bat 文件\n\n```\nC:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\tools\\bin\n```\n\n在以下区域加入如 17 行所示 set JAVA_HOME=\"xxx\\Android Studio\\jre\"\n\n```\n16 @rem Add default JVM options here. You can also use JAVA_OPTS and SDKMANAGER_OPTS to pass JVM options to this script.\n+17 set JAVA_HOME=\"F:\\ada\\Android Studio\\jre\" // 你的 Android Studio\\jre 路径\n18 set DEFAULT_JVM_OPTS=\"-Dcom.android.sdklib.toolsdir=%~dp0\\..\"\n```\n\n再运行 flutter doctor\n\n![](https://upload-images.jianshu.io/upload_images/7094266-49d92a6402463517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n根据提示运行 flutter doctor --android-licenses\n然后一直 y 就可以了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d8ba85e97083d9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以继续愉快得学习拉！\n","source":"_posts/Flutter-踩坑之环境搭建.md","raw":"---\ntitle: Flutter 踩坑之环境搭建\ndate: 2019-06-12 22:09:03\ntags: Flutter\n---\n\n对于前端来说， flutter 学习的难点在于环境搭建\n在跟随 [技术胖：Flutter 开发环境搭建 Windows 版](https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwindows%E7%89%88) 时\n出现以下 ✗ Android license status unknown 的环境错误\n\n![](https://upload-images.jianshu.io/upload_images/7094266-e2d7d273e10ecf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在 [✗ Android license status unknown.](https://github.com/flutter/flutter/issues/16025#) issue 内找到答案\n\n# 解决思路\n\n在下方路径内找到 sdkmanager.bat 文件\n\n```\nC:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\tools\\bin\n```\n\n在以下区域加入如 17 行所示 set JAVA_HOME=\"xxx\\Android Studio\\jre\"\n\n```\n16 @rem Add default JVM options here. You can also use JAVA_OPTS and SDKMANAGER_OPTS to pass JVM options to this script.\n+17 set JAVA_HOME=\"F:\\ada\\Android Studio\\jre\" // 你的 Android Studio\\jre 路径\n18 set DEFAULT_JVM_OPTS=\"-Dcom.android.sdklib.toolsdir=%~dp0\\..\"\n```\n\n再运行 flutter doctor\n\n![](https://upload-images.jianshu.io/upload_images/7094266-49d92a6402463517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n根据提示运行 flutter doctor --android-licenses\n然后一直 y 就可以了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d8ba85e97083d9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以继续愉快得学习拉！\n","slug":"Flutter-踩坑之环境搭建","published":1,"updated":"2020-03-28T17:39:23.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyl0007ws99sc175wpz","content":"<p>对于前端来说， flutter 学习的难点在于环境搭建<br>在跟随 <a href=\"https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwindows%E7%89%88\" target=\"_blank\" rel=\"noopener\">技术胖：Flutter 开发环境搭建 Windows 版</a> 时<br>出现以下 ✗ Android license status unknown 的环境错误</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e2d7d273e10ecf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在 <a href=\"https://github.com/flutter/flutter/issues/16025#\">✗ Android license status unknown.</a> issue 内找到答案</p>\n<h1 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h1><p>在下方路径内找到 sdkmanager.bat 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\tools\\bin</span><br></pre></td></tr></table></figure>\n<p>在以下区域加入如 17 行所示 set JAVA_HOME=”xxx\\Android Studio\\jre”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16 @rem Add default JVM options here. You can also use JAVA_OPTS and SDKMANAGER_OPTS to pass JVM options to this script.</span><br><span class=\"line\">+17 set JAVA_HOME=&quot;F:\\ada\\Android Studio\\jre&quot; // 你的 Android Studio\\jre 路径</span><br><span class=\"line\">18 set DEFAULT_JVM_OPTS=&quot;-Dcom.android.sdklib.toolsdir=%~dp0\\..&quot;</span><br></pre></td></tr></table></figure>\n<p>再运行 flutter doctor</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-49d92a6402463517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>根据提示运行 flutter doctor –android-licenses<br>然后一直 y 就可以了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d8ba85e97083d9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以继续愉快得学习拉！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于前端来说， flutter 学习的难点在于环境搭建<br>在跟随 <a href=\"https://jspang.com/posts/2019/01/20/flutter-base.html#%E7%AC%AC02%E8%8A%82%EF%BC%9Aflutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwindows%E7%89%88\" target=\"_blank\" rel=\"noopener\">技术胖：Flutter 开发环境搭建 Windows 版</a> 时<br>出现以下 ✗ Android license status unknown 的环境错误</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e2d7d273e10ecf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在 <a href=\"https://github.com/flutter/flutter/issues/16025#\">✗ Android license status unknown.</a> issue 内找到答案</p>\n<h1 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h1><p>在下方路径内找到 sdkmanager.bat 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\tools\\bin</span><br></pre></td></tr></table></figure>\n<p>在以下区域加入如 17 行所示 set JAVA_HOME=”xxx\\Android Studio\\jre”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16 @rem Add default JVM options here. You can also use JAVA_OPTS and SDKMANAGER_OPTS to pass JVM options to this script.</span><br><span class=\"line\">+17 set JAVA_HOME=&quot;F:\\ada\\Android Studio\\jre&quot; // 你的 Android Studio\\jre 路径</span><br><span class=\"line\">18 set DEFAULT_JVM_OPTS=&quot;-Dcom.android.sdklib.toolsdir=%~dp0\\..&quot;</span><br></pre></td></tr></table></figure>\n<p>再运行 flutter doctor</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-49d92a6402463517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>根据提示运行 flutter doctor –android-licenses<br>然后一直 y 就可以了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d8ba85e97083d9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以继续愉快得学习拉！</p>\n"},{"title":"HTML 常用的几个标签","date":"2018-06-13T14:04:49.000Z","_content":"\n**遇到新的标签属性等不会用可以用 JS BIN 尝试看看效果，就知道了**\n\n# 常见标签详解\n\n## **1\\. iframe** **标签**\n\n**嵌套页面**\n\n1.1. **iframe 标签**的 **frameborder**  属性\n\n**iframe 标签**自带边界 border，所以用这个属性可以去边界，如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-1031b6812b8aaf57.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-fa67255c8a244a71.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1.2.**iframe 标签**的  **src** 属性：主要用来加链接\n\n1.3.**iframe 标签**的  **name** 属性\n\n**name 属性**与** a 标签**一起使用有效，如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d6e908d8da74ea14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## **2\\. a 标签**\n\n**跳转页面（HTTP GET 请求）**\n\n**target 属性**\n\n**target=\"\\_blank \\_top \\_parent \\_self\"** 的区别，看意思就懂了分别是跳转 新空白页面；最首页（用于不止两个页面，跳到第一个页面）；父页面（不止两个页面，跳到当前页面父页面）；自身页面\n\n命令行下载 http 服务工具\n\n```\nnpm i -g http-server\n```\n\n这样就不用自己写服务了，然后用下面命令打开服务器\n\n```\nhttp-server -c -1\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-23d055b34597b717.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开服务器\n\n下面的路径都可以访问文件夹所在网页文件，复制其中一个在浏览器上访问即可\n\n如http://10.216.155.182:8080\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5af1c1c11575c480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n只有  **href=\"#\"** 没有 **get** 请求\n\n此外  **a 标签**  的 **href**  有以下几种方法\n\n![](https://upload-images.jianshu.io/upload_images/7094266-787bd332399011ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.form 标签\n\n**跳转页面（HTTP POST 请求）**\n\n3.1. **from 标签** 需要加 **（提交按钮）submit** 来显示跳转，如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-aaa0d33e641cd112.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/7094266-e664c2791e3c60dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3.2. **from 标签**  主要用来发起 post 请求（如登录时输入账号密码时候）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ca38a55f51850bee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在网页中点击提交，Network 中 post 请求中的第四部分 From Data 如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-22538ebbc2c5f43d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n若是 HTTP 协议，密码便是明文：\"222\"，这就是为什么会有 HTTPS 出现\n\n3.3. **from 标签**与**a 标签**一样也有** target**\n\n## **4\\. input 标签和 button 标签**\n\n**input 要学的比较多，可以结合[MDN 文档](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)实例学习**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-fad8a6d86142a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**input type=\"button\"**和 **button** 的区别\n\n![](https://upload-images.jianshu.io/upload_images/7094266-583d5833841661dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n区别是  **input** 是空元素，无法内联其他标签，而  **button** 显然可以\n\n注：若 form 表单只有一个  **button 按钮**而无 **type** 属性，**button** 直接升级为  **submit**（跳转）\n\n## 5.table 标签\n\n较完整示例如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-410da64f04c3a907.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1\\. 很多人会忽略  **colgroup**  的使用，它可以用来给 table 的表列表加宽度等属性\n\n2\\. thead tbody tfoot 三个标签可以省略，加上的好处是给了每一部分定义，即使他们顺序打乱，浏览器也可以很好得形成原列表\n\n3\\. 上图中 table 的 border 有空隙可以用\n\n**border-collapse**  来去掉\n\n![](https://upload-images.jianshu.io/upload_images/7094266-b6ee3f969de3dc94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除\n","source":"_posts/HTML常用的几个标签.md","raw":"---\ntitle: HTML 常用的几个标签\ndate: 2018-06-13 22:04:49\ntags: HTML\n---\n\n**遇到新的标签属性等不会用可以用 JS BIN 尝试看看效果，就知道了**\n\n# 常见标签详解\n\n## **1\\. iframe** **标签**\n\n**嵌套页面**\n\n1.1. **iframe 标签**的 **frameborder**  属性\n\n**iframe 标签**自带边界 border，所以用这个属性可以去边界，如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-1031b6812b8aaf57.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-fa67255c8a244a71.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1.2.**iframe 标签**的  **src** 属性：主要用来加链接\n\n1.3.**iframe 标签**的  **name** 属性\n\n**name 属性**与** a 标签**一起使用有效，如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d6e908d8da74ea14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## **2\\. a 标签**\n\n**跳转页面（HTTP GET 请求）**\n\n**target 属性**\n\n**target=\"\\_blank \\_top \\_parent \\_self\"** 的区别，看意思就懂了分别是跳转 新空白页面；最首页（用于不止两个页面，跳到第一个页面）；父页面（不止两个页面，跳到当前页面父页面）；自身页面\n\n命令行下载 http 服务工具\n\n```\nnpm i -g http-server\n```\n\n这样就不用自己写服务了，然后用下面命令打开服务器\n\n```\nhttp-server -c -1\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-23d055b34597b717.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开服务器\n\n下面的路径都可以访问文件夹所在网页文件，复制其中一个在浏览器上访问即可\n\n如http://10.216.155.182:8080\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5af1c1c11575c480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n只有  **href=\"#\"** 没有 **get** 请求\n\n此外  **a 标签**  的 **href**  有以下几种方法\n\n![](https://upload-images.jianshu.io/upload_images/7094266-787bd332399011ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.form 标签\n\n**跳转页面（HTTP POST 请求）**\n\n3.1. **from 标签** 需要加 **（提交按钮）submit** 来显示跳转，如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-aaa0d33e641cd112.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/7094266-e664c2791e3c60dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3.2. **from 标签**  主要用来发起 post 请求（如登录时输入账号密码时候）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ca38a55f51850bee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在网页中点击提交，Network 中 post 请求中的第四部分 From Data 如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-22538ebbc2c5f43d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n若是 HTTP 协议，密码便是明文：\"222\"，这就是为什么会有 HTTPS 出现\n\n3.3. **from 标签**与**a 标签**一样也有** target**\n\n## **4\\. input 标签和 button 标签**\n\n**input 要学的比较多，可以结合[MDN 文档](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)实例学习**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-fad8a6d86142a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**input type=\"button\"**和 **button** 的区别\n\n![](https://upload-images.jianshu.io/upload_images/7094266-583d5833841661dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n区别是  **input** 是空元素，无法内联其他标签，而  **button** 显然可以\n\n注：若 form 表单只有一个  **button 按钮**而无 **type** 属性，**button** 直接升级为  **submit**（跳转）\n\n## 5.table 标签\n\n较完整示例如图\n\n![](https://upload-images.jianshu.io/upload_images/7094266-410da64f04c3a907.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1\\. 很多人会忽略  **colgroup**  的使用，它可以用来给 table 的表列表加宽度等属性\n\n2\\. thead tbody tfoot 三个标签可以省略，加上的好处是给了每一部分定义，即使他们顺序打乱，浏览器也可以很好得形成原列表\n\n3\\. 上图中 table 的 border 有空隙可以用\n\n**border-collapse**  来去掉\n\n![](https://upload-images.jianshu.io/upload_images/7094266-b6ee3f969de3dc94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除\n","slug":"HTML常用的几个标签","published":1,"updated":"2020-03-28T17:35:41.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswym0008ws99bm6lkykf","content":"<p><strong>遇到新的标签属性等不会用可以用 JS BIN 尝试看看效果，就知道了</strong></p>\n<h1 id=\"常见标签详解\"><a href=\"#常见标签详解\" class=\"headerlink\" title=\"常见标签详解\"></a>常见标签详解</h1><h2 id=\"1-iframe-标签\"><a href=\"#1-iframe-标签\" class=\"headerlink\" title=\"1. iframe 标签\"></a><strong>1. iframe</strong> <strong>标签</strong></h2><p><strong>嵌套页面</strong></p>\n<p>1.1. <strong>iframe 标签</strong>的 <strong>frameborder</strong>  属性</p>\n<p><strong>iframe 标签</strong>自带边界 border，所以用这个属性可以去边界，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-1031b6812b8aaf57.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fa67255c8a244a71.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>1.2.<strong>iframe 标签</strong>的  <strong>src</strong> 属性：主要用来加链接</p>\n<p>1.3.<strong>iframe 标签</strong>的  <strong>name</strong> 属性</p>\n<p><strong>name 属性</strong>与<strong> a 标签</strong>一起使用有效，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d6e908d8da74ea14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"2-a-标签\"><a href=\"#2-a-标签\" class=\"headerlink\" title=\"2. a 标签\"></a><strong>2. a 标签</strong></h2><p><strong>跳转页面（HTTP GET 请求）</strong></p>\n<p><strong>target 属性</strong></p>\n<p><strong>target=”_blank _top _parent _self”</strong> 的区别，看意思就懂了分别是跳转 新空白页面；最首页（用于不止两个页面，跳到第一个页面）；父页面（不止两个页面，跳到当前页面父页面）；自身页面</p>\n<p>命令行下载 http 服务工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g http-server</span><br></pre></td></tr></table></figure>\n<p>这样就不用自己写服务了，然后用下面命令打开服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server -c -1</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-23d055b34597b717.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>打开服务器</p>\n<p>下面的路径都可以访问文件夹所在网页文件，复制其中一个在浏览器上访问即可</p>\n<p>如<a href=\"http://10.216.155.182:8080\" target=\"_blank\" rel=\"noopener\">http://10.216.155.182:8080</a></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5af1c1c11575c480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>只有  <strong>href=”#”</strong> 没有 <strong>get</strong> 请求</p>\n<p>此外  <strong>a 标签</strong>  的 <strong>href</strong>  有以下几种方法</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-787bd332399011ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"3-form-标签\"><a href=\"#3-form-标签\" class=\"headerlink\" title=\"3.form 标签\"></a>3.form 标签</h2><p><strong>跳转页面（HTTP POST 请求）</strong></p>\n<p>3.1. <strong>from 标签</strong> 需要加 <strong>（提交按钮）submit</strong> 来显示跳转，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-aaa0d33e641cd112.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e664c2791e3c60dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>3.2. <strong>from 标签</strong>  主要用来发起 post 请求（如登录时输入账号密码时候）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ca38a55f51850bee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在网页中点击提交，Network 中 post 请求中的第四部分 From Data 如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-22538ebbc2c5f43d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>若是 HTTP 协议，密码便是明文：”222”，这就是为什么会有 HTTPS 出现</p>\n<p>3.3. <strong>from 标签</strong>与<strong>a 标签</strong>一样也有<strong> target</strong></p>\n<h2 id=\"4-input-标签和-button-标签\"><a href=\"#4-input-标签和-button-标签\" class=\"headerlink\" title=\"4. input 标签和 button 标签\"></a><strong>4. input 标签和 button 标签</strong></h2><p><strong>input 要学的比较多，可以结合<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\" target=\"_blank\" rel=\"noopener\">MDN 文档</a>实例学习</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fad8a6d86142a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>input type=”button”</strong>和 <strong>button</strong> 的区别</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-583d5833841661dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>区别是  <strong>input</strong> 是空元素，无法内联其他标签，而  <strong>button</strong> 显然可以</p>\n<p>注：若 form 表单只有一个  <strong>button 按钮</strong>而无 <strong>type</strong> 属性，<strong>button</strong> 直接升级为  <strong>submit</strong>（跳转）</p>\n<h2 id=\"5-table-标签\"><a href=\"#5-table-标签\" class=\"headerlink\" title=\"5.table 标签\"></a>5.table 标签</h2><p>较完整示例如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-410da64f04c3a907.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>1. 很多人会忽略  <strong>colgroup</strong>  的使用，它可以用来给 table 的表列表加宽度等属性</p>\n<p>2. thead tbody tfoot 三个标签可以省略，加上的好处是给了每一部分定义，即使他们顺序打乱，浏览器也可以很好得形成原列表</p>\n<p>3. 上图中 table 的 border 有空隙可以用</p>\n<p><strong>border-collapse</strong>  来去掉</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-b6ee3f969de3dc94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>遇到新的标签属性等不会用可以用 JS BIN 尝试看看效果，就知道了</strong></p>\n<h1 id=\"常见标签详解\"><a href=\"#常见标签详解\" class=\"headerlink\" title=\"常见标签详解\"></a>常见标签详解</h1><h2 id=\"1-iframe-标签\"><a href=\"#1-iframe-标签\" class=\"headerlink\" title=\"1. iframe 标签\"></a><strong>1. iframe</strong> <strong>标签</strong></h2><p><strong>嵌套页面</strong></p>\n<p>1.1. <strong>iframe 标签</strong>的 <strong>frameborder</strong>  属性</p>\n<p><strong>iframe 标签</strong>自带边界 border，所以用这个属性可以去边界，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-1031b6812b8aaf57.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fa67255c8a244a71.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>1.2.<strong>iframe 标签</strong>的  <strong>src</strong> 属性：主要用来加链接</p>\n<p>1.3.<strong>iframe 标签</strong>的  <strong>name</strong> 属性</p>\n<p><strong>name 属性</strong>与<strong> a 标签</strong>一起使用有效，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d6e908d8da74ea14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"2-a-标签\"><a href=\"#2-a-标签\" class=\"headerlink\" title=\"2. a 标签\"></a><strong>2. a 标签</strong></h2><p><strong>跳转页面（HTTP GET 请求）</strong></p>\n<p><strong>target 属性</strong></p>\n<p><strong>target=”_blank _top _parent _self”</strong> 的区别，看意思就懂了分别是跳转 新空白页面；最首页（用于不止两个页面，跳到第一个页面）；父页面（不止两个页面，跳到当前页面父页面）；自身页面</p>\n<p>命令行下载 http 服务工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g http-server</span><br></pre></td></tr></table></figure>\n<p>这样就不用自己写服务了，然后用下面命令打开服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server -c -1</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-23d055b34597b717.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>打开服务器</p>\n<p>下面的路径都可以访问文件夹所在网页文件，复制其中一个在浏览器上访问即可</p>\n<p>如<a href=\"http://10.216.155.182:8080\" target=\"_blank\" rel=\"noopener\">http://10.216.155.182:8080</a></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5af1c1c11575c480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>只有  <strong>href=”#”</strong> 没有 <strong>get</strong> 请求</p>\n<p>此外  <strong>a 标签</strong>  的 <strong>href</strong>  有以下几种方法</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-787bd332399011ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"3-form-标签\"><a href=\"#3-form-标签\" class=\"headerlink\" title=\"3.form 标签\"></a>3.form 标签</h2><p><strong>跳转页面（HTTP POST 请求）</strong></p>\n<p>3.1. <strong>from 标签</strong> 需要加 <strong>（提交按钮）submit</strong> 来显示跳转，如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-aaa0d33e641cd112.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e664c2791e3c60dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>3.2. <strong>from 标签</strong>  主要用来发起 post 请求（如登录时输入账号密码时候）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ca38a55f51850bee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在网页中点击提交，Network 中 post 请求中的第四部分 From Data 如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-22538ebbc2c5f43d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>若是 HTTP 协议，密码便是明文：”222”，这就是为什么会有 HTTPS 出现</p>\n<p>3.3. <strong>from 标签</strong>与<strong>a 标签</strong>一样也有<strong> target</strong></p>\n<h2 id=\"4-input-标签和-button-标签\"><a href=\"#4-input-标签和-button-标签\" class=\"headerlink\" title=\"4. input 标签和 button 标签\"></a><strong>4. input 标签和 button 标签</strong></h2><p><strong>input 要学的比较多，可以结合<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\" target=\"_blank\" rel=\"noopener\">MDN 文档</a>实例学习</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fad8a6d86142a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>input type=”button”</strong>和 <strong>button</strong> 的区别</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-583d5833841661dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>区别是  <strong>input</strong> 是空元素，无法内联其他标签，而  <strong>button</strong> 显然可以</p>\n<p>注：若 form 表单只有一个  <strong>button 按钮</strong>而无 <strong>type</strong> 属性，<strong>button</strong> 直接升级为  <strong>submit</strong>（跳转）</p>\n<h2 id=\"5-table-标签\"><a href=\"#5-table-标签\" class=\"headerlink\" title=\"5.table 标签\"></a>5.table 标签</h2><p>较完整示例如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-410da64f04c3a907.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>1. 很多人会忽略  <strong>colgroup</strong>  的使用，它可以用来给 table 的表列表加宽度等属性</p>\n<p>2. thead tbody tfoot 三个标签可以省略，加上的好处是给了每一部分定义，即使他们顺序打乱，浏览器也可以很好得形成原列表</p>\n<p>3. 上图中 table 的 border 有空隙可以用</p>\n<p><strong>border-collapse</strong>  来去掉</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-b6ee3f969de3dc94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除</p>\n"},{"title":"HTTP 学习之 Cookie","date":"2018-09-16T10:43:31.000Z","_content":"\n## Cookie：\n\n今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识\n`HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。`\n\n我们知道，服务器和客户端（浏览器）之间通过 HTTP 发送请求和响应来交流。\n但是 HTTP 是[无状态协议](https://en.wikipedia.org/wiki/Stateless_protocol)：这样做当然能够减少服务器负担，服务器不必记录每一次请求和响应的状态，但这严重阻碍了[交互式 Web 应用程序](https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F \"交互式Web应用程序\")的实现。\n\n**所以就有了 Cookie 技术：在请求和响应的报文中写入 Cookie 信息来控制客户端状态。**\n\n- 服务器通过 Set-Cookie 响应头设置 Cookie\n- 浏览器得到 Cookie 之后，每次请求都要带上 Cookie\n- 服务器发现并读取 Cookie 就知道对应客户端的状态信息\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n**通过 HTTP 协议和 Cookie 技术的协同作用，服务器与客户端之间就可以既快速（HTTP 无状态）又可控（Cookie 有状态）得请求和响应并交互了。\n当然，由于 Cookie 的安全性等问题，有了 Session（服务器的一小块内存）本文不涉及**\n\n## 在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 [API 详情](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value)\n\n```\nresponse.setHeader('Set-Cookie',`sign_in_email = ${email}`)\n```\n\n(这是我写的关于登录注册 demo 里登录请求成功的服务端响应 Cookie 内容部分，完整的代码有兴趣可以看我 [github](https://github.com/Adashuai5/node-demo/tree/master/cookie-demo)，有关 node.js 搭建简单的服务器的内容可以看我相关博客)\n\n如图当 1@ada.com 用户发送登录请求成功，服务器返回响应的响应头（Response Headers）内出现 Set - Cookie ![](https://upload-images.jianshu.io/upload_images/7094266-fdff2ea48f36c28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)其他页面（只要是同源域名）都将带上 Cookie 信息（这里我们并没有设置其他内容）![](https://upload-images.jianshu.io/upload_images/7094266-341585400a01ecf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n设置多个 Cookies\n\n```\nresponse.setHeader('Set-Cookie', [`sign_in_email = ${email}`, 'language=javascript']);\n```\n\n在开发者工具里的 Application 界面里有 Cookies 我们可以随意设置其 cookie ![](http://upload-images.jianshu.io/upload_images/7094266-637c2da4867f4daf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Set-Cookie 字段还可以附加 Cookie 的属性 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)\n\n![常用属性](https://upload-images.jianshu.io/upload_images/7094266-479fc61fdf79ed54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**多个属性之间用 ; 连接，下面代码添加了 Secure 和 HttpOnly 属性**\n\n```\nresponse.setHeader('Set-Cookie',`sign_in_email = ${email};Secure;HttpOnly`)\n```\n\n**可以通过设置 Set-Cookie 的 Max-Age 属性 和 Expires 属性**\n以 node.js 为例\n\n```\nresponse.setHeader('Set-Cookie',' Max-Age=1000; Expires=Sun, 16 Sep 2018 10:05:35 GMT')\n```\n\n上面代码设置了响应头在 1000 秒后 cookie 失效，同时指定了 Expires 和 Max-Age，那么 Max-Age 的值将优先生效\n\n关闭 session（会话）即可删除内存 Cookie；上述过期时间达到则会删除硬盘 Cookie，因此可以通过设置过期时间删除 Cookie\n我们还可以通过手动清除浏览器 Cookie 及缓存删除 cookie\n\n**相关内容可以参考\n[Cookie 的属性](http://javascript.ruanyifeng.com/bom/cookie.html#toc4)\n[HTTP Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)\n[Cookie-wikipedia](https://zh.wikipedia.org/wiki/Cookie)\n同时这也是本文参考内容，另外还参考了 《图解 HTTP》相关章节**\n\n---\n\n本文仅供个人学习使用\n","source":"_posts/HTTP-学习之-Cookie.md","raw":"---\ntitle: HTTP 学习之 Cookie\ndate: 2018-09-16 18:43:31\ntags: HTTP\n---\n\n## Cookie：\n\n今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识\n`HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。`\n\n我们知道，服务器和客户端（浏览器）之间通过 HTTP 发送请求和响应来交流。\n但是 HTTP 是[无状态协议](https://en.wikipedia.org/wiki/Stateless_protocol)：这样做当然能够减少服务器负担，服务器不必记录每一次请求和响应的状态，但这严重阻碍了[交互式 Web 应用程序](https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F \"交互式Web应用程序\")的实现。\n\n**所以就有了 Cookie 技术：在请求和响应的报文中写入 Cookie 信息来控制客户端状态。**\n\n- 服务器通过 Set-Cookie 响应头设置 Cookie\n- 浏览器得到 Cookie 之后，每次请求都要带上 Cookie\n- 服务器发现并读取 Cookie 就知道对应客户端的状态信息\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n**通过 HTTP 协议和 Cookie 技术的协同作用，服务器与客户端之间就可以既快速（HTTP 无状态）又可控（Cookie 有状态）得请求和响应并交互了。\n当然，由于 Cookie 的安全性等问题，有了 Session（服务器的一小块内存）本文不涉及**\n\n## 在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 [API 详情](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value)\n\n```\nresponse.setHeader('Set-Cookie',`sign_in_email = ${email}`)\n```\n\n(这是我写的关于登录注册 demo 里登录请求成功的服务端响应 Cookie 内容部分，完整的代码有兴趣可以看我 [github](https://github.com/Adashuai5/node-demo/tree/master/cookie-demo)，有关 node.js 搭建简单的服务器的内容可以看我相关博客)\n\n如图当 1@ada.com 用户发送登录请求成功，服务器返回响应的响应头（Response Headers）内出现 Set - Cookie ![](https://upload-images.jianshu.io/upload_images/7094266-fdff2ea48f36c28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)其他页面（只要是同源域名）都将带上 Cookie 信息（这里我们并没有设置其他内容）![](https://upload-images.jianshu.io/upload_images/7094266-341585400a01ecf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n设置多个 Cookies\n\n```\nresponse.setHeader('Set-Cookie', [`sign_in_email = ${email}`, 'language=javascript']);\n```\n\n在开发者工具里的 Application 界面里有 Cookies 我们可以随意设置其 cookie ![](http://upload-images.jianshu.io/upload_images/7094266-637c2da4867f4daf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Set-Cookie 字段还可以附加 Cookie 的属性 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)\n\n![常用属性](https://upload-images.jianshu.io/upload_images/7094266-479fc61fdf79ed54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**多个属性之间用 ; 连接，下面代码添加了 Secure 和 HttpOnly 属性**\n\n```\nresponse.setHeader('Set-Cookie',`sign_in_email = ${email};Secure;HttpOnly`)\n```\n\n**可以通过设置 Set-Cookie 的 Max-Age 属性 和 Expires 属性**\n以 node.js 为例\n\n```\nresponse.setHeader('Set-Cookie',' Max-Age=1000; Expires=Sun, 16 Sep 2018 10:05:35 GMT')\n```\n\n上面代码设置了响应头在 1000 秒后 cookie 失效，同时指定了 Expires 和 Max-Age，那么 Max-Age 的值将优先生效\n\n关闭 session（会话）即可删除内存 Cookie；上述过期时间达到则会删除硬盘 Cookie，因此可以通过设置过期时间删除 Cookie\n我们还可以通过手动清除浏览器 Cookie 及缓存删除 cookie\n\n**相关内容可以参考\n[Cookie 的属性](http://javascript.ruanyifeng.com/bom/cookie.html#toc4)\n[HTTP Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)\n[Cookie-wikipedia](https://zh.wikipedia.org/wiki/Cookie)\n同时这也是本文参考内容，另外还参考了 《图解 HTTP》相关章节**\n\n---\n\n本文仅供个人学习使用\n","slug":"HTTP-学习之-Cookie","published":1,"updated":"2020-03-28T17:36:04.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyn0009ws99snftixoh","content":"<h2 id=\"Cookie：\"><a href=\"#Cookie：\" class=\"headerlink\" title=\"Cookie：\"></a>Cookie：</h2><p>今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识<br><code>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</code></p>\n<p>我们知道，服务器和客户端（浏览器）之间通过 HTTP 发送请求和响应来交流。<br>但是 HTTP 是<a href=\"https://en.wikipedia.org/wiki/Stateless_protocol\" target=\"_blank\" rel=\"noopener\">无状态协议</a>：这样做当然能够减少服务器负担，服务器不必记录每一次请求和响应的状态，但这严重阻碍了<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F\" title=\"交互式Web应用程序\" target=\"_blank\" rel=\"noopener\">交互式 Web 应用程序</a>的实现。</p>\n<p><strong>所以就有了 Cookie 技术：在请求和响应的报文中写入 Cookie 信息来控制客户端状态。</strong></p>\n<ul>\n<li>服务器通过 Set-Cookie 响应头设置 Cookie</li>\n<li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li>\n<li>服务器发现并读取 Cookie 就知道对应客户端的状态信息</li>\n</ul>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><strong>通过 HTTP 协议和 Cookie 技术的协同作用，服务器与客户端之间就可以既快速（HTTP 无状态）又可控（Cookie 有状态）得请求和响应并交互了。<br>当然，由于 Cookie 的安全性等问题，有了 Session（服务器的一小块内存）本文不涉及</strong></p>\n<h2 id=\"在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情\"><a href=\"#在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情\" class=\"headerlink\" title=\"在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 API 详情\"></a>在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value\" target=\"_blank\" rel=\"noopener\">API 详情</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;`)</span><br></pre></td></tr></table></figure>\n<p>(这是我写的关于登录注册 demo 里登录请求成功的服务端响应 Cookie 内容部分，完整的代码有兴趣可以看我 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/cookie-demo\">github</a>，有关 node.js 搭建简单的服务器的内容可以看我相关博客)</p>\n<p>如图当 <a href=\"mailto:1@ada.com\" target=\"_blank\" rel=\"noopener\">1@ada.com</a> 用户发送登录请求成功，服务器返回响应的响应头（Response Headers）内出现 Set - Cookie <img src=\"https://upload-images.jianshu.io/upload_images/7094266-fdff2ea48f36c28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">其他页面（只要是同源域名）都将带上 Cookie 信息（这里我们并没有设置其他内容）<img src=\"https://upload-images.jianshu.io/upload_images/7094266-341585400a01ecf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>设置多个 Cookies</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;, [`sign_in_email = $&#123;email&#125;`, &apos;language=javascript&apos;]);</span><br></pre></td></tr></table></figure>\n<p>在开发者工具里的 Application 界面里有 Cookies 我们可以随意设置其 cookie <img src=\"http://upload-images.jianshu.io/upload_images/7094266-637c2da4867f4daf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"Set-Cookie-字段还可以附加-Cookie-的属性-MDN\"><a href=\"#Set-Cookie-字段还可以附加-Cookie-的属性-MDN\" class=\"headerlink\" title=\"Set-Cookie 字段还可以附加 Cookie 的属性 MDN\"></a>Set-Cookie 字段还可以附加 Cookie 的属性 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie\" target=\"_blank\" rel=\"noopener\">MDN</a></h2><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-479fc61fdf79ed54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"常用属性\"><br><strong>多个属性之间用 ; 连接，下面代码添加了 Secure 和 HttpOnly 属性</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;;Secure;HttpOnly`)</span><br></pre></td></tr></table></figure>\n<p><strong>可以通过设置 Set-Cookie 的 Max-Age 属性 和 Expires 属性</strong><br>以 node.js 为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;,&apos; Max-Age=1000; Expires=Sun, 16 Sep 2018 10:05:35 GMT&apos;)</span><br></pre></td></tr></table></figure>\n<p>上面代码设置了响应头在 1000 秒后 cookie 失效，同时指定了 Expires 和 Max-Age，那么 Max-Age 的值将优先生效</p>\n<p>关闭 session（会话）即可删除内存 Cookie；上述过期时间达到则会删除硬盘 Cookie，因此可以通过设置过期时间删除 Cookie<br>我们还可以通过手动清除浏览器 Cookie 及缓存删除 cookie</p>\n<p><strong>相关内容可以参考<br><a href=\"http://javascript.ruanyifeng.com/bom/cookie.html#toc4\" target=\"_blank\" rel=\"noopener\">Cookie 的属性</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">HTTP Cookie</a><br><a href=\"https://zh.wikipedia.org/wiki/Cookie\" target=\"_blank\" rel=\"noopener\">Cookie-wikipedia</a><br>同时这也是本文参考内容，另外还参考了 《图解 HTTP》相关章节</strong></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Cookie：\"><a href=\"#Cookie：\" class=\"headerlink\" title=\"Cookie：\"></a>Cookie：</h2><p>今天我们要说的当然不是甜品，而是在 HTTP 协议中使用到的 Cookie 知识<br><code>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</code></p>\n<p>我们知道，服务器和客户端（浏览器）之间通过 HTTP 发送请求和响应来交流。<br>但是 HTTP 是<a href=\"https://en.wikipedia.org/wiki/Stateless_protocol\" target=\"_blank\" rel=\"noopener\">无状态协议</a>：这样做当然能够减少服务器负担，服务器不必记录每一次请求和响应的状态，但这严重阻碍了<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F\" title=\"交互式Web应用程序\" target=\"_blank\" rel=\"noopener\">交互式 Web 应用程序</a>的实现。</p>\n<p><strong>所以就有了 Cookie 技术：在请求和响应的报文中写入 Cookie 信息来控制客户端状态。</strong></p>\n<ul>\n<li>服务器通过 Set-Cookie 响应头设置 Cookie</li>\n<li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li>\n<li>服务器发现并读取 Cookie 就知道对应客户端的状态信息</li>\n</ul>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><strong>通过 HTTP 协议和 Cookie 技术的协同作用，服务器与客户端之间就可以既快速（HTTP 无状态）又可控（Cookie 有状态）得请求和响应并交互了。<br>当然，由于 Cookie 的安全性等问题，有了 Session（服务器的一小块内存）本文不涉及</strong></p>\n<h2 id=\"在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情\"><a href=\"#在-node-js-服务端中设置响应头的-Set-Cookie（以用户的-email-为例）代码示例-API-详情\" class=\"headerlink\" title=\"在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 API 详情\"></a>在 node.js 服务端中设置响应头的 Set Cookie（以用户的 email 为例）代码示例 <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value\" target=\"_blank\" rel=\"noopener\">API 详情</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;`)</span><br></pre></td></tr></table></figure>\n<p>(这是我写的关于登录注册 demo 里登录请求成功的服务端响应 Cookie 内容部分，完整的代码有兴趣可以看我 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/cookie-demo\">github</a>，有关 node.js 搭建简单的服务器的内容可以看我相关博客)</p>\n<p>如图当 <a href=\"mailto:1@ada.com\" target=\"_blank\" rel=\"noopener\">1@ada.com</a> 用户发送登录请求成功，服务器返回响应的响应头（Response Headers）内出现 Set - Cookie <img src=\"https://upload-images.jianshu.io/upload_images/7094266-fdff2ea48f36c28e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">其他页面（只要是同源域名）都将带上 Cookie 信息（这里我们并没有设置其他内容）<img src=\"https://upload-images.jianshu.io/upload_images/7094266-341585400a01ecf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>设置多个 Cookies</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;, [`sign_in_email = $&#123;email&#125;`, &apos;language=javascript&apos;]);</span><br></pre></td></tr></table></figure>\n<p>在开发者工具里的 Application 界面里有 Cookies 我们可以随意设置其 cookie <img src=\"http://upload-images.jianshu.io/upload_images/7094266-637c2da4867f4daf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"Set-Cookie-字段还可以附加-Cookie-的属性-MDN\"><a href=\"#Set-Cookie-字段还可以附加-Cookie-的属性-MDN\" class=\"headerlink\" title=\"Set-Cookie 字段还可以附加 Cookie 的属性 MDN\"></a>Set-Cookie 字段还可以附加 Cookie 的属性 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie\" target=\"_blank\" rel=\"noopener\">MDN</a></h2><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-479fc61fdf79ed54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"常用属性\"><br><strong>多个属性之间用 ; 连接，下面代码添加了 Secure 和 HttpOnly 属性</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;,`sign_in_email = $&#123;email&#125;;Secure;HttpOnly`)</span><br></pre></td></tr></table></figure>\n<p><strong>可以通过设置 Set-Cookie 的 Max-Age 属性 和 Expires 属性</strong><br>以 node.js 为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&apos;Set-Cookie&apos;,&apos; Max-Age=1000; Expires=Sun, 16 Sep 2018 10:05:35 GMT&apos;)</span><br></pre></td></tr></table></figure>\n<p>上面代码设置了响应头在 1000 秒后 cookie 失效，同时指定了 Expires 和 Max-Age，那么 Max-Age 的值将优先生效</p>\n<p>关闭 session（会话）即可删除内存 Cookie；上述过期时间达到则会删除硬盘 Cookie，因此可以通过设置过期时间删除 Cookie<br>我们还可以通过手动清除浏览器 Cookie 及缓存删除 cookie</p>\n<p><strong>相关内容可以参考<br><a href=\"http://javascript.ruanyifeng.com/bom/cookie.html#toc4\" target=\"_blank\" rel=\"noopener\">Cookie 的属性</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">HTTP Cookie</a><br><a href=\"https://zh.wikipedia.org/wiki/Cookie\" target=\"_blank\" rel=\"noopener\">Cookie-wikipedia</a><br>同时这也是本文参考内容，另外还参考了 《图解 HTTP》相关章节</strong></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n"},{"title":"JavaScript 原型和原型链","date":"2018-07-11T16:51:42.000Z","_content":"\nJavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有 类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。\n\n---\n\n> 每个实例对象（ object ）都有一个私有属性（称之为 **proto** ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( **proto** ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。\n\n![](https://upload-images.jianshu.io/upload_images/7094266-2e79d6fbb9c205e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面是 [MDN 里有关原型链知识](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) 的摘录，什么意思？让我们来解释一下\n\n事实上 JavaScript 所有数据都可以以对象的形式表现：由于函数是对象，我们可以用构造函数的方法使得 Number、Boolean、String 变成对象。\n\n下面以 Number 为例 （其他类型也一样）\n\n可以用 var 基本类型 = new 对应基本类型的函数() 的方法创建一个新函数\n\nvar n = new Number() 创建一个 Number 函数，其是一个对象\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-62536de6cd21ab12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的 n 就是 Number 的实例对象，可以看到 n 里面有一个 **proto** 指向 Number 所指向的原型对象（也是 n 自己本身的原型对象），Number 为 n 的构造函数，它通过 prototype 指向自己的原型对象，而后又可以通过 constructor 指向回 Number 本身；\n\n而 Number 函数也有一个 **proto** 指向 Object 这个构造函数的原型对象，Object 通过 prototype 指向自己原型对象 ；\n\nObject 函数没有 **proto**，证明其已经到达最后的属性层，他的 **proto** 指向为 null。\n\n即\n\n![](https://upload-images.jianshu.io/upload_images/7094266-fc991a402727ca56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**以上一整个原型与原型层层相链接的过程即为原型链**\n\n其可以将公用属性存放在同一原型层中，实现继承、节省内存空间等。\n\n> 当您访问实例的属性时，JavaScript 首先会检查它们是否直接存在于该对象上，如果不存在，则会 [[Prototype]] 中查找。这意味着你在 prototype 中定义的所有内容都可以由所有实例有效共享，你甚至可以稍后更改部分 prototype，并在所有现有实例中显示更改（如果需要）。\n\n---\n\n通过以上例子我们可以得到下面两个“公式”\n\n**var 对象 = new 函数()**\n\n**对象.**proto** === 对象的构造函数.prototype**\n\n我们已经知道\n\n**var n = new Number()**\n\n**n.**proto** === Number.prototype //true**\n\n那么  **Number.**proto\\*\\*\\*\\* ？\n\nNumber 的构造函数是 Function，即 Number 是 Function 的实例\n\n即有  **Number.**proto** === Function.prototype**\n\n那么同理\n\n**var object = new Object()**\n\n**object.**proto** === Object.prototype**\n\n**Object.**proto** === Function.prototype**\n\n再进一步推断\n\n**var function = new Function()**\n\n**function.**proto** === Function.prototype**\n\n**Function.**proto** === Function.prototype**\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-b6a6447f260e8db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n参考及推荐：\n\n[继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n\n[Javascript 继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)\n\n[白话原型和原型链](https://juejin.im/post/599d69fc6fb9a0248f4a7b31)\n\n[JavaScript 深入之从原型到原型链 #2](https://github.com/mqyqingfeng/Blog/issues/2)\n\n[饥人谷课件-原型链和继承](http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html)\n","source":"_posts/JavaScript原型和原型链.md","raw":"---\ntitle: JavaScript 原型和原型链\ndate: 2018-07-12 00:51:42\ntags: JavaScript\n---\n\nJavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有 类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。\n\n---\n\n> 每个实例对象（ object ）都有一个私有属性（称之为 **proto** ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( **proto** ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。\n\n![](https://upload-images.jianshu.io/upload_images/7094266-2e79d6fbb9c205e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面是 [MDN 里有关原型链知识](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) 的摘录，什么意思？让我们来解释一下\n\n事实上 JavaScript 所有数据都可以以对象的形式表现：由于函数是对象，我们可以用构造函数的方法使得 Number、Boolean、String 变成对象。\n\n下面以 Number 为例 （其他类型也一样）\n\n可以用 var 基本类型 = new 对应基本类型的函数() 的方法创建一个新函数\n\nvar n = new Number() 创建一个 Number 函数，其是一个对象\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-62536de6cd21ab12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的 n 就是 Number 的实例对象，可以看到 n 里面有一个 **proto** 指向 Number 所指向的原型对象（也是 n 自己本身的原型对象），Number 为 n 的构造函数，它通过 prototype 指向自己的原型对象，而后又可以通过 constructor 指向回 Number 本身；\n\n而 Number 函数也有一个 **proto** 指向 Object 这个构造函数的原型对象，Object 通过 prototype 指向自己原型对象 ；\n\nObject 函数没有 **proto**，证明其已经到达最后的属性层，他的 **proto** 指向为 null。\n\n即\n\n![](https://upload-images.jianshu.io/upload_images/7094266-fc991a402727ca56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**以上一整个原型与原型层层相链接的过程即为原型链**\n\n其可以将公用属性存放在同一原型层中，实现继承、节省内存空间等。\n\n> 当您访问实例的属性时，JavaScript 首先会检查它们是否直接存在于该对象上，如果不存在，则会 [[Prototype]] 中查找。这意味着你在 prototype 中定义的所有内容都可以由所有实例有效共享，你甚至可以稍后更改部分 prototype，并在所有现有实例中显示更改（如果需要）。\n\n---\n\n通过以上例子我们可以得到下面两个“公式”\n\n**var 对象 = new 函数()**\n\n**对象.**proto** === 对象的构造函数.prototype**\n\n我们已经知道\n\n**var n = new Number()**\n\n**n.**proto** === Number.prototype //true**\n\n那么  **Number.**proto\\*\\*\\*\\* ？\n\nNumber 的构造函数是 Function，即 Number 是 Function 的实例\n\n即有  **Number.**proto** === Function.prototype**\n\n那么同理\n\n**var object = new Object()**\n\n**object.**proto** === Object.prototype**\n\n**Object.**proto** === Function.prototype**\n\n再进一步推断\n\n**var function = new Function()**\n\n**function.**proto** === Function.prototype**\n\n**Function.**proto** === Function.prototype**\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-b6a6447f260e8db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n参考及推荐：\n\n[继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n\n[Javascript 继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)\n\n[白话原型和原型链](https://juejin.im/post/599d69fc6fb9a0248f4a7b31)\n\n[JavaScript 深入之从原型到原型链 #2](https://github.com/mqyqingfeng/Blog/issues/2)\n\n[饥人谷课件-原型链和继承](http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html)\n","slug":"JavaScript原型和原型链","published":1,"updated":"2020-03-28T17:36:11.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyo000aws99flojxh27","content":"<p>JavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有 类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。</p>\n<hr>\n<blockquote>\n<p>每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-2e79d6fbb9c205e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>上面是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">MDN 里有关原型链知识</a> 的摘录，什么意思？让我们来解释一下</p>\n<p>事实上 JavaScript 所有数据都可以以对象的形式表现：由于函数是对象，我们可以用构造函数的方法使得 Number、Boolean、String 变成对象。</p>\n<p>下面以 Number 为例 （其他类型也一样）</p>\n<p>可以用 var 基本类型 = new 对应基本类型的函数() 的方法创建一个新函数</p>\n<p>var n = new Number() 创建一个 Number 函数，其是一个对象</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-62536de6cd21ab12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>这里的 n 就是 Number 的实例对象，可以看到 n 里面有一个 <strong>proto</strong> 指向 Number 所指向的原型对象（也是 n 自己本身的原型对象），Number 为 n 的构造函数，它通过 prototype 指向自己的原型对象，而后又可以通过 constructor 指向回 Number 本身；</p>\n<p>而 Number 函数也有一个 <strong>proto</strong> 指向 Object 这个构造函数的原型对象，Object 通过 prototype 指向自己原型对象 ；</p>\n<p>Object 函数没有 <strong>proto</strong>，证明其已经到达最后的属性层，他的 <strong>proto</strong> 指向为 null。</p>\n<p>即</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fc991a402727ca56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>以上一整个原型与原型层层相链接的过程即为原型链</strong></p>\n<p>其可以将公用属性存放在同一原型层中，实现继承、节省内存空间等。</p>\n<blockquote>\n<p>当您访问实例的属性时，JavaScript 首先会检查它们是否直接存在于该对象上，如果不存在，则会 [[Prototype]] 中查找。这意味着你在 prototype 中定义的所有内容都可以由所有实例有效共享，你甚至可以稍后更改部分 prototype，并在所有现有实例中显示更改（如果需要）。</p>\n</blockquote>\n<hr>\n<p>通过以上例子我们可以得到下面两个“公式”</p>\n<p><strong>var 对象 = new 函数()</strong></p>\n<p><strong>对象.</strong>proto<strong> === 对象的构造函数.prototype</strong></p>\n<p>我们已经知道</p>\n<p><strong>var n = new Number()</strong></p>\n<p><strong>n.</strong>proto<strong> === Number.prototype //true</strong></p>\n<p>那么  <strong>Number.</strong>proto**** ？</p>\n<p>Number 的构造函数是 Function，即 Number 是 Function 的实例</p>\n<p>即有  <strong>Number.</strong>proto<strong> === Function.prototype</strong></p>\n<p>那么同理</p>\n<p><strong>var object = new Object()</strong></p>\n<p><strong>object.</strong>proto<strong> === Object.prototype</strong></p>\n<p><strong>Object.</strong>proto<strong> === Function.prototype</strong></p>\n<p>再进一步推断</p>\n<p><strong>var function = new Function()</strong></p>\n<p><strong>function.</strong>proto<strong> === Function.prototype</strong></p>\n<p><strong>Function.</strong>proto<strong> === Function.prototype</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-b6a6447f260e8db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p>参考及推荐：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">继承与原型链</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\" target=\"_blank\" rel=\"noopener\">Javascript 继承机制的设计思想</a></p>\n<p><a href=\"https://juejin.im/post/599d69fc6fb9a0248f4a7b31\" target=\"_blank\" rel=\"noopener\">白话原型和原型链</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">JavaScript 深入之从原型到原型链 #2</a></p>\n<p><a href=\"http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html\" target=\"_blank\" rel=\"noopener\">饥人谷课件-原型链和继承</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有 类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。</p>\n<hr>\n<blockquote>\n<p>每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-2e79d6fbb9c205e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>上面是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">MDN 里有关原型链知识</a> 的摘录，什么意思？让我们来解释一下</p>\n<p>事实上 JavaScript 所有数据都可以以对象的形式表现：由于函数是对象，我们可以用构造函数的方法使得 Number、Boolean、String 变成对象。</p>\n<p>下面以 Number 为例 （其他类型也一样）</p>\n<p>可以用 var 基本类型 = new 对应基本类型的函数() 的方法创建一个新函数</p>\n<p>var n = new Number() 创建一个 Number 函数，其是一个对象</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-62536de6cd21ab12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>这里的 n 就是 Number 的实例对象，可以看到 n 里面有一个 <strong>proto</strong> 指向 Number 所指向的原型对象（也是 n 自己本身的原型对象），Number 为 n 的构造函数，它通过 prototype 指向自己的原型对象，而后又可以通过 constructor 指向回 Number 本身；</p>\n<p>而 Number 函数也有一个 <strong>proto</strong> 指向 Object 这个构造函数的原型对象，Object 通过 prototype 指向自己原型对象 ；</p>\n<p>Object 函数没有 <strong>proto</strong>，证明其已经到达最后的属性层，他的 <strong>proto</strong> 指向为 null。</p>\n<p>即</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fc991a402727ca56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>以上一整个原型与原型层层相链接的过程即为原型链</strong></p>\n<p>其可以将公用属性存放在同一原型层中，实现继承、节省内存空间等。</p>\n<blockquote>\n<p>当您访问实例的属性时，JavaScript 首先会检查它们是否直接存在于该对象上，如果不存在，则会 [[Prototype]] 中查找。这意味着你在 prototype 中定义的所有内容都可以由所有实例有效共享，你甚至可以稍后更改部分 prototype，并在所有现有实例中显示更改（如果需要）。</p>\n</blockquote>\n<hr>\n<p>通过以上例子我们可以得到下面两个“公式”</p>\n<p><strong>var 对象 = new 函数()</strong></p>\n<p><strong>对象.</strong>proto<strong> === 对象的构造函数.prototype</strong></p>\n<p>我们已经知道</p>\n<p><strong>var n = new Number()</strong></p>\n<p><strong>n.</strong>proto<strong> === Number.prototype //true</strong></p>\n<p>那么  <strong>Number.</strong>proto**** ？</p>\n<p>Number 的构造函数是 Function，即 Number 是 Function 的实例</p>\n<p>即有  <strong>Number.</strong>proto<strong> === Function.prototype</strong></p>\n<p>那么同理</p>\n<p><strong>var object = new Object()</strong></p>\n<p><strong>object.</strong>proto<strong> === Object.prototype</strong></p>\n<p><strong>Object.</strong>proto<strong> === Function.prototype</strong></p>\n<p>再进一步推断</p>\n<p><strong>var function = new Function()</strong></p>\n<p><strong>function.</strong>proto<strong> === Function.prototype</strong></p>\n<p><strong>Function.</strong>proto<strong> === Function.prototype</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-b6a6447f260e8db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p>参考及推荐：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">继承与原型链</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\" target=\"_blank\" rel=\"noopener\">Javascript 继承机制的设计思想</a></p>\n<p><a href=\"https://juejin.im/post/599d69fc6fb9a0248f4a7b31\" target=\"_blank\" rel=\"noopener\">白话原型和原型链</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">JavaScript 深入之从原型到原型链 #2</a></p>\n<p><a href=\"http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html\" target=\"_blank\" rel=\"noopener\">饥人谷课件-原型链和继承</a></p>\n"},{"title":"LeetCode 算法之旅","date":"2019-03-28T14:19:06.000Z","_content":"\n算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。\n于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。\n\n## [1\\. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n```\nvar twoSum = function (nums, target) {\n    let newArr = []\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) {\n                newArr.push(i, j)\n            }\n        }\n    }\n    return newArr\n}\n// 164 ms\n```\n\n## [26\\. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    for (var i = 0; i < nums.length; i++) {\n        if (nums[i] === nums[i + 1]) {\n            nums.splice(i, 1)\n            i--\n        }\n    }\n    return nums.length\n}\n// 376 ms\n```\n","source":"_posts/LeetCode-算法之旅.md","raw":"---\ntitle: LeetCode 算法之旅\ndate: 2019-03-28 22:19:06\ntags: 算法\n---\n\n算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。\n于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。\n\n## [1\\. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n```\nvar twoSum = function (nums, target) {\n    let newArr = []\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) {\n                newArr.push(i, j)\n            }\n        }\n    }\n    return newArr\n}\n// 164 ms\n```\n\n## [26\\. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    for (var i = 0; i < nums.length; i++) {\n        if (nums[i] === nums[i + 1]) {\n            nums.splice(i, 1)\n            i--\n        }\n    }\n    return nums.length\n}\n// 376 ms\n```\n","slug":"LeetCode-算法之旅","published":1,"updated":"2020-03-28T17:36:20.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyq000bws99v1m90kcu","content":"<p>算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。<br>于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。</p>\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">1. 两数之和</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var twoSum = function (nums, target) &#123;</span><br><span class=\"line\">    let newArr = []</span><br><span class=\"line\">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        for (let j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">            if (nums[i] + nums[j] === target) &#123;</span><br><span class=\"line\">                newArr.push(i, j)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newArr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 164 ms</span><br></pre></td></tr></table></figure>\n<h2 id=\"26-删除排序数组中的重复项\"><a href=\"#26-删除排序数组中的重复项\" class=\"headerlink\" title=\"26. 删除排序数组中的重复项\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">26. 删除排序数组中的重复项</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;number[]&#125; nums</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var removeDuplicates = function (nums) &#123;</span><br><span class=\"line\">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        if (nums[i] === nums[i + 1]) &#123;</span><br><span class=\"line\">            nums.splice(i, 1)</span><br><span class=\"line\">            i--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nums.length</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 376 ms</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>算法是每个程序员应该重视的技能之一，即使是对算法要求不那么高的前端。但是如果能够不时抽空练习，对逻辑与能力的提升一定会有极大帮助。<br>于是，作为前端新人的我，注册了大名鼎鼎的 LeetCode，开始练习之旅。本文记录每道题目的记录，便于不时查阅及更新。</p>\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">1. 两数之和</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var twoSum = function (nums, target) &#123;</span><br><span class=\"line\">    let newArr = []</span><br><span class=\"line\">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        for (let j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">            if (nums[i] + nums[j] === target) &#123;</span><br><span class=\"line\">                newArr.push(i, j)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newArr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 164 ms</span><br></pre></td></tr></table></figure>\n<h2 id=\"26-删除排序数组中的重复项\"><a href=\"#26-删除排序数组中的重复项\" class=\"headerlink\" title=\"26. 删除排序数组中的重复项\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">26. 删除排序数组中的重复项</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;number[]&#125; nums</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var removeDuplicates = function (nums) &#123;</span><br><span class=\"line\">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        if (nums[i] === nums[i + 1]) &#123;</span><br><span class=\"line\">            nums.splice(i, 1)</span><br><span class=\"line\">            i--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nums.length</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 376 ms</span><br></pre></td></tr></table></figure>\n"},{"title":"OOP 初探（给 MVC 添加类）","date":"2018-09-02T08:49:17.000Z","_content":"\n# 面向对象程序设计：Object-oriented programming(OOP)\n\n**命名空间：name space**\n什么是命名空间？我们来看看 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4) 的例子\n\n```\n// 全局命名空间\nvar MYAPP = MYAPP || {};\n```\n\n---\n\n**这里补充有关逻辑运算符的知识**\n逻辑运算符：且（&&）、或（||）\n**&& 运算符返回第一个 falsy 值（停止运算），若无 falsy 值，则返回最后一个 truthy 值**\n只有（0；NaN；null；undefined；空字符串(' ')）五个是 falsy 值，除此之外其他都是 truthy 值\n\n```\nconsole.log(1) && 0 // 1\n```\n\n注意这里 console.log(1) 是返回值是 undefined （falsy 值），因此直接返回打印结果 1\n而不是返回第二个 falsy 值 0\n\n```\n0 && console.log(n) // 0\n```\n\n注意这里不会报错说 Uncaught ReferenceError: n is not defined\n因为 0 已经是 falsy 值所以直接返回，运算停止后面代码不再执行\n\n## **|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值**\n\n因此上面代码等价于\n\n```\n// 首先检查MYAPP是否已经被定义\nvar MYAPP\n// 是的话，那么使用现有的MYAPP全局对象\nif(MYAPP){\n  MYAPP = MYAPP;\n// 创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象\n}else{\n  MYAPP = {};\n}\n```\n\n然后可以基于 MYAPP 这一 name 的空间来放置所有与 MYAPP 相关的子命名\n\n```\n// 子命名空间\nMYAPP.event = {};\nMYAPP.commonMethod = {}\n```\n\n**_在 JavaScript 中，命名空间只是另一个包含 方法，属性，对象 的对象_**\n我们常见的文件夹就类似一个命名空间\n\n---\n\n**构造函数：constructor（类：class）**\nJavaScript 基于原型，没有类的概念；但是我们可以定义一个类\n下面代码就是一个新的类 Person\n\n```\nfunction Person() { }\n// 或\nvar Person = function(){ }\n```\n\nJavaScript 中类的本质是函数，只是它有两个特点：\n**1.函数体内部使用了 this 关键字，代表了所要生成的对象实例。 2.生成对象的时候，必须使用 new 命令\n这两个特点就形成了所谓的构造函数**\n_为了与普通函数区别，构造函数名字的第一个字母通常大写，如这里的 Person_\n\n**对象（类的实例）**\n\n```\nfunction Person() { }\nvar person1 = new Person();\nvar person2 = new Person();\n```\n\n以 Person 为类（模版），person1 和 person2 是 Person 新的实例：person1、person2 可以调用函数 Person\n\n# 为什么会有面向对象编程？\n\n你写了一个 person1 ，又写了一个 person2 ，然后又写了一个 person3 。。。\n它们有很多重复的代码：这些代码结构一致（如我们之前的 [MVC 设计模式](https://zhuanlan.zhihu.com/p/42366912)），简直浪费内存（内存条那么贵）\n**于是就有了 Person 这个构造函数作为对象的模板：把所有相同结构的代码用一个函数封装起来\n可以让 person1 等只需要用 new 的方法调用这个 Person 传入参数来使用它的模版，person1 自身属性，再单独罗列即可**\n\n**下面以之前有关 MVC 的 [博客](https://zhuanlan.zhihu.com/p/42366912) 中的代码为例**\n原来代码\n\n```\n! function () {\n    // MVC 的 V\n    var view = document.querySelector('section.message')\n    //添加 M\n    var model = {\n        init: function () {\n            var APP_ID = '2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz'\n            var APP_KEY = 'iByF5Dy55tJodAoxC4cxwAwx'\n\n            AV.init({\n                appId: APP_ID,\n                appKey: APP_KEY\n            })\n        },\n        //获取所有数据\n        fetch: function () {\n            var query = new AV.Query('Message')\n            return query.find() //Promise 对象\n        },\n        //创建数据\n        save: function (name,content) {\n            var Message = AV.Object.extend('Message');\n            var message = new Message();\n            return message.save({ //Promise 对象\n                name: name,\n                content: content\n            })\n        }\n    }\n    // MVC 的 C\n    var controller = {\n        view: null,\n        model: null,\n        messageList: null,\n        init: function (view, model) {\n            this.view = view\n            this.model = model\n            this.messageList = view.querySelector('#messageList')\n            this.form = view.querySelector('form')\n            this.model.init()\n            this.loadMessages()\n            this.bindEvents()\n        },\n        loadMessages: function () {\n            this.model.fetch().then((messages) => {\n                let array = messages.map((item) => item.attributes)\n                array.forEach((item) => {\n                    let li = document.createElement('li')\n                    li.innerText = `${item.name} : ${item.content}`\n                    this.messageList.appendChild(li)\n                })\n            })\n        },\n        bindEvents: function () {\n            this.form.addEventListener('submit', (e) => {\n                e.preventDefault()\n                this.saveMessage()\n            })\n        },\n        saveMessage: function () {\n            let myForm = this.form\n            let content = myForm.querySelector('input[name=content]').value\n            let name = myForm.querySelector('input[name=name]').value\n            this.model.save(name, content).then(function (object) {\n                let li = document.createElement('li')\n                li.innerText = `${object.attributes.name} : ${object.attributes.content}`\n                let messageList = document.querySelector('#messageList')\n                messageList.appendChild(li)\n                myForm.querySelector('input[name=content]').value = ''\n                console.log(object)\n            })\n        }\n    }\n    controller.init(view, model)\n}.call()\n```\n\n**把 M、V、C 三个模版单独分出**\nM 的模版\n\n```\n// Model 办事，我放心\n// 通过全局函数 window 引入 Model 便于所有 model 调用\n// 提供三个参数：Options、resourceName 和 object\nwindow.Model = function (Options) {\n    let resourceName = Options.resourceName\n    return {\n        init: function () {\n            var APP_ID = '2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz'\n            var APP_KEY = 'iByF5Dy55tJodAoxC4cxwAwx'\n\n            AV.init({\n                appId: APP_ID,\n                appKey: APP_KEY\n            })\n        },\n        fetch: function () {\n            var query = new AV.Query(resourceName)\n            return query.find()\n        },\n        //创建数据\n        save: function (object) {\n            var X = AV.Object.extend(resourceName)\n            var x = new X();\n            return x.save(object)\n        }\n    }\n}\n```\n\nV 就比较简单了，就一句话，但是封装后也可以调用以便减少代码\n\n```\nwindow.View = function(Selector){\n    return document.querySelector(Selector)\n}\n```\n\n这里 C 是有一定难点的，需要对 this 的概念有所理解\n\n```\nwindow.Controller = function (options) {\n    var init = options.init //这个 init 就是 controller 传进来的，记为 initB\n    // 4-21 return 一个 object\n    let object = {\n        view: null,\n        model: null,\n        init: function (view, model) { // 注意这里的 init 是 object 的属性,记为 initA\n            this.view = view\n            this.model = model\n            this.model.init()\n            // 3.initB.call(this)\n            init.call(this, view, model) // 这里的 init 当然是 initB，写成这样 init(view,model) 你就懂了\n            this.bindEvents.call(this)\n        },\n    }\n    // 把除 init 外的所有 options 的参数传给 object\n    // init 是公共参数，而其他实例独有的参数需要传进来\n    for (let key in options) {\n        if (key !== 'init') {\n            object[key] = options[key]\n        }\n    }\n    return object\n}\n```\n\n实例代码：现在可以直接调用 M、V、C 了，其他实例也是一样的\n\n```\n! function () {\n\t// MVC 的 V\n\t// 这里 window.View 的 window 可以省略，是默认的\n\tvar view = View('section.message')\n\t//添加 M\n\tvar model = Model({\n\t\tresourceName: 'Message'\n\t})\n\t// MVC 的 C\n\t// 1.controller === object\n\tvar controller = Controller({\n\t\tinit: function () {\n\t\t\tthis.messageList = view.querySelector('#messageList')\n\t\t\tthis.form = view.querySelector('form')\n\t\t\tthis.loadMessages()\n\t\t\t// 这里的 this 是 object，但是 object 没有上面参数\n\t\t\t// 所以才要 for...in...遍历一下，让 object 有这些 controller 独有的参数\n\t\t},\n\t\tloadMessages: function () {\n\t\t\tthis.model.fetch().then((messages) => {\n\t\t\t\tlet array = messages.map((item) => item.attributes)\n\t\t\t\tarray.forEach((item) => {\n\t\t\t\t\tlet li = document.createElement('li')\n\t\t\t\t\tli.innerText = `${item.name} : ${item.content}`\n\t\t\t\t\tthis.messageList.appendChild(li)\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\t\tbindEvents: function () {\n\t\t\tthis.form.addEventListener('submit', (e) => {\n\t\t\t\te.preventDefault()\n\t\t\t\tthis.saveMessage()\n\t\t\t})\n\t\t},\n\t\tsaveMessage: function () {\n\t\t\tlet myForm = this.form\n\t\t\tlet content = myForm.querySelector('input[name=content]').value\n\t\t\tlet name = myForm.querySelector('input[name=name]').value\n\t\t\tthis.model.save({\n\t\t\t\tname: name,\n\t\t\t\tcontent: content\n\t\t\t}).then(function (object) {\n\t\t\t\tlet li = document.createElement('li')\n\t\t\t\tli.innerText = `${object.attributes.name} : ${object.attributes.content}`\n\t\t\t\tlet messageList = document.querySelector('#messageList')\n\t\t\t\tmessageList.appendChild(li)\n\t\t\t\tmyForm.querySelector('input[name=content]').value = ''\n\t\t\t\tconsole.log(object)\n\t\t\t})\n\t\t}\n\t})\n\t// 2.controller.init(view, model)\n\tcontroller.init(view, model)\n}.call()\n```\n\n# 关于 this\n\n我们以 C：controller 部分封装的代码的 this 为例：所有内容已经在代码中注明，我们来总结一下\n\n```\n1.controller === object\n2.controller.init(view, model)\n  写成 call 的形式：controller.init.call(controller, view, model)\n // MDN 里 this 文档告诉我们：this 是 call 的第一个参数\n  显然 controller.init 里面的 this 当然是 controller\n  那它还是 object：即 controller.init 里面的 this 就是 object\n  相当于 object.init 里面的 this 是 object\n3.initB.call(this)\n  initB 里面的 this === call 后面的this\n  call 后面 this === 第二条里的 this\n  第二条里面的 this === object\n  => initB 里面的 this 就是 object\n```\n\n想了解更多有关 this 知识，移步 [搞懂这些 你就理解 this 了](https://www.jianshu.com/p/bd9d8bd248ab)\n\n---\n\n本文仅供个人学习使用\n\n**未完待续。。**\n","source":"_posts/OOP-初探（给-MVC-添加类）.md","raw":"---\ntitle: OOP 初探（给 MVC 添加类）\ndate: 2018-09-02 16:49:17\ntags: 设计模式\n---\n\n# 面向对象程序设计：Object-oriented programming(OOP)\n\n**命名空间：name space**\n什么是命名空间？我们来看看 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4) 的例子\n\n```\n// 全局命名空间\nvar MYAPP = MYAPP || {};\n```\n\n---\n\n**这里补充有关逻辑运算符的知识**\n逻辑运算符：且（&&）、或（||）\n**&& 运算符返回第一个 falsy 值（停止运算），若无 falsy 值，则返回最后一个 truthy 值**\n只有（0；NaN；null；undefined；空字符串(' ')）五个是 falsy 值，除此之外其他都是 truthy 值\n\n```\nconsole.log(1) && 0 // 1\n```\n\n注意这里 console.log(1) 是返回值是 undefined （falsy 值），因此直接返回打印结果 1\n而不是返回第二个 falsy 值 0\n\n```\n0 && console.log(n) // 0\n```\n\n注意这里不会报错说 Uncaught ReferenceError: n is not defined\n因为 0 已经是 falsy 值所以直接返回，运算停止后面代码不再执行\n\n## **|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值**\n\n因此上面代码等价于\n\n```\n// 首先检查MYAPP是否已经被定义\nvar MYAPP\n// 是的话，那么使用现有的MYAPP全局对象\nif(MYAPP){\n  MYAPP = MYAPP;\n// 创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象\n}else{\n  MYAPP = {};\n}\n```\n\n然后可以基于 MYAPP 这一 name 的空间来放置所有与 MYAPP 相关的子命名\n\n```\n// 子命名空间\nMYAPP.event = {};\nMYAPP.commonMethod = {}\n```\n\n**_在 JavaScript 中，命名空间只是另一个包含 方法，属性，对象 的对象_**\n我们常见的文件夹就类似一个命名空间\n\n---\n\n**构造函数：constructor（类：class）**\nJavaScript 基于原型，没有类的概念；但是我们可以定义一个类\n下面代码就是一个新的类 Person\n\n```\nfunction Person() { }\n// 或\nvar Person = function(){ }\n```\n\nJavaScript 中类的本质是函数，只是它有两个特点：\n**1.函数体内部使用了 this 关键字，代表了所要生成的对象实例。 2.生成对象的时候，必须使用 new 命令\n这两个特点就形成了所谓的构造函数**\n_为了与普通函数区别，构造函数名字的第一个字母通常大写，如这里的 Person_\n\n**对象（类的实例）**\n\n```\nfunction Person() { }\nvar person1 = new Person();\nvar person2 = new Person();\n```\n\n以 Person 为类（模版），person1 和 person2 是 Person 新的实例：person1、person2 可以调用函数 Person\n\n# 为什么会有面向对象编程？\n\n你写了一个 person1 ，又写了一个 person2 ，然后又写了一个 person3 。。。\n它们有很多重复的代码：这些代码结构一致（如我们之前的 [MVC 设计模式](https://zhuanlan.zhihu.com/p/42366912)），简直浪费内存（内存条那么贵）\n**于是就有了 Person 这个构造函数作为对象的模板：把所有相同结构的代码用一个函数封装起来\n可以让 person1 等只需要用 new 的方法调用这个 Person 传入参数来使用它的模版，person1 自身属性，再单独罗列即可**\n\n**下面以之前有关 MVC 的 [博客](https://zhuanlan.zhihu.com/p/42366912) 中的代码为例**\n原来代码\n\n```\n! function () {\n    // MVC 的 V\n    var view = document.querySelector('section.message')\n    //添加 M\n    var model = {\n        init: function () {\n            var APP_ID = '2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz'\n            var APP_KEY = 'iByF5Dy55tJodAoxC4cxwAwx'\n\n            AV.init({\n                appId: APP_ID,\n                appKey: APP_KEY\n            })\n        },\n        //获取所有数据\n        fetch: function () {\n            var query = new AV.Query('Message')\n            return query.find() //Promise 对象\n        },\n        //创建数据\n        save: function (name,content) {\n            var Message = AV.Object.extend('Message');\n            var message = new Message();\n            return message.save({ //Promise 对象\n                name: name,\n                content: content\n            })\n        }\n    }\n    // MVC 的 C\n    var controller = {\n        view: null,\n        model: null,\n        messageList: null,\n        init: function (view, model) {\n            this.view = view\n            this.model = model\n            this.messageList = view.querySelector('#messageList')\n            this.form = view.querySelector('form')\n            this.model.init()\n            this.loadMessages()\n            this.bindEvents()\n        },\n        loadMessages: function () {\n            this.model.fetch().then((messages) => {\n                let array = messages.map((item) => item.attributes)\n                array.forEach((item) => {\n                    let li = document.createElement('li')\n                    li.innerText = `${item.name} : ${item.content}`\n                    this.messageList.appendChild(li)\n                })\n            })\n        },\n        bindEvents: function () {\n            this.form.addEventListener('submit', (e) => {\n                e.preventDefault()\n                this.saveMessage()\n            })\n        },\n        saveMessage: function () {\n            let myForm = this.form\n            let content = myForm.querySelector('input[name=content]').value\n            let name = myForm.querySelector('input[name=name]').value\n            this.model.save(name, content).then(function (object) {\n                let li = document.createElement('li')\n                li.innerText = `${object.attributes.name} : ${object.attributes.content}`\n                let messageList = document.querySelector('#messageList')\n                messageList.appendChild(li)\n                myForm.querySelector('input[name=content]').value = ''\n                console.log(object)\n            })\n        }\n    }\n    controller.init(view, model)\n}.call()\n```\n\n**把 M、V、C 三个模版单独分出**\nM 的模版\n\n```\n// Model 办事，我放心\n// 通过全局函数 window 引入 Model 便于所有 model 调用\n// 提供三个参数：Options、resourceName 和 object\nwindow.Model = function (Options) {\n    let resourceName = Options.resourceName\n    return {\n        init: function () {\n            var APP_ID = '2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz'\n            var APP_KEY = 'iByF5Dy55tJodAoxC4cxwAwx'\n\n            AV.init({\n                appId: APP_ID,\n                appKey: APP_KEY\n            })\n        },\n        fetch: function () {\n            var query = new AV.Query(resourceName)\n            return query.find()\n        },\n        //创建数据\n        save: function (object) {\n            var X = AV.Object.extend(resourceName)\n            var x = new X();\n            return x.save(object)\n        }\n    }\n}\n```\n\nV 就比较简单了，就一句话，但是封装后也可以调用以便减少代码\n\n```\nwindow.View = function(Selector){\n    return document.querySelector(Selector)\n}\n```\n\n这里 C 是有一定难点的，需要对 this 的概念有所理解\n\n```\nwindow.Controller = function (options) {\n    var init = options.init //这个 init 就是 controller 传进来的，记为 initB\n    // 4-21 return 一个 object\n    let object = {\n        view: null,\n        model: null,\n        init: function (view, model) { // 注意这里的 init 是 object 的属性,记为 initA\n            this.view = view\n            this.model = model\n            this.model.init()\n            // 3.initB.call(this)\n            init.call(this, view, model) // 这里的 init 当然是 initB，写成这样 init(view,model) 你就懂了\n            this.bindEvents.call(this)\n        },\n    }\n    // 把除 init 外的所有 options 的参数传给 object\n    // init 是公共参数，而其他实例独有的参数需要传进来\n    for (let key in options) {\n        if (key !== 'init') {\n            object[key] = options[key]\n        }\n    }\n    return object\n}\n```\n\n实例代码：现在可以直接调用 M、V、C 了，其他实例也是一样的\n\n```\n! function () {\n\t// MVC 的 V\n\t// 这里 window.View 的 window 可以省略，是默认的\n\tvar view = View('section.message')\n\t//添加 M\n\tvar model = Model({\n\t\tresourceName: 'Message'\n\t})\n\t// MVC 的 C\n\t// 1.controller === object\n\tvar controller = Controller({\n\t\tinit: function () {\n\t\t\tthis.messageList = view.querySelector('#messageList')\n\t\t\tthis.form = view.querySelector('form')\n\t\t\tthis.loadMessages()\n\t\t\t// 这里的 this 是 object，但是 object 没有上面参数\n\t\t\t// 所以才要 for...in...遍历一下，让 object 有这些 controller 独有的参数\n\t\t},\n\t\tloadMessages: function () {\n\t\t\tthis.model.fetch().then((messages) => {\n\t\t\t\tlet array = messages.map((item) => item.attributes)\n\t\t\t\tarray.forEach((item) => {\n\t\t\t\t\tlet li = document.createElement('li')\n\t\t\t\t\tli.innerText = `${item.name} : ${item.content}`\n\t\t\t\t\tthis.messageList.appendChild(li)\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\t\tbindEvents: function () {\n\t\t\tthis.form.addEventListener('submit', (e) => {\n\t\t\t\te.preventDefault()\n\t\t\t\tthis.saveMessage()\n\t\t\t})\n\t\t},\n\t\tsaveMessage: function () {\n\t\t\tlet myForm = this.form\n\t\t\tlet content = myForm.querySelector('input[name=content]').value\n\t\t\tlet name = myForm.querySelector('input[name=name]').value\n\t\t\tthis.model.save({\n\t\t\t\tname: name,\n\t\t\t\tcontent: content\n\t\t\t}).then(function (object) {\n\t\t\t\tlet li = document.createElement('li')\n\t\t\t\tli.innerText = `${object.attributes.name} : ${object.attributes.content}`\n\t\t\t\tlet messageList = document.querySelector('#messageList')\n\t\t\t\tmessageList.appendChild(li)\n\t\t\t\tmyForm.querySelector('input[name=content]').value = ''\n\t\t\t\tconsole.log(object)\n\t\t\t})\n\t\t}\n\t})\n\t// 2.controller.init(view, model)\n\tcontroller.init(view, model)\n}.call()\n```\n\n# 关于 this\n\n我们以 C：controller 部分封装的代码的 this 为例：所有内容已经在代码中注明，我们来总结一下\n\n```\n1.controller === object\n2.controller.init(view, model)\n  写成 call 的形式：controller.init.call(controller, view, model)\n // MDN 里 this 文档告诉我们：this 是 call 的第一个参数\n  显然 controller.init 里面的 this 当然是 controller\n  那它还是 object：即 controller.init 里面的 this 就是 object\n  相当于 object.init 里面的 this 是 object\n3.initB.call(this)\n  initB 里面的 this === call 后面的this\n  call 后面 this === 第二条里的 this\n  第二条里面的 this === object\n  => initB 里面的 this 就是 object\n```\n\n想了解更多有关 this 知识，移步 [搞懂这些 你就理解 this 了](https://www.jianshu.com/p/bd9d8bd248ab)\n\n---\n\n本文仅供个人学习使用\n\n**未完待续。。**\n","slug":"OOP-初探（给-MVC-添加类）","published":1,"updated":"2020-03-28T17:36:51.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswys000cws996joe0apy","content":"<h1 id=\"面向对象程序设计：Object-oriented-programming-OOP\"><a href=\"#面向对象程序设计：Object-oriented-programming-OOP\" class=\"headerlink\" title=\"面向对象程序设计：Object-oriented programming(OOP)\"></a>面向对象程序设计：Object-oriented programming(OOP)</h1><p><strong>命名空间：name space</strong><br>什么是命名空间？我们来看看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\" target=\"_blank\" rel=\"noopener\">MDN</a> 的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局命名空间</span><br><span class=\"line\">var MYAPP = MYAPP || &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>这里补充有关逻辑运算符的知识</strong><br>逻辑运算符：且（&amp;&amp;）、或（||）<br><strong>&amp;&amp; 运算符返回第一个 falsy 值（停止运算），若无 falsy 值，则返回最后一个 truthy 值</strong><br>只有（0；NaN；null；undefined；空字符串(‘ ‘)）五个是 falsy 值，除此之外其他都是 truthy 值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1) &amp;&amp; 0 // 1</span><br></pre></td></tr></table></figure>\n<p>注意这里 console.log(1) 是返回值是 undefined （falsy 值），因此直接返回打印结果 1<br>而不是返回第二个 falsy 值 0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 &amp;&amp; console.log(n) // 0</span><br></pre></td></tr></table></figure>\n<p>注意这里不会报错说 Uncaught ReferenceError: n is not defined<br>因为 0 已经是 falsy 值所以直接返回，运算停止后面代码不再执行</p>\n<h2 id=\"运算符返回第一个-truthy-值（停止运算），若无-truthy-值，则返回最后一个-falsy-值\"><a href=\"#运算符返回第一个-truthy-值（停止运算），若无-truthy-值，则返回最后一个-falsy-值\" class=\"headerlink\" title=\"|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值\"></a><strong>|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值</strong></h2><p>因此上面代码等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先检查MYAPP是否已经被定义</span><br><span class=\"line\">var MYAPP</span><br><span class=\"line\">// 是的话，那么使用现有的MYAPP全局对象</span><br><span class=\"line\">if(MYAPP)&#123;</span><br><span class=\"line\">  MYAPP = MYAPP;</span><br><span class=\"line\">// 创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">  MYAPP = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后可以基于 MYAPP 这一 name 的空间来放置所有与 MYAPP 相关的子命名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子命名空间</span><br><span class=\"line\">MYAPP.event = &#123;&#125;;</span><br><span class=\"line\">MYAPP.commonMethod = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>在 JavaScript 中，命名空间只是另一个包含 方法，属性，对象 的对象</em></strong><br>我们常见的文件夹就类似一个命名空间</p>\n<hr>\n<p><strong>构造函数：constructor（类：class）</strong><br>JavaScript 基于原型，没有类的概念；但是我们可以定义一个类<br>下面代码就是一个新的类 Person</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123; &#125;</span><br><span class=\"line\">// 或</span><br><span class=\"line\">var Person = function()&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>JavaScript 中类的本质是函数，只是它有两个特点：<br><strong>1.函数体内部使用了 this 关键字，代表了所要生成的对象实例。 2.生成对象的时候，必须使用 new 命令<br>这两个特点就形成了所谓的构造函数</strong><br><em>为了与普通函数区别，构造函数名字的第一个字母通常大写，如这里的 Person</em></p>\n<p><strong>对象（类的实例）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123; &#125;</span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">var person2 = new Person();</span><br></pre></td></tr></table></figure>\n<p>以 Person 为类（模版），person1 和 person2 是 Person 新的实例：person1、person2 可以调用函数 Person</p>\n<h1 id=\"为什么会有面向对象编程？\"><a href=\"#为什么会有面向对象编程？\" class=\"headerlink\" title=\"为什么会有面向对象编程？\"></a>为什么会有面向对象编程？</h1><p>你写了一个 person1 ，又写了一个 person2 ，然后又写了一个 person3 。。。<br>它们有很多重复的代码：这些代码结构一致（如我们之前的 <a href=\"https://zhuanlan.zhihu.com/p/42366912\" target=\"_blank\" rel=\"noopener\">MVC 设计模式</a>），简直浪费内存（内存条那么贵）<br><strong>于是就有了 Person 这个构造函数作为对象的模板：把所有相同结构的代码用一个函数封装起来<br>可以让 person1 等只需要用 new 的方法调用这个 Person 传入参数来使用它的模版，person1 自身属性，再单独罗列即可</strong></p>\n<p><strong>下面以之前有关 MVC 的 <a href=\"https://zhuanlan.zhihu.com/p/42366912\" target=\"_blank\" rel=\"noopener\">博客</a> 中的代码为例</strong><br>原来代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    // MVC 的 V</span><br><span class=\"line\">    var view = document.querySelector(&apos;section.message&apos;)</span><br><span class=\"line\">    //添加 M</span><br><span class=\"line\">    var model = &#123;</span><br><span class=\"line\">        init: function () &#123;</span><br><span class=\"line\">            var APP_ID = &apos;2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz&apos;</span><br><span class=\"line\">            var APP_KEY = &apos;iByF5Dy55tJodAoxC4cxwAwx&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">            AV.init(&#123;</span><br><span class=\"line\">                appId: APP_ID,</span><br><span class=\"line\">                appKey: APP_KEY</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //获取所有数据</span><br><span class=\"line\">        fetch: function () &#123;</span><br><span class=\"line\">            var query = new AV.Query(&apos;Message&apos;)</span><br><span class=\"line\">            return query.find() //Promise 对象</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //创建数据</span><br><span class=\"line\">        save: function (name,content) &#123;</span><br><span class=\"line\">            var Message = AV.Object.extend(&apos;Message&apos;);</span><br><span class=\"line\">            var message = new Message();</span><br><span class=\"line\">            return message.save(&#123; //Promise 对象</span><br><span class=\"line\">                name: name,</span><br><span class=\"line\">                content: content</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // MVC 的 C</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        model: null,</span><br><span class=\"line\">        messageList: null,</span><br><span class=\"line\">        init: function (view, model) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.model = model</span><br><span class=\"line\">            this.messageList = view.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">            this.form = view.querySelector(&apos;form&apos;)</span><br><span class=\"line\">            this.model.init()</span><br><span class=\"line\">            this.loadMessages()</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        loadMessages: function () &#123;</span><br><span class=\"line\">            this.model.fetch().then((messages) =&gt; &#123;</span><br><span class=\"line\">                let array = messages.map((item) =&gt; item.attributes)</span><br><span class=\"line\">                array.forEach((item) =&gt; &#123;</span><br><span class=\"line\">                    let li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">                    li.innerText = `$&#123;item.name&#125; : $&#123;item.content&#125;`</span><br><span class=\"line\">                    this.messageList.appendChild(li)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            this.form.addEventListener(&apos;submit&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">                e.preventDefault()</span><br><span class=\"line\">                this.saveMessage()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        saveMessage: function () &#123;</span><br><span class=\"line\">            let myForm = this.form</span><br><span class=\"line\">            let content = myForm.querySelector(&apos;input[name=content]&apos;).value</span><br><span class=\"line\">            let name = myForm.querySelector(&apos;input[name=name]&apos;).value</span><br><span class=\"line\">            this.model.save(name, content).then(function (object) &#123;</span><br><span class=\"line\">                let li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">                li.innerText = `$&#123;object.attributes.name&#125; : $&#123;object.attributes.content&#125;`</span><br><span class=\"line\">                let messageList = document.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">                messageList.appendChild(li)</span><br><span class=\"line\">                myForm.querySelector(&apos;input[name=content]&apos;).value = &apos;&apos;</span><br><span class=\"line\">                console.log(object)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view, model)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p><strong>把 M、V、C 三个模版单独分出</strong><br>M 的模版</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Model 办事，我放心</span><br><span class=\"line\">// 通过全局函数 window 引入 Model 便于所有 model 调用</span><br><span class=\"line\">// 提供三个参数：Options、resourceName 和 object</span><br><span class=\"line\">window.Model = function (Options) &#123;</span><br><span class=\"line\">    let resourceName = Options.resourceName</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        init: function () &#123;</span><br><span class=\"line\">            var APP_ID = &apos;2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz&apos;</span><br><span class=\"line\">            var APP_KEY = &apos;iByF5Dy55tJodAoxC4cxwAwx&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">            AV.init(&#123;</span><br><span class=\"line\">                appId: APP_ID,</span><br><span class=\"line\">                appKey: APP_KEY</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fetch: function () &#123;</span><br><span class=\"line\">            var query = new AV.Query(resourceName)</span><br><span class=\"line\">            return query.find()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //创建数据</span><br><span class=\"line\">        save: function (object) &#123;</span><br><span class=\"line\">            var X = AV.Object.extend(resourceName)</span><br><span class=\"line\">            var x = new X();</span><br><span class=\"line\">            return x.save(object)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>V 就比较简单了，就一句话，但是封装后也可以调用以便减少代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.View = function(Selector)&#123;</span><br><span class=\"line\">    return document.querySelector(Selector)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里 C 是有一定难点的，需要对 this 的概念有所理解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.Controller = function (options) &#123;</span><br><span class=\"line\">    var init = options.init //这个 init 就是 controller 传进来的，记为 initB</span><br><span class=\"line\">    // 4-21 return 一个 object</span><br><span class=\"line\">    let object = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        model: null,</span><br><span class=\"line\">        init: function (view, model) &#123; // 注意这里的 init 是 object 的属性,记为 initA</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.model = model</span><br><span class=\"line\">            this.model.init()</span><br><span class=\"line\">            // 3.initB.call(this)</span><br><span class=\"line\">            init.call(this, view, model) // 这里的 init 当然是 initB，写成这样 init(view,model) 你就懂了</span><br><span class=\"line\">            this.bindEvents.call(this)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 把除 init 外的所有 options 的参数传给 object</span><br><span class=\"line\">    // init 是公共参数，而其他实例独有的参数需要传进来</span><br><span class=\"line\">    for (let key in options) &#123;</span><br><span class=\"line\">        if (key !== &apos;init&apos;) &#123;</span><br><span class=\"line\">            object[key] = options[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例代码：现在可以直接调用 M、V、C 了，其他实例也是一样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">\t// MVC 的 V</span><br><span class=\"line\">\t// 这里 window.View 的 window 可以省略，是默认的</span><br><span class=\"line\">\tvar view = View(&apos;section.message&apos;)</span><br><span class=\"line\">\t//添加 M</span><br><span class=\"line\">\tvar model = Model(&#123;</span><br><span class=\"line\">\t\tresourceName: &apos;Message&apos;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t// MVC 的 C</span><br><span class=\"line\">\t// 1.controller === object</span><br><span class=\"line\">\tvar controller = Controller(&#123;</span><br><span class=\"line\">\t\tinit: function () &#123;</span><br><span class=\"line\">\t\t\tthis.messageList = view.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">\t\t\tthis.form = view.querySelector(&apos;form&apos;)</span><br><span class=\"line\">\t\t\tthis.loadMessages()</span><br><span class=\"line\">\t\t\t// 这里的 this 是 object，但是 object 没有上面参数</span><br><span class=\"line\">\t\t\t// 所以才要 for...in...遍历一下，让 object 有这些 controller 独有的参数</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tloadMessages: function () &#123;</span><br><span class=\"line\">\t\t\tthis.model.fetch().then((messages) =&gt; &#123;</span><br><span class=\"line\">\t\t\t\tlet array = messages.map((item) =&gt; item.attributes)</span><br><span class=\"line\">\t\t\t\tarray.forEach((item) =&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\tlet li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">\t\t\t\t\tli.innerText = `$&#123;item.name&#125; : $&#123;item.content&#125;`</span><br><span class=\"line\">\t\t\t\t\tthis.messageList.appendChild(li)</span><br><span class=\"line\">\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tbindEvents: function () &#123;</span><br><span class=\"line\">\t\t\tthis.form.addEventListener(&apos;submit&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">\t\t\t\te.preventDefault()</span><br><span class=\"line\">\t\t\t\tthis.saveMessage()</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tsaveMessage: function () &#123;</span><br><span class=\"line\">\t\t\tlet myForm = this.form</span><br><span class=\"line\">\t\t\tlet content = myForm.querySelector(&apos;input[name=content]&apos;).value</span><br><span class=\"line\">\t\t\tlet name = myForm.querySelector(&apos;input[name=name]&apos;).value</span><br><span class=\"line\">\t\t\tthis.model.save(&#123;</span><br><span class=\"line\">\t\t\t\tname: name,</span><br><span class=\"line\">\t\t\t\tcontent: content</span><br><span class=\"line\">\t\t\t&#125;).then(function (object) &#123;</span><br><span class=\"line\">\t\t\t\tlet li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">\t\t\t\tli.innerText = `$&#123;object.attributes.name&#125; : $&#123;object.attributes.content&#125;`</span><br><span class=\"line\">\t\t\t\tlet messageList = document.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">\t\t\t\tmessageList.appendChild(li)</span><br><span class=\"line\">\t\t\t\tmyForm.querySelector(&apos;input[name=content]&apos;).value = &apos;&apos;</span><br><span class=\"line\">\t\t\t\tconsole.log(object)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t// 2.controller.init(view, model)</span><br><span class=\"line\">\tcontroller.init(view, model)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<h1 id=\"关于-this\"><a href=\"#关于-this\" class=\"headerlink\" title=\"关于 this\"></a>关于 this</h1><p>我们以 C：controller 部分封装的代码的 this 为例：所有内容已经在代码中注明，我们来总结一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.controller === object</span><br><span class=\"line\">2.controller.init(view, model)</span><br><span class=\"line\">  写成 call 的形式：controller.init.call(controller, view, model)</span><br><span class=\"line\"> // MDN 里 this 文档告诉我们：this 是 call 的第一个参数</span><br><span class=\"line\">  显然 controller.init 里面的 this 当然是 controller</span><br><span class=\"line\">  那它还是 object：即 controller.init 里面的 this 就是 object</span><br><span class=\"line\">  相当于 object.init 里面的 this 是 object</span><br><span class=\"line\">3.initB.call(this)</span><br><span class=\"line\">  initB 里面的 this === call 后面的this</span><br><span class=\"line\">  call 后面 this === 第二条里的 this</span><br><span class=\"line\">  第二条里面的 this === object</span><br><span class=\"line\">  =&gt; initB 里面的 this 就是 object</span><br></pre></td></tr></table></figure>\n<p>想了解更多有关 this 知识，移步 <a href=\"https://www.jianshu.com/p/bd9d8bd248ab\" target=\"_blank\" rel=\"noopener\">搞懂这些 你就理解 this 了</a></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n<p><strong>未完待续。。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"面向对象程序设计：Object-oriented-programming-OOP\"><a href=\"#面向对象程序设计：Object-oriented-programming-OOP\" class=\"headerlink\" title=\"面向对象程序设计：Object-oriented programming(OOP)\"></a>面向对象程序设计：Object-oriented programming(OOP)</h1><p><strong>命名空间：name space</strong><br>什么是命名空间？我们来看看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\" target=\"_blank\" rel=\"noopener\">MDN</a> 的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 全局命名空间</span><br><span class=\"line\">var MYAPP = MYAPP || &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>这里补充有关逻辑运算符的知识</strong><br>逻辑运算符：且（&amp;&amp;）、或（||）<br><strong>&amp;&amp; 运算符返回第一个 falsy 值（停止运算），若无 falsy 值，则返回最后一个 truthy 值</strong><br>只有（0；NaN；null；undefined；空字符串(‘ ‘)）五个是 falsy 值，除此之外其他都是 truthy 值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1) &amp;&amp; 0 // 1</span><br></pre></td></tr></table></figure>\n<p>注意这里 console.log(1) 是返回值是 undefined （falsy 值），因此直接返回打印结果 1<br>而不是返回第二个 falsy 值 0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 &amp;&amp; console.log(n) // 0</span><br></pre></td></tr></table></figure>\n<p>注意这里不会报错说 Uncaught ReferenceError: n is not defined<br>因为 0 已经是 falsy 值所以直接返回，运算停止后面代码不再执行</p>\n<h2 id=\"运算符返回第一个-truthy-值（停止运算），若无-truthy-值，则返回最后一个-falsy-值\"><a href=\"#运算符返回第一个-truthy-值（停止运算），若无-truthy-值，则返回最后一个-falsy-值\" class=\"headerlink\" title=\"|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值\"></a><strong>|| 运算符返回第一个 truthy 值（停止运算），若无 truthy 值，则返回最后一个 falsy 值</strong></h2><p>因此上面代码等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先检查MYAPP是否已经被定义</span><br><span class=\"line\">var MYAPP</span><br><span class=\"line\">// 是的话，那么使用现有的MYAPP全局对象</span><br><span class=\"line\">if(MYAPP)&#123;</span><br><span class=\"line\">  MYAPP = MYAPP;</span><br><span class=\"line\">// 创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">  MYAPP = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后可以基于 MYAPP 这一 name 的空间来放置所有与 MYAPP 相关的子命名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子命名空间</span><br><span class=\"line\">MYAPP.event = &#123;&#125;;</span><br><span class=\"line\">MYAPP.commonMethod = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>在 JavaScript 中，命名空间只是另一个包含 方法，属性，对象 的对象</em></strong><br>我们常见的文件夹就类似一个命名空间</p>\n<hr>\n<p><strong>构造函数：constructor（类：class）</strong><br>JavaScript 基于原型，没有类的概念；但是我们可以定义一个类<br>下面代码就是一个新的类 Person</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123; &#125;</span><br><span class=\"line\">// 或</span><br><span class=\"line\">var Person = function()&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>JavaScript 中类的本质是函数，只是它有两个特点：<br><strong>1.函数体内部使用了 this 关键字，代表了所要生成的对象实例。 2.生成对象的时候，必须使用 new 命令<br>这两个特点就形成了所谓的构造函数</strong><br><em>为了与普通函数区别，构造函数名字的第一个字母通常大写，如这里的 Person</em></p>\n<p><strong>对象（类的实例）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123; &#125;</span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">var person2 = new Person();</span><br></pre></td></tr></table></figure>\n<p>以 Person 为类（模版），person1 和 person2 是 Person 新的实例：person1、person2 可以调用函数 Person</p>\n<h1 id=\"为什么会有面向对象编程？\"><a href=\"#为什么会有面向对象编程？\" class=\"headerlink\" title=\"为什么会有面向对象编程？\"></a>为什么会有面向对象编程？</h1><p>你写了一个 person1 ，又写了一个 person2 ，然后又写了一个 person3 。。。<br>它们有很多重复的代码：这些代码结构一致（如我们之前的 <a href=\"https://zhuanlan.zhihu.com/p/42366912\" target=\"_blank\" rel=\"noopener\">MVC 设计模式</a>），简直浪费内存（内存条那么贵）<br><strong>于是就有了 Person 这个构造函数作为对象的模板：把所有相同结构的代码用一个函数封装起来<br>可以让 person1 等只需要用 new 的方法调用这个 Person 传入参数来使用它的模版，person1 自身属性，再单独罗列即可</strong></p>\n<p><strong>下面以之前有关 MVC 的 <a href=\"https://zhuanlan.zhihu.com/p/42366912\" target=\"_blank\" rel=\"noopener\">博客</a> 中的代码为例</strong><br>原来代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    // MVC 的 V</span><br><span class=\"line\">    var view = document.querySelector(&apos;section.message&apos;)</span><br><span class=\"line\">    //添加 M</span><br><span class=\"line\">    var model = &#123;</span><br><span class=\"line\">        init: function () &#123;</span><br><span class=\"line\">            var APP_ID = &apos;2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz&apos;</span><br><span class=\"line\">            var APP_KEY = &apos;iByF5Dy55tJodAoxC4cxwAwx&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">            AV.init(&#123;</span><br><span class=\"line\">                appId: APP_ID,</span><br><span class=\"line\">                appKey: APP_KEY</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //获取所有数据</span><br><span class=\"line\">        fetch: function () &#123;</span><br><span class=\"line\">            var query = new AV.Query(&apos;Message&apos;)</span><br><span class=\"line\">            return query.find() //Promise 对象</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //创建数据</span><br><span class=\"line\">        save: function (name,content) &#123;</span><br><span class=\"line\">            var Message = AV.Object.extend(&apos;Message&apos;);</span><br><span class=\"line\">            var message = new Message();</span><br><span class=\"line\">            return message.save(&#123; //Promise 对象</span><br><span class=\"line\">                name: name,</span><br><span class=\"line\">                content: content</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // MVC 的 C</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        model: null,</span><br><span class=\"line\">        messageList: null,</span><br><span class=\"line\">        init: function (view, model) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.model = model</span><br><span class=\"line\">            this.messageList = view.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">            this.form = view.querySelector(&apos;form&apos;)</span><br><span class=\"line\">            this.model.init()</span><br><span class=\"line\">            this.loadMessages()</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        loadMessages: function () &#123;</span><br><span class=\"line\">            this.model.fetch().then((messages) =&gt; &#123;</span><br><span class=\"line\">                let array = messages.map((item) =&gt; item.attributes)</span><br><span class=\"line\">                array.forEach((item) =&gt; &#123;</span><br><span class=\"line\">                    let li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">                    li.innerText = `$&#123;item.name&#125; : $&#123;item.content&#125;`</span><br><span class=\"line\">                    this.messageList.appendChild(li)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            this.form.addEventListener(&apos;submit&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">                e.preventDefault()</span><br><span class=\"line\">                this.saveMessage()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        saveMessage: function () &#123;</span><br><span class=\"line\">            let myForm = this.form</span><br><span class=\"line\">            let content = myForm.querySelector(&apos;input[name=content]&apos;).value</span><br><span class=\"line\">            let name = myForm.querySelector(&apos;input[name=name]&apos;).value</span><br><span class=\"line\">            this.model.save(name, content).then(function (object) &#123;</span><br><span class=\"line\">                let li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">                li.innerText = `$&#123;object.attributes.name&#125; : $&#123;object.attributes.content&#125;`</span><br><span class=\"line\">                let messageList = document.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">                messageList.appendChild(li)</span><br><span class=\"line\">                myForm.querySelector(&apos;input[name=content]&apos;).value = &apos;&apos;</span><br><span class=\"line\">                console.log(object)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view, model)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p><strong>把 M、V、C 三个模版单独分出</strong><br>M 的模版</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Model 办事，我放心</span><br><span class=\"line\">// 通过全局函数 window 引入 Model 便于所有 model 调用</span><br><span class=\"line\">// 提供三个参数：Options、resourceName 和 object</span><br><span class=\"line\">window.Model = function (Options) &#123;</span><br><span class=\"line\">    let resourceName = Options.resourceName</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        init: function () &#123;</span><br><span class=\"line\">            var APP_ID = &apos;2zeITbbU6cgHT0mdBscQtmp0-gzGzoHsz&apos;</span><br><span class=\"line\">            var APP_KEY = &apos;iByF5Dy55tJodAoxC4cxwAwx&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">            AV.init(&#123;</span><br><span class=\"line\">                appId: APP_ID,</span><br><span class=\"line\">                appKey: APP_KEY</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fetch: function () &#123;</span><br><span class=\"line\">            var query = new AV.Query(resourceName)</span><br><span class=\"line\">            return query.find()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //创建数据</span><br><span class=\"line\">        save: function (object) &#123;</span><br><span class=\"line\">            var X = AV.Object.extend(resourceName)</span><br><span class=\"line\">            var x = new X();</span><br><span class=\"line\">            return x.save(object)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>V 就比较简单了，就一句话，但是封装后也可以调用以便减少代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.View = function(Selector)&#123;</span><br><span class=\"line\">    return document.querySelector(Selector)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里 C 是有一定难点的，需要对 this 的概念有所理解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.Controller = function (options) &#123;</span><br><span class=\"line\">    var init = options.init //这个 init 就是 controller 传进来的，记为 initB</span><br><span class=\"line\">    // 4-21 return 一个 object</span><br><span class=\"line\">    let object = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        model: null,</span><br><span class=\"line\">        init: function (view, model) &#123; // 注意这里的 init 是 object 的属性,记为 initA</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.model = model</span><br><span class=\"line\">            this.model.init()</span><br><span class=\"line\">            // 3.initB.call(this)</span><br><span class=\"line\">            init.call(this, view, model) // 这里的 init 当然是 initB，写成这样 init(view,model) 你就懂了</span><br><span class=\"line\">            this.bindEvents.call(this)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 把除 init 外的所有 options 的参数传给 object</span><br><span class=\"line\">    // init 是公共参数，而其他实例独有的参数需要传进来</span><br><span class=\"line\">    for (let key in options) &#123;</span><br><span class=\"line\">        if (key !== &apos;init&apos;) &#123;</span><br><span class=\"line\">            object[key] = options[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例代码：现在可以直接调用 M、V、C 了，其他实例也是一样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">\t// MVC 的 V</span><br><span class=\"line\">\t// 这里 window.View 的 window 可以省略，是默认的</span><br><span class=\"line\">\tvar view = View(&apos;section.message&apos;)</span><br><span class=\"line\">\t//添加 M</span><br><span class=\"line\">\tvar model = Model(&#123;</span><br><span class=\"line\">\t\tresourceName: &apos;Message&apos;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t// MVC 的 C</span><br><span class=\"line\">\t// 1.controller === object</span><br><span class=\"line\">\tvar controller = Controller(&#123;</span><br><span class=\"line\">\t\tinit: function () &#123;</span><br><span class=\"line\">\t\t\tthis.messageList = view.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">\t\t\tthis.form = view.querySelector(&apos;form&apos;)</span><br><span class=\"line\">\t\t\tthis.loadMessages()</span><br><span class=\"line\">\t\t\t// 这里的 this 是 object，但是 object 没有上面参数</span><br><span class=\"line\">\t\t\t// 所以才要 for...in...遍历一下，让 object 有这些 controller 独有的参数</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tloadMessages: function () &#123;</span><br><span class=\"line\">\t\t\tthis.model.fetch().then((messages) =&gt; &#123;</span><br><span class=\"line\">\t\t\t\tlet array = messages.map((item) =&gt; item.attributes)</span><br><span class=\"line\">\t\t\t\tarray.forEach((item) =&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\tlet li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">\t\t\t\t\tli.innerText = `$&#123;item.name&#125; : $&#123;item.content&#125;`</span><br><span class=\"line\">\t\t\t\t\tthis.messageList.appendChild(li)</span><br><span class=\"line\">\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tbindEvents: function () &#123;</span><br><span class=\"line\">\t\t\tthis.form.addEventListener(&apos;submit&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">\t\t\t\te.preventDefault()</span><br><span class=\"line\">\t\t\t\tthis.saveMessage()</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tsaveMessage: function () &#123;</span><br><span class=\"line\">\t\t\tlet myForm = this.form</span><br><span class=\"line\">\t\t\tlet content = myForm.querySelector(&apos;input[name=content]&apos;).value</span><br><span class=\"line\">\t\t\tlet name = myForm.querySelector(&apos;input[name=name]&apos;).value</span><br><span class=\"line\">\t\t\tthis.model.save(&#123;</span><br><span class=\"line\">\t\t\t\tname: name,</span><br><span class=\"line\">\t\t\t\tcontent: content</span><br><span class=\"line\">\t\t\t&#125;).then(function (object) &#123;</span><br><span class=\"line\">\t\t\t\tlet li = document.createElement(&apos;li&apos;)</span><br><span class=\"line\">\t\t\t\tli.innerText = `$&#123;object.attributes.name&#125; : $&#123;object.attributes.content&#125;`</span><br><span class=\"line\">\t\t\t\tlet messageList = document.querySelector(&apos;#messageList&apos;)</span><br><span class=\"line\">\t\t\t\tmessageList.appendChild(li)</span><br><span class=\"line\">\t\t\t\tmyForm.querySelector(&apos;input[name=content]&apos;).value = &apos;&apos;</span><br><span class=\"line\">\t\t\t\tconsole.log(object)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t// 2.controller.init(view, model)</span><br><span class=\"line\">\tcontroller.init(view, model)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<h1 id=\"关于-this\"><a href=\"#关于-this\" class=\"headerlink\" title=\"关于 this\"></a>关于 this</h1><p>我们以 C：controller 部分封装的代码的 this 为例：所有内容已经在代码中注明，我们来总结一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.controller === object</span><br><span class=\"line\">2.controller.init(view, model)</span><br><span class=\"line\">  写成 call 的形式：controller.init.call(controller, view, model)</span><br><span class=\"line\"> // MDN 里 this 文档告诉我们：this 是 call 的第一个参数</span><br><span class=\"line\">  显然 controller.init 里面的 this 当然是 controller</span><br><span class=\"line\">  那它还是 object：即 controller.init 里面的 this 就是 object</span><br><span class=\"line\">  相当于 object.init 里面的 this 是 object</span><br><span class=\"line\">3.initB.call(this)</span><br><span class=\"line\">  initB 里面的 this === call 后面的this</span><br><span class=\"line\">  call 后面 this === 第二条里的 this</span><br><span class=\"line\">  第二条里面的 this === object</span><br><span class=\"line\">  =&gt; initB 里面的 this 就是 object</span><br></pre></td></tr></table></figure>\n<p>想了解更多有关 this 知识，移步 <a href=\"https://www.jianshu.com/p/bd9d8bd248ab\" target=\"_blank\" rel=\"noopener\">搞懂这些 你就理解 this 了</a></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n<p><strong>未完待续。。</strong></p>\n"},{"title":"MVC 初尝试之 V 和 C","date":"2018-08-18T08:51:10.000Z","_content":"\n# 什么是[MVC](http://www.ruanyifeng.com/blog/2007/11/mvc.html)![](https://upload-images.jianshu.io/upload_images/7094266-bd2a358032410034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n视图（View）：用户界面。\n控制器（Controller）：业务逻辑\n模型（Model）：数据保存\n![](https://upload-images.jianshu.io/upload_images/7094266-6f849f9b1d7762be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nView 传送指令到 Controller\nController 完成业务逻辑后，要求 Model 改变状态\nModel 将新的数据发送到 View，用户得到反馈\n\n# 那么怎么做呢\n\n**1.模块化你的 js 代码**\n将同一模块的 js 代码放在同一个文件夹里并正确命名，用立即执行函数[相关博客](https://www.jianshu.com/p/d880bacbc0e9)封装代码，防止出现全局变量\n\n```\n<!-- 模块化 -->\n    <script src=\"./js/init-swiper.js\"></script>\n    <script src=\"./js/auto-slide-up.js\"></script>\n    <script src=\"./js/sticky-topbar.js\"></script>\n    <script src=\"./js/smoothly-navigation.js\"></script>\n```\n\n**2.设置 V 和 C**\n\n2.1.首先简单区分出 V 和 C\n找到 js 模块对应的 html 模块，即是 view\nview 的作用是告诉 js 哪一部分是对应模块的 view\n以轮播模块为例\n\n```\n<!-- 这就是 view ，用户可以看到 -->\n<div id=\"mySlides\">\n    <!-- Slider main container -->\n    <div class=\"swiper-container\">\n        <!-- Additional required wrapper -->\n        <div class=\"swiper-wrapper\">\n            <!-- Slides -->\n            <img src=\"./img/works/nav-page.jpg\" class=\"swiper-slide\">\n            <img src=\"./img/works/canvas.jpg\" class=\"swiper-slide\">\n            <img src=\"./img/works/apple-style-slides.jpg\" class=\"swiper-slide\">\n        </div>\n        <!-- If we need pagination -->\n        <div class=\"swiper-pagination\"></div>\n    </div>\n    <!-- If we need navigation buttons -->\n    <div class=\"swiper-button-prev\"></div>\n    <div class=\"swiper-button-next\"></div>\n</div>\n```\n\n2.1.1.在 js 中声明一个 view 作为 js 模块的 view，如轮播模块的 view 为 #mySlides\n2.1.2.声明一个 controller 他是 view 的函数\n\n```\n!function(){\n    var view = document.querySelector('#mySlides')\n    var controller = function(view){\n        var mySwiper = new Swiper(view.querySelector('.swiper-container'), {\n            loop: true,\n            // If we need pagination\n            pagination: {\n                el: '.swiper-pagination',\n            },\n\n            // Navigation arrows\n            navigation: {\n                nextEl: '.swiper-button-next',\n                prevEl: '.swiper-button-prev',\n            }\n        })\n    }\n    controller(view)\n}.call()\n```\n\n2.2.再简化一下\n用另一个模块 topNavBar 举例（可以看到每个模块结构是一致的）\n\n```\n! function () {\n    var view = document.querySelector('#topNavBar')\n    //把 controller 变成对象\n    var controller = {\n        //把函数放到 init 里（init 即是初始化）\n        init: function (view) {\n            window.addEventListener('scroll', function (x) {\n                if (window.scrollY > 0) {\n                    topNavBar.classList.add('sticky')\n                } else {\n                    topNavBar.classList.remove('sticky')\n                }\n            })\n        }\n    }\n    //此时 controller(view) 就变成了 controller.init(view)\n    controller.init(view)\n}.call()\n```\n\n下面是关键\n\n```\n! function () {\n    var view = document.querySelector('#topNavBar')\n    var controller = {\n        //开始 controller 有个空的 view\n        view: null,\n        //有个初始化函数\n        init: function (view) {\n            //把 view 存到 controller 的 view 里\n            this.view = view\n            //下面代码 this.bindEvents.call(this)\n            this.bindEvents()\n        },\n        //绑定事件\n        bindEvents: function () {\n            //所以这里的 this 就是上面的 this\n            //上面的 this 就等于 controller.init(view)\n            //controller.init(view) 的 this 就是 controller\n            var view = this.view\n            window.addEventListener('scroll', function (x) {\n                if (window.scrollY > 0) {\n                    topNavBar.classList.add('sticky')\n                } else {\n                    topNavBar.classList.remove('sticky')\n                }\n            })\n        }\n    }\n    //下面代码等价于controller.init.call(controller,view) 即 this 就是controller\n    controller.init(view)\n}.call()\n```\n\ncontroller 有个 view，有个初始化函数，并可以绑定事件\n下面优化绑定事件函数内部代码，让其只起绑定事件的作用\n\n```\nwindow.addEventListener('scroll', function (x) {\n    if (window.scrollY > 0) {\n        topNavBar.classList.add('sticky')\n    } else {\n        topNavBar.classList.remove('sticky')\n    }\n})\n```\n\n由于 addEventListener 里面的 this 代表用户触发的元素\n但是我们希望 this 与原来一致\n**解决方法一：用 bind()**\n\n```\nwindow.addEventListener('scroll', function (x) {\n    if (window.scrollY > 0) {\n        topNavBar.classList.add('sticky')\n    } else {\n        topNavBar.classList.remove('sticky')\n    }\n}).bind(this)\n```\n\n**解决方法二：**\n用箭头函数，由于箭头函数没有 this ，所以当我们在其内部使用 this 默认就是外部的 this。\n**可以说箭头函数内外 this 不变，我们的目的就是让函数内外 this 不变**\n\n然后将 addClass 和 remove Class 事件也用各自的函数分隔开，同样用 this 和 view 串起来\n完整代码\n\n```\n! function () {\n    var view = document.querySelector('#topNavBar')\n    var controller = {\n        view: null,\n        init: function (view) {\n            this.view = view\n            this.bindEvents()\n        },\n        bindEvents: function () {\n            var view = this.view\n            window.addEventListener('scroll', (x) =>{\n                if (window.scrollY > 0) {\n                    this.active()\n                } else {\n                    this.deactive()\n                }\n            })\n        },\n        active:function(){\n            this.view.classList.add('sticky')\n        },\n        deactive:function(){\n            this.view.classList.remove('sticky')\n        }\n    }\n    controller.init(view)\n}.call()\n```\n\n轮播完整代码\n\n```\n! function () {\n    var view = document.querySelector('#mySlides')\n    var controller = {\n        view: null,\n        swiper: null,\n        swiperOptions: {\n            loop: true,\n            pagination: {\n                el: '.swiper-pagination',\n            },\n            navigation: {\n                nextEl: '.swiper-button-next',\n                prevEl: '.swiper-button-prev',\n            }\n        },\n        init: function (view) {\n            this.view = view\n            this.initSwiper()\n        },\n        initSwiper: function () {\n            this.swiper = new Swiper(\n                this.view.querySelector('.swiper-container'),\n                this.swiperOptions\n            )\n        },\n    }\n    controller.init(view)\n}.call()\n```\n\nsmoothly-navigation.js 模块代码\n\n```\n! function () {\n    var view = document.querySelector('nav.menu')\n    var controller = {\n        view: null,\n        aTags: null,\n        init: function (view) {\n            this.view = view\n            this.initAnimation()\n            this.bindEvents()\n        },\n        initAnimation: function () {\n            function animate(time) {\n                requestAnimationFrame(animate);\n                TWEEN.update(time);\n            }\n            requestAnimationFrame(animate);\n        },\n        scrollToElement: function (element) {\n            let top = element.offsetTop\n            let currentTop = window.scrollY\n            let targetTop = top - 80\n            let s = targetTop - currentTop //路程\n            var coords = {\n                y: currentTop\n            }; //起始位置\n            var t = Math.abs(s / 100) * 300;\n            if (t > 500) {\n                t = 500\n            } //时间\n            var tween = new TWEEN.Tween(coords) //起始位置\n                .to({\n                    y: targetTop\n                }, t) //结束位置和时间\n                .easing(TWEEN.Easing.Quadratic.InOut) //缓动类型\n                .onUpdate(function () {\n                    //coords.y 已经变了\n                    window.scrollTo(0, coords.y) //如何更新界面\n                })\n                .start(); //开始缓动\n        },\n        bindEvents: function () {\n            let aTags = this.view.querySelectorAll('nav.menu > ul > li > a')\n            for (let i = 0; i < aTags.length; i++) {\n                aTags[i].onclick = (x) =>{\n                    x.preventDefault()\n                    let a = x.currentTarget\n                    let href = a.getAttribute('href') //'#siteAbout'\n                    let element = document.querySelector(href)\n                    this.scrollToElement(element)\n                }\n            }\n        }\n    }\n    controller.init(view)\n}.call()\n```\n\n# 总结\n\n所有模块结构：\n**在立即执行函数内部**\n**有个 view**\n**有个 controller**\n**controller 操作 view**\n将复杂的代码模块化，然后通过对象 controller 将 view 的函数通过 this 串起来，使得每一个 view 的函数都可以被 controller 操控\n\n**后续：MVC 的 M：[做一个简单的留言——leancloud 数据库](https://www.jianshu.com/p/039f910539d8)**\n\n---\n\n本文仅供个人学习使用\n","source":"_posts/MVC-初尝试之-V-和-C.md","raw":"---\ntitle: MVC 初尝试之 V 和 C\ndate: 2018-08-18 16:51:10\ntags: 设计模式\n---\n\n# 什么是[MVC](http://www.ruanyifeng.com/blog/2007/11/mvc.html)![](https://upload-images.jianshu.io/upload_images/7094266-bd2a358032410034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n视图（View）：用户界面。\n控制器（Controller）：业务逻辑\n模型（Model）：数据保存\n![](https://upload-images.jianshu.io/upload_images/7094266-6f849f9b1d7762be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nView 传送指令到 Controller\nController 完成业务逻辑后，要求 Model 改变状态\nModel 将新的数据发送到 View，用户得到反馈\n\n# 那么怎么做呢\n\n**1.模块化你的 js 代码**\n将同一模块的 js 代码放在同一个文件夹里并正确命名，用立即执行函数[相关博客](https://www.jianshu.com/p/d880bacbc0e9)封装代码，防止出现全局变量\n\n```\n<!-- 模块化 -->\n    <script src=\"./js/init-swiper.js\"></script>\n    <script src=\"./js/auto-slide-up.js\"></script>\n    <script src=\"./js/sticky-topbar.js\"></script>\n    <script src=\"./js/smoothly-navigation.js\"></script>\n```\n\n**2.设置 V 和 C**\n\n2.1.首先简单区分出 V 和 C\n找到 js 模块对应的 html 模块，即是 view\nview 的作用是告诉 js 哪一部分是对应模块的 view\n以轮播模块为例\n\n```\n<!-- 这就是 view ，用户可以看到 -->\n<div id=\"mySlides\">\n    <!-- Slider main container -->\n    <div class=\"swiper-container\">\n        <!-- Additional required wrapper -->\n        <div class=\"swiper-wrapper\">\n            <!-- Slides -->\n            <img src=\"./img/works/nav-page.jpg\" class=\"swiper-slide\">\n            <img src=\"./img/works/canvas.jpg\" class=\"swiper-slide\">\n            <img src=\"./img/works/apple-style-slides.jpg\" class=\"swiper-slide\">\n        </div>\n        <!-- If we need pagination -->\n        <div class=\"swiper-pagination\"></div>\n    </div>\n    <!-- If we need navigation buttons -->\n    <div class=\"swiper-button-prev\"></div>\n    <div class=\"swiper-button-next\"></div>\n</div>\n```\n\n2.1.1.在 js 中声明一个 view 作为 js 模块的 view，如轮播模块的 view 为 #mySlides\n2.1.2.声明一个 controller 他是 view 的函数\n\n```\n!function(){\n    var view = document.querySelector('#mySlides')\n    var controller = function(view){\n        var mySwiper = new Swiper(view.querySelector('.swiper-container'), {\n            loop: true,\n            // If we need pagination\n            pagination: {\n                el: '.swiper-pagination',\n            },\n\n            // Navigation arrows\n            navigation: {\n                nextEl: '.swiper-button-next',\n                prevEl: '.swiper-button-prev',\n            }\n        })\n    }\n    controller(view)\n}.call()\n```\n\n2.2.再简化一下\n用另一个模块 topNavBar 举例（可以看到每个模块结构是一致的）\n\n```\n! function () {\n    var view = document.querySelector('#topNavBar')\n    //把 controller 变成对象\n    var controller = {\n        //把函数放到 init 里（init 即是初始化）\n        init: function (view) {\n            window.addEventListener('scroll', function (x) {\n                if (window.scrollY > 0) {\n                    topNavBar.classList.add('sticky')\n                } else {\n                    topNavBar.classList.remove('sticky')\n                }\n            })\n        }\n    }\n    //此时 controller(view) 就变成了 controller.init(view)\n    controller.init(view)\n}.call()\n```\n\n下面是关键\n\n```\n! function () {\n    var view = document.querySelector('#topNavBar')\n    var controller = {\n        //开始 controller 有个空的 view\n        view: null,\n        //有个初始化函数\n        init: function (view) {\n            //把 view 存到 controller 的 view 里\n            this.view = view\n            //下面代码 this.bindEvents.call(this)\n            this.bindEvents()\n        },\n        //绑定事件\n        bindEvents: function () {\n            //所以这里的 this 就是上面的 this\n            //上面的 this 就等于 controller.init(view)\n            //controller.init(view) 的 this 就是 controller\n            var view = this.view\n            window.addEventListener('scroll', function (x) {\n                if (window.scrollY > 0) {\n                    topNavBar.classList.add('sticky')\n                } else {\n                    topNavBar.classList.remove('sticky')\n                }\n            })\n        }\n    }\n    //下面代码等价于controller.init.call(controller,view) 即 this 就是controller\n    controller.init(view)\n}.call()\n```\n\ncontroller 有个 view，有个初始化函数，并可以绑定事件\n下面优化绑定事件函数内部代码，让其只起绑定事件的作用\n\n```\nwindow.addEventListener('scroll', function (x) {\n    if (window.scrollY > 0) {\n        topNavBar.classList.add('sticky')\n    } else {\n        topNavBar.classList.remove('sticky')\n    }\n})\n```\n\n由于 addEventListener 里面的 this 代表用户触发的元素\n但是我们希望 this 与原来一致\n**解决方法一：用 bind()**\n\n```\nwindow.addEventListener('scroll', function (x) {\n    if (window.scrollY > 0) {\n        topNavBar.classList.add('sticky')\n    } else {\n        topNavBar.classList.remove('sticky')\n    }\n}).bind(this)\n```\n\n**解决方法二：**\n用箭头函数，由于箭头函数没有 this ，所以当我们在其内部使用 this 默认就是外部的 this。\n**可以说箭头函数内外 this 不变，我们的目的就是让函数内外 this 不变**\n\n然后将 addClass 和 remove Class 事件也用各自的函数分隔开，同样用 this 和 view 串起来\n完整代码\n\n```\n! function () {\n    var view = document.querySelector('#topNavBar')\n    var controller = {\n        view: null,\n        init: function (view) {\n            this.view = view\n            this.bindEvents()\n        },\n        bindEvents: function () {\n            var view = this.view\n            window.addEventListener('scroll', (x) =>{\n                if (window.scrollY > 0) {\n                    this.active()\n                } else {\n                    this.deactive()\n                }\n            })\n        },\n        active:function(){\n            this.view.classList.add('sticky')\n        },\n        deactive:function(){\n            this.view.classList.remove('sticky')\n        }\n    }\n    controller.init(view)\n}.call()\n```\n\n轮播完整代码\n\n```\n! function () {\n    var view = document.querySelector('#mySlides')\n    var controller = {\n        view: null,\n        swiper: null,\n        swiperOptions: {\n            loop: true,\n            pagination: {\n                el: '.swiper-pagination',\n            },\n            navigation: {\n                nextEl: '.swiper-button-next',\n                prevEl: '.swiper-button-prev',\n            }\n        },\n        init: function (view) {\n            this.view = view\n            this.initSwiper()\n        },\n        initSwiper: function () {\n            this.swiper = new Swiper(\n                this.view.querySelector('.swiper-container'),\n                this.swiperOptions\n            )\n        },\n    }\n    controller.init(view)\n}.call()\n```\n\nsmoothly-navigation.js 模块代码\n\n```\n! function () {\n    var view = document.querySelector('nav.menu')\n    var controller = {\n        view: null,\n        aTags: null,\n        init: function (view) {\n            this.view = view\n            this.initAnimation()\n            this.bindEvents()\n        },\n        initAnimation: function () {\n            function animate(time) {\n                requestAnimationFrame(animate);\n                TWEEN.update(time);\n            }\n            requestAnimationFrame(animate);\n        },\n        scrollToElement: function (element) {\n            let top = element.offsetTop\n            let currentTop = window.scrollY\n            let targetTop = top - 80\n            let s = targetTop - currentTop //路程\n            var coords = {\n                y: currentTop\n            }; //起始位置\n            var t = Math.abs(s / 100) * 300;\n            if (t > 500) {\n                t = 500\n            } //时间\n            var tween = new TWEEN.Tween(coords) //起始位置\n                .to({\n                    y: targetTop\n                }, t) //结束位置和时间\n                .easing(TWEEN.Easing.Quadratic.InOut) //缓动类型\n                .onUpdate(function () {\n                    //coords.y 已经变了\n                    window.scrollTo(0, coords.y) //如何更新界面\n                })\n                .start(); //开始缓动\n        },\n        bindEvents: function () {\n            let aTags = this.view.querySelectorAll('nav.menu > ul > li > a')\n            for (let i = 0; i < aTags.length; i++) {\n                aTags[i].onclick = (x) =>{\n                    x.preventDefault()\n                    let a = x.currentTarget\n                    let href = a.getAttribute('href') //'#siteAbout'\n                    let element = document.querySelector(href)\n                    this.scrollToElement(element)\n                }\n            }\n        }\n    }\n    controller.init(view)\n}.call()\n```\n\n# 总结\n\n所有模块结构：\n**在立即执行函数内部**\n**有个 view**\n**有个 controller**\n**controller 操作 view**\n将复杂的代码模块化，然后通过对象 controller 将 view 的函数通过 this 串起来，使得每一个 view 的函数都可以被 controller 操控\n\n**后续：MVC 的 M：[做一个简单的留言——leancloud 数据库](https://www.jianshu.com/p/039f910539d8)**\n\n---\n\n本文仅供个人学习使用\n","slug":"MVC-初尝试之-V-和-C","published":1,"updated":"2020-03-28T17:36:56.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyt000dws99k297k38v","content":"<h1 id=\"什么是MVC\"><a href=\"#什么是MVC\" class=\"headerlink\" title=\"什么是MVC\"></a>什么是<a href=\"http://www.ruanyifeng.com/blog/2007/11/mvc.html\" target=\"_blank\" rel=\"noopener\">MVC</a><img src=\"https://upload-images.jianshu.io/upload_images/7094266-bd2a358032410034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></h1><p>视图（View）：用户界面。<br>控制器（Controller）：业务逻辑<br>模型（Model）：数据保存<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-6f849f9b1d7762be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>View 传送指令到 Controller<br>Controller 完成业务逻辑后，要求 Model 改变状态<br>Model 将新的数据发送到 View，用户得到反馈</p>\n<h1 id=\"那么怎么做呢\"><a href=\"#那么怎么做呢\" class=\"headerlink\" title=\"那么怎么做呢\"></a>那么怎么做呢</h1><p><strong>1.模块化你的 js 代码</strong><br>将同一模块的 js 代码放在同一个文件夹里并正确命名，用立即执行函数<a href=\"https://www.jianshu.com/p/d880bacbc0e9\" target=\"_blank\" rel=\"noopener\">相关博客</a>封装代码，防止出现全局变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 模块化 --&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/init-swiper.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/auto-slide-up.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/sticky-topbar.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/smoothly-navigation.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>2.设置 V 和 C</strong></p>\n<p>2.1.首先简单区分出 V 和 C<br>找到 js 模块对应的 html 模块，即是 view<br>view 的作用是告诉 js 哪一部分是对应模块的 view<br>以轮播模块为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这就是 view ，用户可以看到 --&gt;</span><br><span class=\"line\">&lt;div id=&quot;mySlides&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Slider main container --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;swiper-container&quot;&gt;</span><br><span class=\"line\">        &lt;!-- Additional required wrapper --&gt;</span><br><span class=\"line\">        &lt;div class=&quot;swiper-wrapper&quot;&gt;</span><br><span class=\"line\">            &lt;!-- Slides --&gt;</span><br><span class=\"line\">            &lt;img src=&quot;./img/works/nav-page.jpg&quot; class=&quot;swiper-slide&quot;&gt;</span><br><span class=\"line\">            &lt;img src=&quot;./img/works/canvas.jpg&quot; class=&quot;swiper-slide&quot;&gt;</span><br><span class=\"line\">            &lt;img src=&quot;./img/works/apple-style-slides.jpg&quot; class=&quot;swiper-slide&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;!-- If we need pagination --&gt;</span><br><span class=\"line\">        &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;!-- If we need navigation buttons --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>2.1.1.在 js 中声明一个 view 作为 js 模块的 view，如轮播模块的 view 为 #mySlides<br>2.1.2.声明一个 controller 他是 view 的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!function()&#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#mySlides&apos;)</span><br><span class=\"line\">    var controller = function(view)&#123;</span><br><span class=\"line\">        var mySwiper = new Swiper(view.querySelector(&apos;.swiper-container&apos;), &#123;</span><br><span class=\"line\">            loop: true,</span><br><span class=\"line\">            // If we need pagination</span><br><span class=\"line\">            pagination: &#123;</span><br><span class=\"line\">                el: &apos;.swiper-pagination&apos;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">            // Navigation arrows</span><br><span class=\"line\">            navigation: &#123;</span><br><span class=\"line\">                nextEl: &apos;.swiper-button-next&apos;,</span><br><span class=\"line\">                prevEl: &apos;.swiper-button-prev&apos;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>2.2.再简化一下<br>用另一个模块 topNavBar 举例（可以看到每个模块结构是一致的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#topNavBar&apos;)</span><br><span class=\"line\">    //把 controller 变成对象</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        //把函数放到 init 里（init 即是初始化）</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">                if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">                    topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //此时 controller(view) 就变成了 controller.init(view)</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>下面是关键</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#topNavBar&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        //开始 controller 有个空的 view</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        //有个初始化函数</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            //把 view 存到 controller 的 view 里</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            //下面代码 this.bindEvents.call(this)</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //绑定事件</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            //所以这里的 this 就是上面的 this</span><br><span class=\"line\">            //上面的 this 就等于 controller.init(view)</span><br><span class=\"line\">            //controller.init(view) 的 this 就是 controller</span><br><span class=\"line\">            var view = this.view</span><br><span class=\"line\">            window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">                if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">                    topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //下面代码等价于controller.init.call(controller,view) 即 this 就是controller</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>controller 有个 view，有个初始化函数，并可以绑定事件<br>下面优化绑定事件函数内部代码，让其只起绑定事件的作用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">    if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">        topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>由于 addEventListener 里面的 this 代表用户触发的元素<br>但是我们希望 this 与原来一致<br><strong>解决方法一：用 bind()</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">    if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">        topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).bind(this)</span><br></pre></td></tr></table></figure>\n<p><strong>解决方法二：</strong><br>用箭头函数，由于箭头函数没有 this ，所以当我们在其内部使用 this 默认就是外部的 this。<br><strong>可以说箭头函数内外 this 不变，我们的目的就是让函数内外 this 不变</strong></p>\n<p>然后将 addClass 和 remove Class 事件也用各自的函数分隔开，同样用 this 和 view 串起来<br>完整代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#topNavBar&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            var view = this.view</span><br><span class=\"line\">            window.addEventListener(&apos;scroll&apos;, (x) =&gt;&#123;</span><br><span class=\"line\">                if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">                    this.active()</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    this.deactive()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        active:function()&#123;</span><br><span class=\"line\">            this.view.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        deactive:function()&#123;</span><br><span class=\"line\">            this.view.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>轮播完整代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#mySlides&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        swiper: null,</span><br><span class=\"line\">        swiperOptions: &#123;</span><br><span class=\"line\">            loop: true,</span><br><span class=\"line\">            pagination: &#123;</span><br><span class=\"line\">                el: &apos;.swiper-pagination&apos;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            navigation: &#123;</span><br><span class=\"line\">                nextEl: &apos;.swiper-button-next&apos;,</span><br><span class=\"line\">                prevEl: &apos;.swiper-button-prev&apos;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.initSwiper()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        initSwiper: function () &#123;</span><br><span class=\"line\">            this.swiper = new Swiper(</span><br><span class=\"line\">                this.view.querySelector(&apos;.swiper-container&apos;),</span><br><span class=\"line\">                this.swiperOptions</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>smoothly-navigation.js 模块代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;nav.menu&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        aTags: null,</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.initAnimation()</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        initAnimation: function () &#123;</span><br><span class=\"line\">            function animate(time) &#123;</span><br><span class=\"line\">                requestAnimationFrame(animate);</span><br><span class=\"line\">                TWEEN.update(time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            requestAnimationFrame(animate);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scrollToElement: function (element) &#123;</span><br><span class=\"line\">            let top = element.offsetTop</span><br><span class=\"line\">            let currentTop = window.scrollY</span><br><span class=\"line\">            let targetTop = top - 80</span><br><span class=\"line\">            let s = targetTop - currentTop //路程</span><br><span class=\"line\">            var coords = &#123;</span><br><span class=\"line\">                y: currentTop</span><br><span class=\"line\">            &#125;; //起始位置</span><br><span class=\"line\">            var t = Math.abs(s / 100) * 300;</span><br><span class=\"line\">            if (t &gt; 500) &#123;</span><br><span class=\"line\">                t = 500</span><br><span class=\"line\">            &#125; //时间</span><br><span class=\"line\">            var tween = new TWEEN.Tween(coords) //起始位置</span><br><span class=\"line\">                .to(&#123;</span><br><span class=\"line\">                    y: targetTop</span><br><span class=\"line\">                &#125;, t) //结束位置和时间</span><br><span class=\"line\">                .easing(TWEEN.Easing.Quadratic.InOut) //缓动类型</span><br><span class=\"line\">                .onUpdate(function () &#123;</span><br><span class=\"line\">                    //coords.y 已经变了</span><br><span class=\"line\">                    window.scrollTo(0, coords.y) //如何更新界面</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .start(); //开始缓动</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            let aTags = this.view.querySelectorAll(&apos;nav.menu &gt; ul &gt; li &gt; a&apos;)</span><br><span class=\"line\">            for (let i = 0; i &lt; aTags.length; i++) &#123;</span><br><span class=\"line\">                aTags[i].onclick = (x) =&gt;&#123;</span><br><span class=\"line\">                    x.preventDefault()</span><br><span class=\"line\">                    let a = x.currentTarget</span><br><span class=\"line\">                    let href = a.getAttribute(&apos;href&apos;) //&apos;#siteAbout&apos;</span><br><span class=\"line\">                    let element = document.querySelector(href)</span><br><span class=\"line\">                    this.scrollToElement(element)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所有模块结构：<br><strong>在立即执行函数内部</strong><br><strong>有个 view</strong><br><strong>有个 controller</strong><br><strong>controller 操作 view</strong><br>将复杂的代码模块化，然后通过对象 controller 将 view 的函数通过 this 串起来，使得每一个 view 的函数都可以被 controller 操控</p>\n<p><strong>后续：MVC 的 M：<a href=\"https://www.jianshu.com/p/039f910539d8\" target=\"_blank\" rel=\"noopener\">做一个简单的留言——leancloud 数据库</a></strong></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是MVC\"><a href=\"#什么是MVC\" class=\"headerlink\" title=\"什么是MVC\"></a>什么是<a href=\"http://www.ruanyifeng.com/blog/2007/11/mvc.html\" target=\"_blank\" rel=\"noopener\">MVC</a><img src=\"https://upload-images.jianshu.io/upload_images/7094266-bd2a358032410034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></h1><p>视图（View）：用户界面。<br>控制器（Controller）：业务逻辑<br>模型（Model）：数据保存<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-6f849f9b1d7762be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>View 传送指令到 Controller<br>Controller 完成业务逻辑后，要求 Model 改变状态<br>Model 将新的数据发送到 View，用户得到反馈</p>\n<h1 id=\"那么怎么做呢\"><a href=\"#那么怎么做呢\" class=\"headerlink\" title=\"那么怎么做呢\"></a>那么怎么做呢</h1><p><strong>1.模块化你的 js 代码</strong><br>将同一模块的 js 代码放在同一个文件夹里并正确命名，用立即执行函数<a href=\"https://www.jianshu.com/p/d880bacbc0e9\" target=\"_blank\" rel=\"noopener\">相关博客</a>封装代码，防止出现全局变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 模块化 --&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/init-swiper.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/auto-slide-up.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/sticky-topbar.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./js/smoothly-navigation.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>2.设置 V 和 C</strong></p>\n<p>2.1.首先简单区分出 V 和 C<br>找到 js 模块对应的 html 模块，即是 view<br>view 的作用是告诉 js 哪一部分是对应模块的 view<br>以轮播模块为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这就是 view ，用户可以看到 --&gt;</span><br><span class=\"line\">&lt;div id=&quot;mySlides&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Slider main container --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;swiper-container&quot;&gt;</span><br><span class=\"line\">        &lt;!-- Additional required wrapper --&gt;</span><br><span class=\"line\">        &lt;div class=&quot;swiper-wrapper&quot;&gt;</span><br><span class=\"line\">            &lt;!-- Slides --&gt;</span><br><span class=\"line\">            &lt;img src=&quot;./img/works/nav-page.jpg&quot; class=&quot;swiper-slide&quot;&gt;</span><br><span class=\"line\">            &lt;img src=&quot;./img/works/canvas.jpg&quot; class=&quot;swiper-slide&quot;&gt;</span><br><span class=\"line\">            &lt;img src=&quot;./img/works/apple-style-slides.jpg&quot; class=&quot;swiper-slide&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;!-- If we need pagination --&gt;</span><br><span class=\"line\">        &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;!-- If we need navigation buttons --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>2.1.1.在 js 中声明一个 view 作为 js 模块的 view，如轮播模块的 view 为 #mySlides<br>2.1.2.声明一个 controller 他是 view 的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!function()&#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#mySlides&apos;)</span><br><span class=\"line\">    var controller = function(view)&#123;</span><br><span class=\"line\">        var mySwiper = new Swiper(view.querySelector(&apos;.swiper-container&apos;), &#123;</span><br><span class=\"line\">            loop: true,</span><br><span class=\"line\">            // If we need pagination</span><br><span class=\"line\">            pagination: &#123;</span><br><span class=\"line\">                el: &apos;.swiper-pagination&apos;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">            // Navigation arrows</span><br><span class=\"line\">            navigation: &#123;</span><br><span class=\"line\">                nextEl: &apos;.swiper-button-next&apos;,</span><br><span class=\"line\">                prevEl: &apos;.swiper-button-prev&apos;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>2.2.再简化一下<br>用另一个模块 topNavBar 举例（可以看到每个模块结构是一致的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#topNavBar&apos;)</span><br><span class=\"line\">    //把 controller 变成对象</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        //把函数放到 init 里（init 即是初始化）</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">                if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">                    topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //此时 controller(view) 就变成了 controller.init(view)</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>下面是关键</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#topNavBar&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        //开始 controller 有个空的 view</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        //有个初始化函数</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            //把 view 存到 controller 的 view 里</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            //下面代码 this.bindEvents.call(this)</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        //绑定事件</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            //所以这里的 this 就是上面的 this</span><br><span class=\"line\">            //上面的 this 就等于 controller.init(view)</span><br><span class=\"line\">            //controller.init(view) 的 this 就是 controller</span><br><span class=\"line\">            var view = this.view</span><br><span class=\"line\">            window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">                if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">                    topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //下面代码等价于controller.init.call(controller,view) 即 this 就是controller</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>controller 有个 view，有个初始化函数，并可以绑定事件<br>下面优化绑定事件函数内部代码，让其只起绑定事件的作用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">    if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">        topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>由于 addEventListener 里面的 this 代表用户触发的元素<br>但是我们希望 this 与原来一致<br><strong>解决方法一：用 bind()</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&apos;scroll&apos;, function (x) &#123;</span><br><span class=\"line\">    if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">        topNavBar.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        topNavBar.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).bind(this)</span><br></pre></td></tr></table></figure>\n<p><strong>解决方法二：</strong><br>用箭头函数，由于箭头函数没有 this ，所以当我们在其内部使用 this 默认就是外部的 this。<br><strong>可以说箭头函数内外 this 不变，我们的目的就是让函数内外 this 不变</strong></p>\n<p>然后将 addClass 和 remove Class 事件也用各自的函数分隔开，同样用 this 和 view 串起来<br>完整代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#topNavBar&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            var view = this.view</span><br><span class=\"line\">            window.addEventListener(&apos;scroll&apos;, (x) =&gt;&#123;</span><br><span class=\"line\">                if (window.scrollY &gt; 0) &#123;</span><br><span class=\"line\">                    this.active()</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    this.deactive()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        active:function()&#123;</span><br><span class=\"line\">            this.view.classList.add(&apos;sticky&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        deactive:function()&#123;</span><br><span class=\"line\">            this.view.classList.remove(&apos;sticky&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>轮播完整代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;#mySlides&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        swiper: null,</span><br><span class=\"line\">        swiperOptions: &#123;</span><br><span class=\"line\">            loop: true,</span><br><span class=\"line\">            pagination: &#123;</span><br><span class=\"line\">                el: &apos;.swiper-pagination&apos;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            navigation: &#123;</span><br><span class=\"line\">                nextEl: &apos;.swiper-button-next&apos;,</span><br><span class=\"line\">                prevEl: &apos;.swiper-button-prev&apos;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.initSwiper()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        initSwiper: function () &#123;</span><br><span class=\"line\">            this.swiper = new Swiper(</span><br><span class=\"line\">                this.view.querySelector(&apos;.swiper-container&apos;),</span><br><span class=\"line\">                this.swiperOptions</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>smoothly-navigation.js 模块代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function () &#123;</span><br><span class=\"line\">    var view = document.querySelector(&apos;nav.menu&apos;)</span><br><span class=\"line\">    var controller = &#123;</span><br><span class=\"line\">        view: null,</span><br><span class=\"line\">        aTags: null,</span><br><span class=\"line\">        init: function (view) &#123;</span><br><span class=\"line\">            this.view = view</span><br><span class=\"line\">            this.initAnimation()</span><br><span class=\"line\">            this.bindEvents()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        initAnimation: function () &#123;</span><br><span class=\"line\">            function animate(time) &#123;</span><br><span class=\"line\">                requestAnimationFrame(animate);</span><br><span class=\"line\">                TWEEN.update(time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            requestAnimationFrame(animate);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scrollToElement: function (element) &#123;</span><br><span class=\"line\">            let top = element.offsetTop</span><br><span class=\"line\">            let currentTop = window.scrollY</span><br><span class=\"line\">            let targetTop = top - 80</span><br><span class=\"line\">            let s = targetTop - currentTop //路程</span><br><span class=\"line\">            var coords = &#123;</span><br><span class=\"line\">                y: currentTop</span><br><span class=\"line\">            &#125;; //起始位置</span><br><span class=\"line\">            var t = Math.abs(s / 100) * 300;</span><br><span class=\"line\">            if (t &gt; 500) &#123;</span><br><span class=\"line\">                t = 500</span><br><span class=\"line\">            &#125; //时间</span><br><span class=\"line\">            var tween = new TWEEN.Tween(coords) //起始位置</span><br><span class=\"line\">                .to(&#123;</span><br><span class=\"line\">                    y: targetTop</span><br><span class=\"line\">                &#125;, t) //结束位置和时间</span><br><span class=\"line\">                .easing(TWEEN.Easing.Quadratic.InOut) //缓动类型</span><br><span class=\"line\">                .onUpdate(function () &#123;</span><br><span class=\"line\">                    //coords.y 已经变了</span><br><span class=\"line\">                    window.scrollTo(0, coords.y) //如何更新界面</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .start(); //开始缓动</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bindEvents: function () &#123;</span><br><span class=\"line\">            let aTags = this.view.querySelectorAll(&apos;nav.menu &gt; ul &gt; li &gt; a&apos;)</span><br><span class=\"line\">            for (let i = 0; i &lt; aTags.length; i++) &#123;</span><br><span class=\"line\">                aTags[i].onclick = (x) =&gt;&#123;</span><br><span class=\"line\">                    x.preventDefault()</span><br><span class=\"line\">                    let a = x.currentTarget</span><br><span class=\"line\">                    let href = a.getAttribute(&apos;href&apos;) //&apos;#siteAbout&apos;</span><br><span class=\"line\">                    let element = document.querySelector(href)</span><br><span class=\"line\">                    this.scrollToElement(element)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    controller.init(view)</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所有模块结构：<br><strong>在立即执行函数内部</strong><br><strong>有个 view</strong><br><strong>有个 controller</strong><br><strong>controller 操作 view</strong><br>将复杂的代码模块化，然后通过对象 controller 将 view 的函数通过 this 串起来，使得每一个 view 的函数都可以被 controller 操控</p>\n<p><strong>后续：MVC 的 M：<a href=\"https://www.jianshu.com/p/039f910539d8\" target=\"_blank\" rel=\"noopener\">做一个简单的留言——leancloud 数据库</a></strong></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n"},{"title":"Vue 项目编译时间过长问题","date":"2019-11-14T15:20:51.000Z","_content":"\n随着公司项目不断增大，项目打包编译的时长也不断增加，尤其是在公司使用 jenkins 自动化部署以后更甚。由此我想到此问题可能是引入依赖过多而造成。通过 google 查看分析，终于找到相关问题并初步实践，方法如下：\n\n# 1. 使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 分析项目外部依赖大小\n\n```\n# NPM\nnpm install --save-dev webpack-bundle-analyzer\n# Yarn\nyarn add -D webpack-bundle-analyzer\n```\n\n官网显示的使用方法，需要在 webpack.config.js 内配置：\n\n```\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}\n```\n\n而我们的项目是使用 vue-cli3 搭建，其内置 webpack （也就是没有 webpack.config.js），因此我们找到 vue.config.js 使用如下代码引入插件：\n\n```\n// vue.config.js\nmodule.exports = {\n\n  chainWebpack: config => {\n    //*//\n    config\n      .plugin('webpack-bundle-analyzer')\n      .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)\n  },\n}\n```\n\n此时运行 yarn serve 会执行 webpack-bundle-analyzer 插件 BundleAnalyzerPlugin 的默认功能\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ab4bc9a1e287601a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nserve 完成，会在浏览器自动生成依赖大小分析的可视化网站，如下图所示\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a23b069d62f17087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 2. 使用 [webpack 外部扩展(externals)](https://www.webpackjs.com/configuration/externals/)\n\n> 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖\n\n## 使用前打包时间\n\n![](https://upload-images.jianshu.io/upload_images/7094266-db8c24d4609bb95c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n使用 externals 过滤我们希望通过 cdn 引入的依赖，同样在 vue.config.js 配置：\n（注意所需依赖的别名）\n\n```\n// vue.config.js\nmodule.exports = {\n\n  chainWebpack: config => {\n    //*//\n    config.externals({\n      'axios': 'axios',\n      'vue': 'Vue',\n      'vue-router': 'VueRouter',\n      'vuex': 'Vuex',\n      'element-ui': 'ELEMENT' // 注意此处要全大写且 Vue.use(ELEMENT)\n    })\n  },\n}\n```\n\n而后在项目 index.html 文件内引入对应 cdn\n\n```\n<!-- public/index.html -->\n  <script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"></script>\n  <script src=\"https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js\"></script>\n  <script src=\"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js\"></script>\n  <script src=\"https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js\">\n  <script src=\"https://cdn.bootcss.com/element-ui/2.3.3/index.js\"></script>\n```\n\n需要将原来的引用注释，我们的过滤才能生效\n\n```js\n// import Vue from \"vue\"\n// import Element from \"element-ui\"\n```\n\n再次使用 webpack-bundle-analyzer，可以看到依赖的体积减少了近 10 M\n\n![](https://upload-images.jianshu.io/upload_images/7094266-8519d5ef027b6035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 使用后打包时间\n\n再次打包，打包时间缩短了近一倍\n\n![](https://upload-images.jianshu.io/upload_images/7094266-7df2a6d82c804a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n未完待续。。。\n\n---\n\n参考\n[vue-cli3 使用 webpack-bundle-analyzer 插件](https://juejin.im/post/5d7266495188256f3b09baea);\n[解决 vue 打包 wendor 过大的问题](https://www.jianshu.com/p/b2fe6aebe691)\n","source":"_posts/Vue-项目编译时间过长问题.md","raw":"---\ntitle: Vue 项目编译时间过长问题\ndate: 2019-11-14 23:20:51\ntags: Vue\n---\n\n随着公司项目不断增大，项目打包编译的时长也不断增加，尤其是在公司使用 jenkins 自动化部署以后更甚。由此我想到此问题可能是引入依赖过多而造成。通过 google 查看分析，终于找到相关问题并初步实践，方法如下：\n\n# 1. 使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 分析项目外部依赖大小\n\n```\n# NPM\nnpm install --save-dev webpack-bundle-analyzer\n# Yarn\nyarn add -D webpack-bundle-analyzer\n```\n\n官网显示的使用方法，需要在 webpack.config.js 内配置：\n\n```\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}\n```\n\n而我们的项目是使用 vue-cli3 搭建，其内置 webpack （也就是没有 webpack.config.js），因此我们找到 vue.config.js 使用如下代码引入插件：\n\n```\n// vue.config.js\nmodule.exports = {\n\n  chainWebpack: config => {\n    //*//\n    config\n      .plugin('webpack-bundle-analyzer')\n      .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)\n  },\n}\n```\n\n此时运行 yarn serve 会执行 webpack-bundle-analyzer 插件 BundleAnalyzerPlugin 的默认功能\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ab4bc9a1e287601a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nserve 完成，会在浏览器自动生成依赖大小分析的可视化网站，如下图所示\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a23b069d62f17087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 2. 使用 [webpack 外部扩展(externals)](https://www.webpackjs.com/configuration/externals/)\n\n> 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖\n\n## 使用前打包时间\n\n![](https://upload-images.jianshu.io/upload_images/7094266-db8c24d4609bb95c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n使用 externals 过滤我们希望通过 cdn 引入的依赖，同样在 vue.config.js 配置：\n（注意所需依赖的别名）\n\n```\n// vue.config.js\nmodule.exports = {\n\n  chainWebpack: config => {\n    //*//\n    config.externals({\n      'axios': 'axios',\n      'vue': 'Vue',\n      'vue-router': 'VueRouter',\n      'vuex': 'Vuex',\n      'element-ui': 'ELEMENT' // 注意此处要全大写且 Vue.use(ELEMENT)\n    })\n  },\n}\n```\n\n而后在项目 index.html 文件内引入对应 cdn\n\n```\n<!-- public/index.html -->\n  <script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"></script>\n  <script src=\"https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js\"></script>\n  <script src=\"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js\"></script>\n  <script src=\"https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js\">\n  <script src=\"https://cdn.bootcss.com/element-ui/2.3.3/index.js\"></script>\n```\n\n需要将原来的引用注释，我们的过滤才能生效\n\n```js\n// import Vue from \"vue\"\n// import Element from \"element-ui\"\n```\n\n再次使用 webpack-bundle-analyzer，可以看到依赖的体积减少了近 10 M\n\n![](https://upload-images.jianshu.io/upload_images/7094266-8519d5ef027b6035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 使用后打包时间\n\n再次打包，打包时间缩短了近一倍\n\n![](https://upload-images.jianshu.io/upload_images/7094266-7df2a6d82c804a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n未完待续。。。\n\n---\n\n参考\n[vue-cli3 使用 webpack-bundle-analyzer 插件](https://juejin.im/post/5d7266495188256f3b09baea);\n[解决 vue 打包 wendor 过大的问题](https://www.jianshu.com/p/b2fe6aebe691)\n","slug":"Vue-项目编译时间过长问题","published":1,"updated":"2020-03-28T17:37:06.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyu000ews99qlxe0zur","content":"<p>随着公司项目不断增大，项目打包编译的时长也不断增加，尤其是在公司使用 jenkins 自动化部署以后更甚。由此我想到此问题可能是引入依赖过多而造成。通过 google 查看分析，终于找到相关问题并初步实践，方法如下：</p>\n<h1 id=\"1-使用-webpack-bundle-analyzer-分析项目外部依赖大小\"><a href=\"#1-使用-webpack-bundle-analyzer-分析项目外部依赖大小\" class=\"headerlink\" title=\"1. 使用 webpack-bundle-analyzer 分析项目外部依赖大小\"></a>1. 使用 <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">webpack-bundle-analyzer</a> 分析项目外部依赖大小</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># NPM</span><br><span class=\"line\">npm install --save-dev webpack-bundle-analyzer</span><br><span class=\"line\"># Yarn</span><br><span class=\"line\">yarn add -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>\n<p>官网显示的使用方法，需要在 webpack.config.js 内配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new BundleAnalyzerPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而我们的项目是使用 vue-cli3 搭建，其内置 webpack （也就是没有 webpack.config.js），因此我们找到 vue.config.js 使用如下代码引入插件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    //*//</span><br><span class=\"line\">    config</span><br><span class=\"line\">      .plugin(&apos;webpack-bundle-analyzer&apos;)</span><br><span class=\"line\">      .use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时运行 yarn serve 会执行 webpack-bundle-analyzer 插件 BundleAnalyzerPlugin 的默认功能</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ab4bc9a1e287601a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>serve 完成，会在浏览器自动生成依赖大小分析的可视化网站，如下图所示</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a23b069d62f17087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"2-使用-webpack-外部扩展-externals\"><a href=\"#2-使用-webpack-外部扩展-externals\" class=\"headerlink\" title=\"2. 使用 webpack 外部扩展(externals)\"></a>2. 使用 <a href=\"https://www.webpackjs.com/configuration/externals/\" target=\"_blank\" rel=\"noopener\">webpack 外部扩展(externals)</a></h1><blockquote>\n<p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖</p>\n</blockquote>\n<h2 id=\"使用前打包时间\"><a href=\"#使用前打包时间\" class=\"headerlink\" title=\"使用前打包时间\"></a>使用前打包时间</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-db8c24d4609bb95c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>使用 externals 过滤我们希望通过 cdn 引入的依赖，同样在 vue.config.js 配置：<br>（注意所需依赖的别名）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    //*//</span><br><span class=\"line\">    config.externals(&#123;</span><br><span class=\"line\">      &apos;axios&apos;: &apos;axios&apos;,</span><br><span class=\"line\">      &apos;vue&apos;: &apos;Vue&apos;,</span><br><span class=\"line\">      &apos;vue-router&apos;: &apos;VueRouter&apos;,</span><br><span class=\"line\">      &apos;vuex&apos;: &apos;Vuex&apos;,</span><br><span class=\"line\">      &apos;element-ui&apos;: &apos;ELEMENT&apos; // 注意此处要全大写且 Vue.use(ELEMENT)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而后在项目 index.html 文件内引入对应 cdn</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- public/index.html --&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js&quot;&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.3.3/index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>需要将原来的引用注释，我们的过滤才能生效</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import Vue from \"vue\"</span></span><br><span class=\"line\"><span class=\"comment\">// import Element from \"element-ui\"</span></span><br></pre></td></tr></table></figure>\n<p>再次使用 webpack-bundle-analyzer，可以看到依赖的体积减少了近 10 M</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8519d5ef027b6035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"使用后打包时间\"><a href=\"#使用后打包时间\" class=\"headerlink\" title=\"使用后打包时间\"></a>使用后打包时间</h2><p>再次打包，打包时间缩短了近一倍</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-7df2a6d82c804a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>未完待续。。。</p>\n<hr>\n<p>参考<br><a href=\"https://juejin.im/post/5d7266495188256f3b09baea\" target=\"_blank\" rel=\"noopener\">vue-cli3 使用 webpack-bundle-analyzer 插件</a>;<br><a href=\"https://www.jianshu.com/p/b2fe6aebe691\" target=\"_blank\" rel=\"noopener\">解决 vue 打包 wendor 过大的问题</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>随着公司项目不断增大，项目打包编译的时长也不断增加，尤其是在公司使用 jenkins 自动化部署以后更甚。由此我想到此问题可能是引入依赖过多而造成。通过 google 查看分析，终于找到相关问题并初步实践，方法如下：</p>\n<h1 id=\"1-使用-webpack-bundle-analyzer-分析项目外部依赖大小\"><a href=\"#1-使用-webpack-bundle-analyzer-分析项目外部依赖大小\" class=\"headerlink\" title=\"1. 使用 webpack-bundle-analyzer 分析项目外部依赖大小\"></a>1. 使用 <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">webpack-bundle-analyzer</a> 分析项目外部依赖大小</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># NPM</span><br><span class=\"line\">npm install --save-dev webpack-bundle-analyzer</span><br><span class=\"line\"># Yarn</span><br><span class=\"line\">yarn add -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>\n<p>官网显示的使用方法，需要在 webpack.config.js 内配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new BundleAnalyzerPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而我们的项目是使用 vue-cli3 搭建，其内置 webpack （也就是没有 webpack.config.js），因此我们找到 vue.config.js 使用如下代码引入插件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    //*//</span><br><span class=\"line\">    config</span><br><span class=\"line\">      .plugin(&apos;webpack-bundle-analyzer&apos;)</span><br><span class=\"line\">      .use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时运行 yarn serve 会执行 webpack-bundle-analyzer 插件 BundleAnalyzerPlugin 的默认功能</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ab4bc9a1e287601a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>serve 完成，会在浏览器自动生成依赖大小分析的可视化网站，如下图所示</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a23b069d62f17087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"2-使用-webpack-外部扩展-externals\"><a href=\"#2-使用-webpack-外部扩展-externals\" class=\"headerlink\" title=\"2. 使用 webpack 外部扩展(externals)\"></a>2. 使用 <a href=\"https://www.webpackjs.com/configuration/externals/\" target=\"_blank\" rel=\"noopener\">webpack 外部扩展(externals)</a></h1><blockquote>\n<p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖</p>\n</blockquote>\n<h2 id=\"使用前打包时间\"><a href=\"#使用前打包时间\" class=\"headerlink\" title=\"使用前打包时间\"></a>使用前打包时间</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-db8c24d4609bb95c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>使用 externals 过滤我们希望通过 cdn 引入的依赖，同样在 vue.config.js 配置：<br>（注意所需依赖的别名）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    //*//</span><br><span class=\"line\">    config.externals(&#123;</span><br><span class=\"line\">      &apos;axios&apos;: &apos;axios&apos;,</span><br><span class=\"line\">      &apos;vue&apos;: &apos;Vue&apos;,</span><br><span class=\"line\">      &apos;vue-router&apos;: &apos;VueRouter&apos;,</span><br><span class=\"line\">      &apos;vuex&apos;: &apos;Vuex&apos;,</span><br><span class=\"line\">      &apos;element-ui&apos;: &apos;ELEMENT&apos; // 注意此处要全大写且 Vue.use(ELEMENT)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而后在项目 index.html 文件内引入对应 cdn</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- public/index.html --&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js&quot;&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.3.3/index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>需要将原来的引用注释，我们的过滤才能生效</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import Vue from \"vue\"</span></span><br><span class=\"line\"><span class=\"comment\">// import Element from \"element-ui\"</span></span><br></pre></td></tr></table></figure>\n<p>再次使用 webpack-bundle-analyzer，可以看到依赖的体积减少了近 10 M</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8519d5ef027b6035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"使用后打包时间\"><a href=\"#使用后打包时间\" class=\"headerlink\" title=\"使用后打包时间\"></a>使用后打包时间</h2><p>再次打包，打包时间缩短了近一倍</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-7df2a6d82c804a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>未完待续。。。</p>\n<hr>\n<p>参考<br><a href=\"https://juejin.im/post/5d7266495188256f3b09baea\" target=\"_blank\" rel=\"noopener\">vue-cli3 使用 webpack-bundle-analyzer 插件</a>;<br><a href=\"https://www.jianshu.com/p/b2fe6aebe691\" target=\"_blank\" rel=\"noopener\">解决 vue 打包 wendor 过大的问题</a></p>\n"},{"title":"Vue 全家桶学习总结","date":"2019-02-26T15:32:17.000Z","_content":"# Vue\n\n## Vue.js 特性：\n\n1.轻量级\n2.双向数据绑定\n3.指令\n4.组件化\n\n## 什么是 MVVM\n\n```\nMVC => MVP => MVVM\n// 视图层和数据层的双向绑定\nView <=> ViewModel <=> Model\n```\n1. MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n2. 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\n3. ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\n## Vue.js 的优点\n\n1. 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n2. 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n3. 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。\n4. 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写\n5. 易用灵活高效\n\n## Vue 组件是什么\n\n组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。\n\n# Vue-cli\nVue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。\n\n## Vue 脚手架 3.x 以上版本使用\n\n全局安装\n```\nyarn global add @vue/cli\n```\n快速原型开发\n```\nnpm install -g @vue/cli-service-global\n```\n创建项目\n```\nvue create hello-world\n// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令\nwinpty vue.cmd create hello-world\n```\n```\ncd hello-world\n```\nProject setup\n```\nyarn install\n```\n（以下命令 run 可以省略）\nCompiles and hot-reloads for development\n```\nyarn run serve\n```\nCompiles and minifies for production\n```\nyarn run build\n```\nRun your tests\n```\nyarn run test\n```\nLints and fixes files\n```\nyarn run lint\n```\n## Vuecli 3.x 版本(上图)与 2.x 初始化目录对比\n\n![](https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# Vue Router\n\nVue Router 是 Vue.js 官方的路由管理器。\n安装\n```\nnpm install vue-router\n```\n引用\n```\nimport VueRouter from 'vue-router'\n\nVue.use(VueRouter)\n```\n配置路由文件，并在vue实例中注入 \n```\nconst router = new VueRouter({\n  routes:[{\n    path:'/user/:userId', // 指定要跳转的路径\n    name: 'user', // 命名路由，便于路由跳转\n    component: User// 指定要跳转的组件\n    }]\n})\nconst User = ({\n  template: '<div>User</div>'\n})\n```\n## 确定视图加载的位置\n视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default\n```\n<router-view></router-view>\n<router-view name=\"a\"></router-view>\n```\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: { // 同个路由，多个视图就需要多个组件,components 要有(s)\n        default: Foo,\n        a: Bar\n      }\n    }\n  ]\n})\n```\n## 实现路由跳转\n\n```\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link> // 路由导航到 /user/123\n```\n等同于代码调用 router.push() \n```\n// 编程式导航\nrouter.push({ name: 'user', params: { userId: 123 }}) // 路由导航到 /user/123\n```\n## 路由传参\n使用动态路由参数，以冒号开头\n```\nconst User = {\n  template: '<div>User</div>'\n}\n\nconst router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: '/user/:id', component: User }\n  ]\n})\n```\n现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。\n\n当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。\n```\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>'\n}\n```\n## 响应路由参数变化\n动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 **watch** (监测变化) $route 对象：\n```\nconst User = {\n  template: '...',\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n```\n或者使用 **beforeRouteUpdate** 导航守卫\n\n```\nconst User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n```\n## 路由组件参数解耦\n在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：\n```\nconst User = {\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: '/user/:id',\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n```\nprops 有三种模式：布尔模式、对象模式、函数模式\n# Vuex\n\nVuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## 在 store (存储)内有下列核心概念\n\n**State()：核心原始数据** 展示\n**Getter：计算属性，根据所依赖的数据的变化计算自身变化** 存储\n**Mutation(转变)：提交 mutation 才能改变存储状态**\n**Action：**Action 类似于 mutation，不同在于：\nAction 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n**Module：可以将将 store 分割**\n一般放在 state 文件夹下\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## vuex状态管理的流程\n\nview => actions => mutations => state => view\n\n## 核心概念详解\n\n### state：记录所有公共数据状态的对象\n```\n// 组件如何获取\nthis.$store.state.XXX\n// 此处的 XXX 是 state 内定义的数据状态的键名\n```\n### mutations：包含所有 操作数据状态的方法 的对象\n```\n// 组件如何调用\nthis.$store.commit(XXX)\n// 此处的 XXX是 mutations 中定义的方法名\n```\n### actions：用于操作 mutations 内方法 的对象\nactions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作\n```\n// 如何调用\nthis.$store.dispatch(XXX)\n// 此处的XXX是你在actions中定义的方法名\n```\n### getters：定义状态内容的方法 的对象\n```\nthis.$store.getters.XXX\n// 此处的XXX是你在getters里定义的方法名\n```\n### Module\n当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。\n每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n# Axios \naxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：\n- 从浏览器中创建 XMLHttpRequest\n- 从 node.js 发出 http 请求\n- 支持 Promise API拦截\n- 请求和响应转换\n- 请求和响应数据取消\n- 请求自动转换JSON数据\n- 客户端支持防止 CSRF/XSRF\n1. 安装\n```\nnpm install axios\n```\n2. 引入加载\n```\nimport axios from 'axios'\n```\n3. 将axios全局挂载到 Vue 原型上\n```\nVue.prototype.$http = axios\n```\n## 设置全局 axios 默认值\n```\n// 设置基础路径，一般为后端接口线上地址根路径\naxios.defaults.baseURL = 'https://api.example.com';\n// 设置默认 token\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n// 默认 POST 请求\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n## axios 的 url 有两种传递参数的形式\n```\n// 第一种 对象形式\nthis.$http.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n// 如果只有一个参数，可以省略 params\nthis.$http.get('/user', {\n      ID: 12345\n  }) \n--------------------------------- \n// 第二种 形式\nthis.$http.get('https://cnodejs.org/api/v1/topics?page=1&limit=15')\n```\n## POST 传递数据有两种格式：\n1. form­-data ?page=1&limit=48\n2. x-­www­-form-­urlencoded { page: 1,limit: 10 }\n\n**在 axios 中，post 请求接收的参数必须是 form­-data 形式\n如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换**\n```\nthis.$http.post('/user', qs.stringify({\n   ID: 12345\n  })\n);\n```\n## 实现增删改查\n### 发起 GET 请求：查\n![](https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nconst axios = require('axios') // 下同省略\n\n//发起一个user请求，参数为给定的ID\naxios.get('/user?ID=12345')\n  .then((response) => {\n    console.log(response)\n  }\n  .catch((error) => {\n    console.log(error)\n  }\n```\n### 发起 POST 请求：增\n![](https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\naxios.post('/user', {\n  firstName: 'yuanda',\n  lastName: 'zhou'\n})\n  .then((response) => {\n    console.log(response)\n  })\n  .catch(function(error){\n    console.log(error);\n  })\n```\n```\naxios.request(config)\naxios.get(url[,config])\naxios.delete(url[,config]) // 删除\naxios.head(url[,config])\naxios.options(url[,config])\naxios.post(url[,data[,config]])\naxios.put(url[,data[,config]]) // 改\naxios.patch(url[,data[,config]])\n```\nPUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。\n## 并发请求\n```\nfunction getUserAccount(){\n    return axios.get('/user/12345');\n}\n\nfunction getUserPermissions(){\n    return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUerAccount(),getUserPermissions()])\n    .then(axios.spread(function(acc,pers){\n        //两个请求现在都完成\n    }));\n```\naxios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。\n## 拦截器 interceptors\n你可以在**请求**或者**响应**被 then 或者 catch 处理之前对他们进行拦截。\n```\n//添加一个请求拦截器\naxios.interceptors.request.use(function(config){\n    //在请求发送之前做一些事\n    return config;\n},function(error){\n    //当出现请求错误是做一些事\n    return Promise.reject(error);\n});\n\n//添加一个返回拦截器\naxios.interceptors.response.use(function(response){\n    //对返回的数据进行一些处理\n    return response;\n},function(error){\n    //对返回的错误进行一些处理\n    return Promise.reject(error);\n});\n```\n用 eject 移除拦截器\n```\nvar myInterceptor = axios.interceptors.request.use(function(){/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n## axios 如何获取 cookie\naxios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：\n```\nimport axios from 'axios'\naxios.defaults.withCredentials=true; //让ajax携带cookie\nVue.prototype.$axios = axios;\n```\n通过js原生接口来获取: \n```\nlet allCookies = document.cookie \n```","source":"_posts/Vue-全家桶学习总结.md","raw":"---\ntitle: Vue 全家桶学习总结\ndate: 2019-02-26 23:32:17\ntags: Vue\n---\n# Vue\n\n## Vue.js 特性：\n\n1.轻量级\n2.双向数据绑定\n3.指令\n4.组件化\n\n## 什么是 MVVM\n\n```\nMVC => MVP => MVVM\n// 视图层和数据层的双向绑定\nView <=> ViewModel <=> Model\n```\n1. MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n\n2. 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。\n\n3. ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\n## Vue.js 的优点\n\n1. 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n2. 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n3. 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。\n4. 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写\n5. 易用灵活高效\n\n## Vue 组件是什么\n\n组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。\n\n# Vue-cli\nVue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。\n\n## Vue 脚手架 3.x 以上版本使用\n\n全局安装\n```\nyarn global add @vue/cli\n```\n快速原型开发\n```\nnpm install -g @vue/cli-service-global\n```\n创建项目\n```\nvue create hello-world\n// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令\nwinpty vue.cmd create hello-world\n```\n```\ncd hello-world\n```\nProject setup\n```\nyarn install\n```\n（以下命令 run 可以省略）\nCompiles and hot-reloads for development\n```\nyarn run serve\n```\nCompiles and minifies for production\n```\nyarn run build\n```\nRun your tests\n```\nyarn run test\n```\nLints and fixes files\n```\nyarn run lint\n```\n## Vuecli 3.x 版本(上图)与 2.x 初始化目录对比\n\n![](https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# Vue Router\n\nVue Router 是 Vue.js 官方的路由管理器。\n安装\n```\nnpm install vue-router\n```\n引用\n```\nimport VueRouter from 'vue-router'\n\nVue.use(VueRouter)\n```\n配置路由文件，并在vue实例中注入 \n```\nconst router = new VueRouter({\n  routes:[{\n    path:'/user/:userId', // 指定要跳转的路径\n    name: 'user', // 命名路由，便于路由跳转\n    component: User// 指定要跳转的组件\n    }]\n})\nconst User = ({\n  template: '<div>User</div>'\n})\n```\n## 确定视图加载的位置\n视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default\n```\n<router-view></router-view>\n<router-view name=\"a\"></router-view>\n```\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: { // 同个路由，多个视图就需要多个组件,components 要有(s)\n        default: Foo,\n        a: Bar\n      }\n    }\n  ]\n})\n```\n## 实现路由跳转\n\n```\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link> // 路由导航到 /user/123\n```\n等同于代码调用 router.push() \n```\n// 编程式导航\nrouter.push({ name: 'user', params: { userId: 123 }}) // 路由导航到 /user/123\n```\n## 路由传参\n使用动态路由参数，以冒号开头\n```\nconst User = {\n  template: '<div>User</div>'\n}\n\nconst router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: '/user/:id', component: User }\n  ]\n})\n```\n现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。\n\n当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。\n```\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>'\n}\n```\n## 响应路由参数变化\n动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 **watch** (监测变化) $route 对象：\n```\nconst User = {\n  template: '...',\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n```\n或者使用 **beforeRouteUpdate** 导航守卫\n\n```\nconst User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n```\n## 路由组件参数解耦\n在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：\n```\nconst User = {\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: '/user/:id',\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n```\nprops 有三种模式：布尔模式、对象模式、函数模式\n# Vuex\n\nVuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## 在 store (存储)内有下列核心概念\n\n**State()：核心原始数据** 展示\n**Getter：计算属性，根据所依赖的数据的变化计算自身变化** 存储\n**Mutation(转变)：提交 mutation 才能改变存储状态**\n**Action：**Action 类似于 mutation，不同在于：\nAction 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n**Module：可以将将 store 分割**\n一般放在 state 文件夹下\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## vuex状态管理的流程\n\nview => actions => mutations => state => view\n\n## 核心概念详解\n\n### state：记录所有公共数据状态的对象\n```\n// 组件如何获取\nthis.$store.state.XXX\n// 此处的 XXX 是 state 内定义的数据状态的键名\n```\n### mutations：包含所有 操作数据状态的方法 的对象\n```\n// 组件如何调用\nthis.$store.commit(XXX)\n// 此处的 XXX是 mutations 中定义的方法名\n```\n### actions：用于操作 mutations 内方法 的对象\nactions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作\n```\n// 如何调用\nthis.$store.dispatch(XXX)\n// 此处的XXX是你在actions中定义的方法名\n```\n### getters：定义状态内容的方法 的对象\n```\nthis.$store.getters.XXX\n// 此处的XXX是你在getters里定义的方法名\n```\n### Module\n当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。\n每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n# Axios \naxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：\n- 从浏览器中创建 XMLHttpRequest\n- 从 node.js 发出 http 请求\n- 支持 Promise API拦截\n- 请求和响应转换\n- 请求和响应数据取消\n- 请求自动转换JSON数据\n- 客户端支持防止 CSRF/XSRF\n1. 安装\n```\nnpm install axios\n```\n2. 引入加载\n```\nimport axios from 'axios'\n```\n3. 将axios全局挂载到 Vue 原型上\n```\nVue.prototype.$http = axios\n```\n## 设置全局 axios 默认值\n```\n// 设置基础路径，一般为后端接口线上地址根路径\naxios.defaults.baseURL = 'https://api.example.com';\n// 设置默认 token\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n// 默认 POST 请求\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n## axios 的 url 有两种传递参数的形式\n```\n// 第一种 对象形式\nthis.$http.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n// 如果只有一个参数，可以省略 params\nthis.$http.get('/user', {\n      ID: 12345\n  }) \n--------------------------------- \n// 第二种 形式\nthis.$http.get('https://cnodejs.org/api/v1/topics?page=1&limit=15')\n```\n## POST 传递数据有两种格式：\n1. form­-data ?page=1&limit=48\n2. x-­www­-form-­urlencoded { page: 1,limit: 10 }\n\n**在 axios 中，post 请求接收的参数必须是 form­-data 形式\n如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换**\n```\nthis.$http.post('/user', qs.stringify({\n   ID: 12345\n  })\n);\n```\n## 实现增删改查\n### 发起 GET 请求：查\n![](https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nconst axios = require('axios') // 下同省略\n\n//发起一个user请求，参数为给定的ID\naxios.get('/user?ID=12345')\n  .then((response) => {\n    console.log(response)\n  }\n  .catch((error) => {\n    console.log(error)\n  }\n```\n### 发起 POST 请求：增\n![](https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\naxios.post('/user', {\n  firstName: 'yuanda',\n  lastName: 'zhou'\n})\n  .then((response) => {\n    console.log(response)\n  })\n  .catch(function(error){\n    console.log(error);\n  })\n```\n```\naxios.request(config)\naxios.get(url[,config])\naxios.delete(url[,config]) // 删除\naxios.head(url[,config])\naxios.options(url[,config])\naxios.post(url[,data[,config]])\naxios.put(url[,data[,config]]) // 改\naxios.patch(url[,data[,config]])\n```\nPUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。\n## 并发请求\n```\nfunction getUserAccount(){\n    return axios.get('/user/12345');\n}\n\nfunction getUserPermissions(){\n    return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUerAccount(),getUserPermissions()])\n    .then(axios.spread(function(acc,pers){\n        //两个请求现在都完成\n    }));\n```\naxios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。\n## 拦截器 interceptors\n你可以在**请求**或者**响应**被 then 或者 catch 处理之前对他们进行拦截。\n```\n//添加一个请求拦截器\naxios.interceptors.request.use(function(config){\n    //在请求发送之前做一些事\n    return config;\n},function(error){\n    //当出现请求错误是做一些事\n    return Promise.reject(error);\n});\n\n//添加一个返回拦截器\naxios.interceptors.response.use(function(response){\n    //对返回的数据进行一些处理\n    return response;\n},function(error){\n    //对返回的错误进行一些处理\n    return Promise.reject(error);\n});\n```\n用 eject 移除拦截器\n```\nvar myInterceptor = axios.interceptors.request.use(function(){/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n## axios 如何获取 cookie\naxios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：\n```\nimport axios from 'axios'\naxios.defaults.withCredentials=true; //让ajax携带cookie\nVue.prototype.$axios = axios;\n```\n通过js原生接口来获取: \n```\nlet allCookies = document.cookie \n```","slug":"Vue-全家桶学习总结","published":1,"updated":"2020-03-28T17:37:03.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyv000fws996qgfl6hh","content":"<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1><h2 id=\"Vue-js-特性：\"><a href=\"#Vue-js-特性：\" class=\"headerlink\" title=\"Vue.js 特性：\"></a>Vue.js 特性：</h2><p>1.轻量级<br>2.双向数据绑定<br>3.指令<br>4.组件化</p>\n<h2 id=\"什么是-MVVM\"><a href=\"#什么是-MVVM\" class=\"headerlink\" title=\"什么是 MVVM\"></a>什么是 MVVM</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVC =&gt; MVP =&gt; MVVM</span><br><span class=\"line\">// 视图层和数据层的双向绑定</span><br><span class=\"line\">View &lt;=&gt; ViewModel &lt;=&gt; Model</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n</li>\n<li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n</li>\n<li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n</li>\n</ol>\n<h2 id=\"Vue-js-的优点\"><a href=\"#Vue-js-的优点\" class=\"headerlink\" title=\"Vue.js 的优点\"></a>Vue.js 的优点</h2><ol>\n<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>\n<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>\n<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>\n<li>易用灵活高效</li>\n</ol>\n<h2 id=\"Vue-组件是什么\"><a href=\"#Vue-组件是什么\" class=\"headerlink\" title=\"Vue 组件是什么\"></a>Vue 组件是什么</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p>\n<h1 id=\"Vue-cli\"><a href=\"#Vue-cli\" class=\"headerlink\" title=\"Vue-cli\"></a>Vue-cli</h1><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。</p>\n<h2 id=\"Vue-脚手架-3-x-以上版本使用\"><a href=\"#Vue-脚手架-3-x-以上版本使用\" class=\"headerlink\" title=\"Vue 脚手架 3.x 以上版本使用\"></a>Vue 脚手架 3.x 以上版本使用</h2><p>全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p>\n<p>快速原型开发<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure></p>\n<p>创建项目<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create hello-world</span><br><span class=\"line\">// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令</span><br><span class=\"line\">winpty vue.cmd create hello-world</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hello-world</span><br></pre></td></tr></table></figure>\n<p>Project setup<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn install</span><br></pre></td></tr></table></figure></p>\n<p>（以下命令 run 可以省略）<br>Compiles and hot-reloads for development<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run serve</span><br></pre></td></tr></table></figure></p>\n<p>Compiles and minifies for production<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run build</span><br></pre></td></tr></table></figure></p>\n<p>Run your tests<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run test</span><br></pre></td></tr></table></figure></p>\n<p>Lints and fixes files<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run lint</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vuecli-3-x-版本-上图-与-2-x-初始化目录对比\"><a href=\"#Vuecli-3-x-版本-上图-与-2-x-初始化目录对比\" class=\"headerlink\" title=\"Vuecli 3.x 版本(上图)与 2.x 初始化目录对比\"></a>Vuecli 3.x 版本(上图)与 2.x 初始化目录对比</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"Vue-Router\"><a href=\"#Vue-Router\" class=\"headerlink\" title=\"Vue Router\"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官方的路由管理器。<br>安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router</span><br></pre></td></tr></table></figure></p>\n<p>引用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import VueRouter from &apos;vue-router&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p>\n<p>配置路由文件，并在vue实例中注入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes:[&#123;</span><br><span class=\"line\">    path:&apos;/user/:userId&apos;, // 指定要跳转的路径</span><br><span class=\"line\">    name: &apos;user&apos;, // 命名路由，便于路由跳转</span><br><span class=\"line\">    component: User// 指定要跳转的组件</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">const User = (&#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"确定视图加载的位置\"><a href=\"#确定视图加载的位置\" class=\"headerlink\" title=\"确定视图加载的位置\"></a>确定视图加载的位置</h2><p>视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &apos;/&apos;,</span><br><span class=\"line\">      components: &#123; // 同个路由，多个视图就需要多个组件,components 要有(s)</span><br><span class=\"line\">        default: Foo,</span><br><span class=\"line\">        a: Bar</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现路由跳转\"><a href=\"#实现路由跳转\" class=\"headerlink\" title=\"实现路由跳转\"></a>实现路由跳转</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; // 路由导航到 /user/123</span><br></pre></td></tr></table></figure>\n<p>等同于代码调用 router.push()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 编程式导航</span><br><span class=\"line\">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) // 路由导航到 /user/123</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"路由传参\"><a href=\"#路由传参\" class=\"headerlink\" title=\"路由传参\"></a>路由传参</h2><p>使用动态路由参数，以冒号开头<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    // 动态路径参数 以冒号开头</span><br><span class=\"line\">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p>\n<p>当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"响应路由参数变化\"><a href=\"#响应路由参数变化\" class=\"headerlink\" title=\"响应路由参数变化\"></a>响应路由参数变化</h2><p>动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 <strong>watch</strong> (监测变化) $route 对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;...&apos;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    &apos;$route&apos; (to, from) &#123;</span><br><span class=\"line\">      // 对路由变化作出响应...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者使用 <strong>beforeRouteUpdate</strong> 导航守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;...&apos;,</span><br><span class=\"line\">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class=\"line\">    // react to route changes...</span><br><span class=\"line\">    // don&apos;t forget to call next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由组件参数解耦\"><a href=\"#路由组件参数解耦\" class=\"headerlink\" title=\"路由组件参数解耦\"></a>路由组件参数解耦</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  props: [&apos;id&apos;],</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &apos;/user/:id&apos;,</span><br><span class=\"line\">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class=\"line\">      props: &#123; default: true, sidebar: false &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>props 有三种模式：布尔模式、对象模式、函数模式</p>\n<h1 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h1><p>Vuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<h2 id=\"在-store-存储-内有下列核心概念\"><a href=\"#在-store-存储-内有下列核心概念\" class=\"headerlink\" title=\"在 store (存储)内有下列核心概念\"></a>在 store (存储)内有下列核心概念</h2><p><strong>State()：核心原始数据</strong> 展示<br><strong>Getter：计算属性，根据所依赖的数据的变化计算自身变化</strong> 存储<br><strong>Mutation(转变)：提交 mutation 才能改变存储状态</strong><br><strong>Action：</strong>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br><strong>Module：可以将将 store 分割</strong><br>一般放在 state 文件夹下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"vuex状态管理的流程\"><a href=\"#vuex状态管理的流程\" class=\"headerlink\" title=\"vuex状态管理的流程\"></a>vuex状态管理的流程</h2><p>view =&gt; actions =&gt; mutations =&gt; state =&gt; view</p>\n<h2 id=\"核心概念详解\"><a href=\"#核心概念详解\" class=\"headerlink\" title=\"核心概念详解\"></a>核心概念详解</h2><h3 id=\"state：记录所有公共数据状态的对象\"><a href=\"#state：记录所有公共数据状态的对象\" class=\"headerlink\" title=\"state：记录所有公共数据状态的对象\"></a>state：记录所有公共数据状态的对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组件如何获取</span><br><span class=\"line\">this.$store.state.XXX</span><br><span class=\"line\">// 此处的 XXX 是 state 内定义的数据状态的键名</span><br></pre></td></tr></table></figure>\n<h3 id=\"mutations：包含所有-操作数据状态的方法-的对象\"><a href=\"#mutations：包含所有-操作数据状态的方法-的对象\" class=\"headerlink\" title=\"mutations：包含所有 操作数据状态的方法 的对象\"></a>mutations：包含所有 操作数据状态的方法 的对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组件如何调用</span><br><span class=\"line\">this.$store.commit(XXX)</span><br><span class=\"line\">// 此处的 XXX是 mutations 中定义的方法名</span><br></pre></td></tr></table></figure>\n<h3 id=\"actions：用于操作-mutations-内方法-的对象\"><a href=\"#actions：用于操作-mutations-内方法-的对象\" class=\"headerlink\" title=\"actions：用于操作 mutations 内方法 的对象\"></a>actions：用于操作 mutations 内方法 的对象</h3><p>actions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如何调用</span><br><span class=\"line\">this.$store.dispatch(XXX)</span><br><span class=\"line\">// 此处的XXX是你在actions中定义的方法名</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"getters：定义状态内容的方法-的对象\"><a href=\"#getters：定义状态内容的方法-的对象\" class=\"headerlink\" title=\"getters：定义状态内容的方法 的对象\"></a>getters：定义状态内容的方法 的对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.getters.XXX</span><br><span class=\"line\">// 此处的XXX是你在getters里定义的方法名</span><br></pre></td></tr></table></figure>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。<br>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>从 node.js 发出 http 请求</li>\n<li>支持 Promise API拦截</li>\n<li>请求和响应转换</li>\n<li>请求和响应数据取消</li>\n<li>请求自动转换JSON数据</li>\n<li>客户端支持防止 CSRF/XSRF</li>\n</ul>\n<ol>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install axios</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入加载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将axios全局挂载到 Vue 原型上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"设置全局-axios-默认值\"><a href=\"#设置全局-axios-默认值\" class=\"headerlink\" title=\"设置全局 axios 默认值\"></a>设置全局 axios 默认值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置基础路径，一般为后端接口线上地址根路径</span><br><span class=\"line\">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class=\"line\">// 设置默认 token</span><br><span class=\"line\">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class=\"line\">// 默认 POST 请求</span><br><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"axios-的-url-有两种传递参数的形式\"><a href=\"#axios-的-url-有两种传递参数的形式\" class=\"headerlink\" title=\"axios 的 url 有两种传递参数的形式\"></a>axios 的 url 有两种传递参数的形式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一种 对象形式</span><br><span class=\"line\">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">// 如果只有一个参数，可以省略 params</span><br><span class=\"line\">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">  &#125;) </span><br><span class=\"line\">--------------------------------- </span><br><span class=\"line\">// 第二种 形式</span><br><span class=\"line\">this.$http.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"POST-传递数据有两种格式：\"><a href=\"#POST-传递数据有两种格式：\" class=\"headerlink\" title=\"POST 传递数据有两种格式：\"></a>POST 传递数据有两种格式：</h2><ol>\n<li>form­-data ?page=1&amp;limit=48</li>\n<li>x-­www­-form-­urlencoded { page: 1,limit: 10 }</li>\n</ol>\n<p><strong>在 axios 中，post 请求接收的参数必须是 form­-data 形式<br>如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$http.post(&apos;/user&apos;, qs.stringify(&#123;</span><br><span class=\"line\">   ID: 12345</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现增删改查\"><a href=\"#实现增删改查\" class=\"headerlink\" title=\"实现增删改查\"></a>实现增删改查</h2><h3 id=\"发起-GET-请求：查\"><a href=\"#发起-GET-请求：查\" class=\"headerlink\" title=\"发起 GET 请求：查\"></a>发起 GET 请求：查</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const axios = require(&apos;axios&apos;) // 下同省略</span><br><span class=\"line\"></span><br><span class=\"line\">//发起一个user请求，参数为给定的ID</span><br><span class=\"line\">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class=\"line\">  .then((response) =&gt; &#123;</span><br><span class=\"line\">    console.log(response)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .catch((error) =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"发起-POST-请求：增\"><a href=\"#发起-POST-请求：增\" class=\"headerlink\" title=\"发起 POST 请求：增\"></a>发起 POST 请求：增</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(&apos;/user&apos;, &#123;</span><br><span class=\"line\">  firstName: &apos;yuanda&apos;,</span><br><span class=\"line\">  lastName: &apos;zhou&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then((response) =&gt; &#123;</span><br><span class=\"line\">    console.log(response)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function(error)&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.request(config)</span><br><span class=\"line\">axios.get(url[,config])</span><br><span class=\"line\">axios.delete(url[,config]) // 删除</span><br><span class=\"line\">axios.head(url[,config])</span><br><span class=\"line\">axios.options(url[,config])</span><br><span class=\"line\">axios.post(url[,data[,config]])</span><br><span class=\"line\">axios.put(url[,data[,config]]) // 改</span><br><span class=\"line\">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>\n<p>PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</p>\n<h2 id=\"并发请求\"><a href=\"#并发请求\" class=\"headerlink\" title=\"并发请求\"></a>并发请求</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getUserAccount()&#123;</span><br><span class=\"line\">    return axios.get(&apos;/user/12345&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getUserPermissions()&#123;</span><br><span class=\"line\">    return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class=\"line\">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class=\"line\">        //两个请求现在都完成</span><br><span class=\"line\">    &#125;));</span><br></pre></td></tr></table></figure>\n<p>axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。</p>\n<h2 id=\"拦截器-interceptors\"><a href=\"#拦截器-interceptors\" class=\"headerlink\" title=\"拦截器 interceptors\"></a>拦截器 interceptors</h2><p>你可以在<strong>请求</strong>或者<strong>响应</strong>被 then 或者 catch 处理之前对他们进行拦截。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//添加一个请求拦截器</span><br><span class=\"line\">axios.interceptors.request.use(function(config)&#123;</span><br><span class=\"line\">    //在请求发送之前做一些事</span><br><span class=\"line\">    return config;</span><br><span class=\"line\">&#125;,function(error)&#123;</span><br><span class=\"line\">    //当出现请求错误是做一些事</span><br><span class=\"line\">    return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//添加一个返回拦截器</span><br><span class=\"line\">axios.interceptors.response.use(function(response)&#123;</span><br><span class=\"line\">    //对返回的数据进行一些处理</span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;,function(error)&#123;</span><br><span class=\"line\">    //对返回的错误进行一些处理</span><br><span class=\"line\">    return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>用 eject 移除拦截器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br><span class=\"line\">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"axios-如何获取-cookie\"><a href=\"#axios-如何获取-cookie\" class=\"headerlink\" title=\"axios 如何获取 cookie\"></a>axios 如何获取 cookie</h2><p>axios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\">axios.defaults.withCredentials=true; //让ajax携带cookie</span><br><span class=\"line\">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure></p>\n<p>通过js原生接口来获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let allCookies = document.cookie</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1><h2 id=\"Vue-js-特性：\"><a href=\"#Vue-js-特性：\" class=\"headerlink\" title=\"Vue.js 特性：\"></a>Vue.js 特性：</h2><p>1.轻量级<br>2.双向数据绑定<br>3.指令<br>4.组件化</p>\n<h2 id=\"什么是-MVVM\"><a href=\"#什么是-MVVM\" class=\"headerlink\" title=\"什么是 MVVM\"></a>什么是 MVVM</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVC =&gt; MVP =&gt; MVVM</span><br><span class=\"line\">// 视图层和数据层的双向绑定</span><br><span class=\"line\">View &lt;=&gt; ViewModel &lt;=&gt; Model</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n</li>\n<li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>\n</li>\n<li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n</li>\n</ol>\n<h2 id=\"Vue-js-的优点\"><a href=\"#Vue-js-的优点\" class=\"headerlink\" title=\"Vue.js 的优点\"></a>Vue.js 的优点</h2><ol>\n<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>\n<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>\n<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>\n<li>易用灵活高效</li>\n</ol>\n<h2 id=\"Vue-组件是什么\"><a href=\"#Vue-组件是什么\" class=\"headerlink\" title=\"Vue 组件是什么\"></a>Vue 组件是什么</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p>\n<h1 id=\"Vue-cli\"><a href=\"#Vue-cli\" class=\"headerlink\" title=\"Vue-cli\"></a>Vue-cli</h1><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。</p>\n<h2 id=\"Vue-脚手架-3-x-以上版本使用\"><a href=\"#Vue-脚手架-3-x-以上版本使用\" class=\"headerlink\" title=\"Vue 脚手架 3.x 以上版本使用\"></a>Vue 脚手架 3.x 以上版本使用</h2><p>全局安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn global add @vue/cli</span><br></pre></td></tr></table></figure></p>\n<p>快速原型开发<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure></p>\n<p>创建项目<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create hello-world</span><br><span class=\"line\">// 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令</span><br><span class=\"line\">winpty vue.cmd create hello-world</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hello-world</span><br></pre></td></tr></table></figure>\n<p>Project setup<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn install</span><br></pre></td></tr></table></figure></p>\n<p>（以下命令 run 可以省略）<br>Compiles and hot-reloads for development<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run serve</span><br></pre></td></tr></table></figure></p>\n<p>Compiles and minifies for production<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run build</span><br></pre></td></tr></table></figure></p>\n<p>Run your tests<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run test</span><br></pre></td></tr></table></figure></p>\n<p>Lints and fixes files<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn run lint</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vuecli-3-x-版本-上图-与-2-x-初始化目录对比\"><a href=\"#Vuecli-3-x-版本-上图-与-2-x-初始化目录对比\" class=\"headerlink\" title=\"Vuecli 3.x 版本(上图)与 2.x 初始化目录对比\"></a>Vuecli 3.x 版本(上图)与 2.x 初始化目录对比</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"Vue-Router\"><a href=\"#Vue-Router\" class=\"headerlink\" title=\"Vue Router\"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官方的路由管理器。<br>安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router</span><br></pre></td></tr></table></figure></p>\n<p>引用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import VueRouter from &apos;vue-router&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p>\n<p>配置路由文件，并在vue实例中注入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes:[&#123;</span><br><span class=\"line\">    path:&apos;/user/:userId&apos;, // 指定要跳转的路径</span><br><span class=\"line\">    name: &apos;user&apos;, // 命名路由，便于路由跳转</span><br><span class=\"line\">    component: User// 指定要跳转的组件</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">const User = (&#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"确定视图加载的位置\"><a href=\"#确定视图加载的位置\" class=\"headerlink\" title=\"确定视图加载的位置\"></a>确定视图加载的位置</h2><p>视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &apos;/&apos;,</span><br><span class=\"line\">      components: &#123; // 同个路由，多个视图就需要多个组件,components 要有(s)</span><br><span class=\"line\">        default: Foo,</span><br><span class=\"line\">        a: Bar</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现路由跳转\"><a href=\"#实现路由跳转\" class=\"headerlink\" title=\"实现路由跳转\"></a>实现路由跳转</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; // 路由导航到 /user/123</span><br></pre></td></tr></table></figure>\n<p>等同于代码调用 router.push()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 编程式导航</span><br><span class=\"line\">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) // 路由导航到 /user/123</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"路由传参\"><a href=\"#路由传参\" class=\"headerlink\" title=\"路由传参\"></a>路由传参</h2><p>使用动态路由参数，以冒号开头<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    // 动态路径参数 以冒号开头</span><br><span class=\"line\">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p>\n<p>当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"响应路由参数变化\"><a href=\"#响应路由参数变化\" class=\"headerlink\" title=\"响应路由参数变化\"></a>响应路由参数变化</h2><p>动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 <strong>watch</strong> (监测变化) $route 对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;...&apos;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    &apos;$route&apos; (to, from) &#123;</span><br><span class=\"line\">      // 对路由变化作出响应...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者使用 <strong>beforeRouteUpdate</strong> 导航守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &apos;...&apos;,</span><br><span class=\"line\">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class=\"line\">    // react to route changes...</span><br><span class=\"line\">    // don&apos;t forget to call next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由组件参数解耦\"><a href=\"#路由组件参数解耦\" class=\"headerlink\" title=\"路由组件参数解耦\"></a>路由组件参数解耦</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  props: [&apos;id&apos;],</span><br><span class=\"line\">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &apos;/user/:id&apos;,</span><br><span class=\"line\">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class=\"line\">      props: &#123; default: true, sidebar: false &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>props 有三种模式：布尔模式、对象模式、函数模式</p>\n<h1 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h1><p>Vuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<h2 id=\"在-store-存储-内有下列核心概念\"><a href=\"#在-store-存储-内有下列核心概念\" class=\"headerlink\" title=\"在 store (存储)内有下列核心概念\"></a>在 store (存储)内有下列核心概念</h2><p><strong>State()：核心原始数据</strong> 展示<br><strong>Getter：计算属性，根据所依赖的数据的变化计算自身变化</strong> 存储<br><strong>Mutation(转变)：提交 mutation 才能改变存储状态</strong><br><strong>Action：</strong>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br><strong>Module：可以将将 store 分割</strong><br>一般放在 state 文件夹下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"vuex状态管理的流程\"><a href=\"#vuex状态管理的流程\" class=\"headerlink\" title=\"vuex状态管理的流程\"></a>vuex状态管理的流程</h2><p>view =&gt; actions =&gt; mutations =&gt; state =&gt; view</p>\n<h2 id=\"核心概念详解\"><a href=\"#核心概念详解\" class=\"headerlink\" title=\"核心概念详解\"></a>核心概念详解</h2><h3 id=\"state：记录所有公共数据状态的对象\"><a href=\"#state：记录所有公共数据状态的对象\" class=\"headerlink\" title=\"state：记录所有公共数据状态的对象\"></a>state：记录所有公共数据状态的对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组件如何获取</span><br><span class=\"line\">this.$store.state.XXX</span><br><span class=\"line\">// 此处的 XXX 是 state 内定义的数据状态的键名</span><br></pre></td></tr></table></figure>\n<h3 id=\"mutations：包含所有-操作数据状态的方法-的对象\"><a href=\"#mutations：包含所有-操作数据状态的方法-的对象\" class=\"headerlink\" title=\"mutations：包含所有 操作数据状态的方法 的对象\"></a>mutations：包含所有 操作数据状态的方法 的对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组件如何调用</span><br><span class=\"line\">this.$store.commit(XXX)</span><br><span class=\"line\">// 此处的 XXX是 mutations 中定义的方法名</span><br></pre></td></tr></table></figure>\n<h3 id=\"actions：用于操作-mutations-内方法-的对象\"><a href=\"#actions：用于操作-mutations-内方法-的对象\" class=\"headerlink\" title=\"actions：用于操作 mutations 内方法 的对象\"></a>actions：用于操作 mutations 内方法 的对象</h3><p>actions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如何调用</span><br><span class=\"line\">this.$store.dispatch(XXX)</span><br><span class=\"line\">// 此处的XXX是你在actions中定义的方法名</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"getters：定义状态内容的方法-的对象\"><a href=\"#getters：定义状态内容的方法-的对象\" class=\"headerlink\" title=\"getters：定义状态内容的方法 的对象\"></a>getters：定义状态内容的方法 的对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.getters.XXX</span><br><span class=\"line\">// 此处的XXX是你在getters里定义的方法名</span><br></pre></td></tr></table></figure>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。<br>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>从 node.js 发出 http 请求</li>\n<li>支持 Promise API拦截</li>\n<li>请求和响应转换</li>\n<li>请求和响应数据取消</li>\n<li>请求自动转换JSON数据</li>\n<li>客户端支持防止 CSRF/XSRF</li>\n</ul>\n<ol>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install axios</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入加载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将axios全局挂载到 Vue 原型上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"设置全局-axios-默认值\"><a href=\"#设置全局-axios-默认值\" class=\"headerlink\" title=\"设置全局 axios 默认值\"></a>设置全局 axios 默认值</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置基础路径，一般为后端接口线上地址根路径</span><br><span class=\"line\">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class=\"line\">// 设置默认 token</span><br><span class=\"line\">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class=\"line\">// 默认 POST 请求</span><br><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"axios-的-url-有两种传递参数的形式\"><a href=\"#axios-的-url-有两种传递参数的形式\" class=\"headerlink\" title=\"axios 的 url 有两种传递参数的形式\"></a>axios 的 url 有两种传递参数的形式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一种 对象形式</span><br><span class=\"line\">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">// 如果只有一个参数，可以省略 params</span><br><span class=\"line\">this.$http.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">  &#125;) </span><br><span class=\"line\">--------------------------------- </span><br><span class=\"line\">// 第二种 形式</span><br><span class=\"line\">this.$http.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"POST-传递数据有两种格式：\"><a href=\"#POST-传递数据有两种格式：\" class=\"headerlink\" title=\"POST 传递数据有两种格式：\"></a>POST 传递数据有两种格式：</h2><ol>\n<li>form­-data ?page=1&amp;limit=48</li>\n<li>x-­www­-form-­urlencoded { page: 1,limit: 10 }</li>\n</ol>\n<p><strong>在 axios 中，post 请求接收的参数必须是 form­-data 形式<br>如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$http.post(&apos;/user&apos;, qs.stringify(&#123;</span><br><span class=\"line\">   ID: 12345</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实现增删改查\"><a href=\"#实现增删改查\" class=\"headerlink\" title=\"实现增删改查\"></a>实现增删改查</h2><h3 id=\"发起-GET-请求：查\"><a href=\"#发起-GET-请求：查\" class=\"headerlink\" title=\"发起 GET 请求：查\"></a>发起 GET 请求：查</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const axios = require(&apos;axios&apos;) // 下同省略</span><br><span class=\"line\"></span><br><span class=\"line\">//发起一个user请求，参数为给定的ID</span><br><span class=\"line\">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class=\"line\">  .then((response) =&gt; &#123;</span><br><span class=\"line\">    console.log(response)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .catch((error) =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"发起-POST-请求：增\"><a href=\"#发起-POST-请求：增\" class=\"headerlink\" title=\"发起 POST 请求：增\"></a>发起 POST 请求：增</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(&apos;/user&apos;, &#123;</span><br><span class=\"line\">  firstName: &apos;yuanda&apos;,</span><br><span class=\"line\">  lastName: &apos;zhou&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then((response) =&gt; &#123;</span><br><span class=\"line\">    console.log(response)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function(error)&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.request(config)</span><br><span class=\"line\">axios.get(url[,config])</span><br><span class=\"line\">axios.delete(url[,config]) // 删除</span><br><span class=\"line\">axios.head(url[,config])</span><br><span class=\"line\">axios.options(url[,config])</span><br><span class=\"line\">axios.post(url[,data[,config]])</span><br><span class=\"line\">axios.put(url[,data[,config]]) // 改</span><br><span class=\"line\">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>\n<p>PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</p>\n<h2 id=\"并发请求\"><a href=\"#并发请求\" class=\"headerlink\" title=\"并发请求\"></a>并发请求</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getUserAccount()&#123;</span><br><span class=\"line\">    return axios.get(&apos;/user/12345&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getUserPermissions()&#123;</span><br><span class=\"line\">    return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class=\"line\">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class=\"line\">        //两个请求现在都完成</span><br><span class=\"line\">    &#125;));</span><br></pre></td></tr></table></figure>\n<p>axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。</p>\n<h2 id=\"拦截器-interceptors\"><a href=\"#拦截器-interceptors\" class=\"headerlink\" title=\"拦截器 interceptors\"></a>拦截器 interceptors</h2><p>你可以在<strong>请求</strong>或者<strong>响应</strong>被 then 或者 catch 处理之前对他们进行拦截。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//添加一个请求拦截器</span><br><span class=\"line\">axios.interceptors.request.use(function(config)&#123;</span><br><span class=\"line\">    //在请求发送之前做一些事</span><br><span class=\"line\">    return config;</span><br><span class=\"line\">&#125;,function(error)&#123;</span><br><span class=\"line\">    //当出现请求错误是做一些事</span><br><span class=\"line\">    return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//添加一个返回拦截器</span><br><span class=\"line\">axios.interceptors.response.use(function(response)&#123;</span><br><span class=\"line\">    //对返回的数据进行一些处理</span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;,function(error)&#123;</span><br><span class=\"line\">    //对返回的错误进行一些处理</span><br><span class=\"line\">    return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>用 eject 移除拦截器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);</span><br><span class=\"line\">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"axios-如何获取-cookie\"><a href=\"#axios-如何获取-cookie\" class=\"headerlink\" title=\"axios 如何获取 cookie\"></a>axios 如何获取 cookie</h2><p>axios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\">axios.defaults.withCredentials=true; //让ajax携带cookie</span><br><span class=\"line\">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure></p>\n<p>通过js原生接口来获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let allCookies = document.cookie</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Web 服务器","date":"2018-08-11T09:21:53.000Z","_content":"\n[从输入 URL 到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)\n\n## 什么是 Web 服务器\n\nWeb 服务器就是一个软件，这个软件监听某个端口。当一个 HTTP 请求到达这个端口后这个软件会接收到，根据请求的 url 和参数发送响应数据，这些数据可以是：1. 本机文件； 2. 通过可执行程序从数据库获取数据后组装的页面\n\n**让我们用 node 搭建一个简单的服务器**\n\n[代码相关 HTTP 文档](https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_request_end_data_encoding_callback) 遇到相应 API 再看，不用一个个看，看不完的\n新建一个名为 server1.js 的代码\n\n```\n//通过 require('http') 来让服务器支持HTTP协议\nvar http = require('http')\n//创建服务器请求和响应的函数\nvar server = http.createServer(function(request, response){\n  //设置一个2秒的计时器\n  setTimeout(function(){\n    //.setHeader设置文件类型编码等\n    response.setHeader('Content-Type','text/html; charset=utf-8')\n    //.writeHead返回状态码\n    response.writeHead(404, 'Not Found')\n    response.write('<html><head><meta charset=\"gbk\" /></head>')\n    response.write('<body>')\n    response.write('<h1>你好</h1>')\n    response.write('</body>')\n    response.write('</html>')\n    //事件'关闭'\n    response.end()\n  },2000);\n})\nconsole.log('open http://localhost:8080')\n//listen(端口)产生HTTP服务器监听链接\nserver.listen(8080)\n```\n\n用命令行打开 server1.js 所在目录，node 开启服务器![](https://upload-images.jianshu.io/upload_images/7094266-59e81063d440a373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n用浏览器打开http://localhost:8080，2秒后就返回页面拉![](https://upload-images.jianshu.io/upload_images/7094266-7bf0b304614ce83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n至此，你已经用 node.js 完成了一个简单的服务器搭建，并用浏览器以http://localhost:8080向你的服务器发起请求并成功得到响应了\n\n### 静态服务器\n\n页面不会变化，展示静态页面![image](http://upload-images.jianshu.io/upload_images/7094266-19e00ec3472ba838.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**同样用 node 尝试一个简单的静态服务器**\n\n```\nvar http = require('http')\n//用来读取内容\nvar fs = require('fs')\n\nvar server = http.createServer(function(req, res){\n  try{\n    //.readFileSync 用于同步读取文件:当前目录下的 hi 文件 下的 目标\n    var fileContent = fs.readFileSync(__dirname + '/hi' + req.url)\n    res.write(fileContent)\n  }catch(e){\n    res.writeHead(404, 'not found')\n  }\n  res.end()\n})\n\nserver.listen(8080)\nconsole.log('visit http://localhost:8080' )\n```\n\n我在 hi 文件下新建了一个 html 文件![](https://upload-images.jianshu.io/upload_images/7094266-f1c53aa1769fd9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n命令行![](https://upload-images.jianshu.io/upload_images/7094266-9dcba127af327a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这次输入的就是http://localhost:8080/index.html![](https://upload-images.jianshu.io/upload_images/7094266-986cc0ea222a9586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)成功拉\n\n### 动态服务器\n\n有个动态软件，可执行动态页面![image](http://upload-images.jianshu.io/upload_images/7094266-47d1ffd2b592f7e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这一部分涉及的知识就多了，无法用简单的小示例完整展现，后续应该会有相关博客\n\n### 以上例子均为 url 同源\n\n当浏览器向服务器发送请求时，会遇到**不同源**的情况：（有关浏览器同源的详细概念可以参考[阮一峰博客](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)）\n不同源两种情况下的规避方法： 1.服务器同意请求：\nJSONP：需要后端支持（附上我学习 JSONP 的相关[博客](https://www.jianshu.com/p/2a2fe02917e7)）\nCORS(Cross-Origin Resource Sharing)：跨域资源共享（AJAX 相关[博客](https://www.jianshu.com/p/4591a66c50f5)） 2.服务器不同意请求：\n利用服务器中转：自己搭建一个服务器，由于服务器访问服务器没有同源要求，可直接访问，自己服务器作为中转，把自己服务器变为情况 1，即可通过访问自己服务器再访问到其他服务器相关内容\n这方面的知识同样可以参考\n[饥人谷博客-跨域](http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/%E8%B7%A8%E5%9F%9F.html)\n\n---\n\n本文仅供个人学习使用\n\n相关参考及资源链接已在文中标注\n","source":"_posts/Web-服务器.md","raw":"---\ntitle: Web 服务器\ndate: 2018-08-11 17:21:53\ntags: Node.js\n---\n\n[从输入 URL 到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)\n\n## 什么是 Web 服务器\n\nWeb 服务器就是一个软件，这个软件监听某个端口。当一个 HTTP 请求到达这个端口后这个软件会接收到，根据请求的 url 和参数发送响应数据，这些数据可以是：1. 本机文件； 2. 通过可执行程序从数据库获取数据后组装的页面\n\n**让我们用 node 搭建一个简单的服务器**\n\n[代码相关 HTTP 文档](https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_request_end_data_encoding_callback) 遇到相应 API 再看，不用一个个看，看不完的\n新建一个名为 server1.js 的代码\n\n```\n//通过 require('http') 来让服务器支持HTTP协议\nvar http = require('http')\n//创建服务器请求和响应的函数\nvar server = http.createServer(function(request, response){\n  //设置一个2秒的计时器\n  setTimeout(function(){\n    //.setHeader设置文件类型编码等\n    response.setHeader('Content-Type','text/html; charset=utf-8')\n    //.writeHead返回状态码\n    response.writeHead(404, 'Not Found')\n    response.write('<html><head><meta charset=\"gbk\" /></head>')\n    response.write('<body>')\n    response.write('<h1>你好</h1>')\n    response.write('</body>')\n    response.write('</html>')\n    //事件'关闭'\n    response.end()\n  },2000);\n})\nconsole.log('open http://localhost:8080')\n//listen(端口)产生HTTP服务器监听链接\nserver.listen(8080)\n```\n\n用命令行打开 server1.js 所在目录，node 开启服务器![](https://upload-images.jianshu.io/upload_images/7094266-59e81063d440a373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n用浏览器打开http://localhost:8080，2秒后就返回页面拉![](https://upload-images.jianshu.io/upload_images/7094266-7bf0b304614ce83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n至此，你已经用 node.js 完成了一个简单的服务器搭建，并用浏览器以http://localhost:8080向你的服务器发起请求并成功得到响应了\n\n### 静态服务器\n\n页面不会变化，展示静态页面![image](http://upload-images.jianshu.io/upload_images/7094266-19e00ec3472ba838.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**同样用 node 尝试一个简单的静态服务器**\n\n```\nvar http = require('http')\n//用来读取内容\nvar fs = require('fs')\n\nvar server = http.createServer(function(req, res){\n  try{\n    //.readFileSync 用于同步读取文件:当前目录下的 hi 文件 下的 目标\n    var fileContent = fs.readFileSync(__dirname + '/hi' + req.url)\n    res.write(fileContent)\n  }catch(e){\n    res.writeHead(404, 'not found')\n  }\n  res.end()\n})\n\nserver.listen(8080)\nconsole.log('visit http://localhost:8080' )\n```\n\n我在 hi 文件下新建了一个 html 文件![](https://upload-images.jianshu.io/upload_images/7094266-f1c53aa1769fd9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n命令行![](https://upload-images.jianshu.io/upload_images/7094266-9dcba127af327a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这次输入的就是http://localhost:8080/index.html![](https://upload-images.jianshu.io/upload_images/7094266-986cc0ea222a9586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)成功拉\n\n### 动态服务器\n\n有个动态软件，可执行动态页面![image](http://upload-images.jianshu.io/upload_images/7094266-47d1ffd2b592f7e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这一部分涉及的知识就多了，无法用简单的小示例完整展现，后续应该会有相关博客\n\n### 以上例子均为 url 同源\n\n当浏览器向服务器发送请求时，会遇到**不同源**的情况：（有关浏览器同源的详细概念可以参考[阮一峰博客](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)）\n不同源两种情况下的规避方法： 1.服务器同意请求：\nJSONP：需要后端支持（附上我学习 JSONP 的相关[博客](https://www.jianshu.com/p/2a2fe02917e7)）\nCORS(Cross-Origin Resource Sharing)：跨域资源共享（AJAX 相关[博客](https://www.jianshu.com/p/4591a66c50f5)） 2.服务器不同意请求：\n利用服务器中转：自己搭建一个服务器，由于服务器访问服务器没有同源要求，可直接访问，自己服务器作为中转，把自己服务器变为情况 1，即可通过访问自己服务器再访问到其他服务器相关内容\n这方面的知识同样可以参考\n[饥人谷博客-跨域](http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/%E8%B7%A8%E5%9F%9F.html)\n\n---\n\n本文仅供个人学习使用\n\n相关参考及资源链接已在文中标注\n","slug":"Web-服务器","published":1,"updated":"2020-03-28T17:37:19.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyw000gws992qzx0e13","content":"<p><a href=\"https://segmentfault.com/a/1190000006879700\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载发生了什么</a></p>\n<h2 id=\"什么是-Web-服务器\"><a href=\"#什么是-Web-服务器\" class=\"headerlink\" title=\"什么是 Web 服务器\"></a>什么是 Web 服务器</h2><p>Web 服务器就是一个软件，这个软件监听某个端口。当一个 HTTP 请求到达这个端口后这个软件会接收到，根据请求的 url 和参数发送响应数据，这些数据可以是：1. 本机文件； 2. 通过可执行程序从数据库获取数据后组装的页面</p>\n<p><strong>让我们用 node 搭建一个简单的服务器</strong></p>\n<p><a href=\"https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_request_end_data_encoding_callback\" target=\"_blank\" rel=\"noopener\">代码相关 HTTP 文档</a> 遇到相应 API 再看，不用一个个看，看不完的<br>新建一个名为 server1.js 的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过 require(&apos;http&apos;) 来让服务器支持HTTP协议</span><br><span class=\"line\">var http = require(&apos;http&apos;)</span><br><span class=\"line\">//创建服务器请求和响应的函数</span><br><span class=\"line\">var server = http.createServer(function(request, response)&#123;</span><br><span class=\"line\">  //设置一个2秒的计时器</span><br><span class=\"line\">  setTimeout(function()&#123;</span><br><span class=\"line\">    //.setHeader设置文件类型编码等</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;,&apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    //.writeHead返回状态码</span><br><span class=\"line\">    response.writeHead(404, &apos;Not Found&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;gbk&quot; /&gt;&lt;/head&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;body&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;/body&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;/html&gt;&apos;)</span><br><span class=\"line\">    //事件&apos;关闭&apos;</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;,2000);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;open http://localhost:8080&apos;)</span><br><span class=\"line\">//listen(端口)产生HTTP服务器监听链接</span><br><span class=\"line\">server.listen(8080)</span><br></pre></td></tr></table></figure>\n<p>用命令行打开 server1.js 所在目录，node 开启服务器<img src=\"https://upload-images.jianshu.io/upload_images/7094266-59e81063d440a373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>用浏览器打开<a href=\"http://localhost:8080，2秒后就返回页面拉![](https://upload-images.jianshu.io/upload_images/7094266-7bf0b304614ce83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\" target=\"_blank\" rel=\"noopener\">http://localhost:8080，2秒后就返回页面拉![](https://upload-images.jianshu.io/upload_images/7094266-7bf0b304614ce83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</a><br>至此，你已经用 node.js 完成了一个简单的服务器搭建，并用浏览器以<a href=\"http://localhost:8080向你的服务器发起请求并成功得到响应了\" target=\"_blank\" rel=\"noopener\">http://localhost:8080向你的服务器发起请求并成功得到响应了</a></p>\n<h3 id=\"静态服务器\"><a href=\"#静态服务器\" class=\"headerlink\" title=\"静态服务器\"></a>静态服务器</h3><p>页面不会变化，展示静态页面<img src=\"http://upload-images.jianshu.io/upload_images/7094266-19e00ec3472ba838.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br><strong>同样用 node 尝试一个简单的静态服务器</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http = require(&apos;http&apos;)</span><br><span class=\"line\">//用来读取内容</span><br><span class=\"line\">var fs = require(&apos;fs&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var server = http.createServer(function(req, res)&#123;</span><br><span class=\"line\">  try&#123;</span><br><span class=\"line\">    //.readFileSync 用于同步读取文件:当前目录下的 hi 文件 下的 目标</span><br><span class=\"line\">    var fileContent = fs.readFileSync(__dirname + &apos;/hi&apos; + req.url)</span><br><span class=\"line\">    res.write(fileContent)</span><br><span class=\"line\">  &#125;catch(e)&#123;</span><br><span class=\"line\">    res.writeHead(404, &apos;not found&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res.end()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080)</span><br><span class=\"line\">console.log(&apos;visit http://localhost:8080&apos; )</span><br></pre></td></tr></table></figure>\n<p>我在 hi 文件下新建了一个 html 文件<img src=\"https://upload-images.jianshu.io/upload_images/7094266-f1c53aa1769fd9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>命令行<img src=\"https://upload-images.jianshu.io/upload_images/7094266-9dcba127af327a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这次输入的就是<a href=\"http://localhost:8080/index.html![](https://upload-images.jianshu.io/upload_images/7094266-986cc0ea222a9586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)成功拉\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/index.html![](https://upload-images.jianshu.io/upload_images/7094266-986cc0ea222a9586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)成功拉</a></p>\n<h3 id=\"动态服务器\"><a href=\"#动态服务器\" class=\"headerlink\" title=\"动态服务器\"></a>动态服务器</h3><p>有个动态软件，可执行动态页面<img src=\"http://upload-images.jianshu.io/upload_images/7094266-47d1ffd2b592f7e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>这一部分涉及的知识就多了，无法用简单的小示例完整展现，后续应该会有相关博客</p>\n<h3 id=\"以上例子均为-url-同源\"><a href=\"#以上例子均为-url-同源\" class=\"headerlink\" title=\"以上例子均为 url 同源\"></a>以上例子均为 url 同源</h3><p>当浏览器向服务器发送请求时，会遇到<strong>不同源</strong>的情况：（有关浏览器同源的详细概念可以参考<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">阮一峰博客</a>）<br>不同源两种情况下的规避方法： 1.服务器同意请求：<br>JSONP：需要后端支持（附上我学习 JSONP 的相关<a href=\"https://www.jianshu.com/p/2a2fe02917e7\" target=\"_blank\" rel=\"noopener\">博客</a>）<br>CORS(Cross-Origin Resource Sharing)：跨域资源共享（AJAX 相关<a href=\"https://www.jianshu.com/p/4591a66c50f5\" target=\"_blank\" rel=\"noopener\">博客</a>） 2.服务器不同意请求：<br>利用服务器中转：自己搭建一个服务器，由于服务器访问服务器没有同源要求，可直接访问，自己服务器作为中转，把自己服务器变为情况 1，即可通过访问自己服务器再访问到其他服务器相关内容<br>这方面的知识同样可以参考<br><a href=\"http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/%E8%B7%A8%E5%9F%9F.html\" target=\"_blank\" rel=\"noopener\">饥人谷博客-跨域</a></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n<p>相关参考及资源链接已在文中标注</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://segmentfault.com/a/1190000006879700\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载发生了什么</a></p>\n<h2 id=\"什么是-Web-服务器\"><a href=\"#什么是-Web-服务器\" class=\"headerlink\" title=\"什么是 Web 服务器\"></a>什么是 Web 服务器</h2><p>Web 服务器就是一个软件，这个软件监听某个端口。当一个 HTTP 请求到达这个端口后这个软件会接收到，根据请求的 url 和参数发送响应数据，这些数据可以是：1. 本机文件； 2. 通过可执行程序从数据库获取数据后组装的页面</p>\n<p><strong>让我们用 node 搭建一个简单的服务器</strong></p>\n<p><a href=\"https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_request_end_data_encoding_callback\" target=\"_blank\" rel=\"noopener\">代码相关 HTTP 文档</a> 遇到相应 API 再看，不用一个个看，看不完的<br>新建一个名为 server1.js 的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过 require(&apos;http&apos;) 来让服务器支持HTTP协议</span><br><span class=\"line\">var http = require(&apos;http&apos;)</span><br><span class=\"line\">//创建服务器请求和响应的函数</span><br><span class=\"line\">var server = http.createServer(function(request, response)&#123;</span><br><span class=\"line\">  //设置一个2秒的计时器</span><br><span class=\"line\">  setTimeout(function()&#123;</span><br><span class=\"line\">    //.setHeader设置文件类型编码等</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;,&apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    //.writeHead返回状态码</span><br><span class=\"line\">    response.writeHead(404, &apos;Not Found&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;gbk&quot; /&gt;&lt;/head&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;body&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;h1&gt;你好&lt;/h1&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;/body&gt;&apos;)</span><br><span class=\"line\">    response.write(&apos;&lt;/html&gt;&apos;)</span><br><span class=\"line\">    //事件&apos;关闭&apos;</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;,2000);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;open http://localhost:8080&apos;)</span><br><span class=\"line\">//listen(端口)产生HTTP服务器监听链接</span><br><span class=\"line\">server.listen(8080)</span><br></pre></td></tr></table></figure>\n<p>用命令行打开 server1.js 所在目录，node 开启服务器<img src=\"https://upload-images.jianshu.io/upload_images/7094266-59e81063d440a373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>用浏览器打开<a href=\"http://localhost:8080，2秒后就返回页面拉![](https://upload-images.jianshu.io/upload_images/7094266-7bf0b304614ce83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\" target=\"_blank\" rel=\"noopener\">http://localhost:8080，2秒后就返回页面拉![](https://upload-images.jianshu.io/upload_images/7094266-7bf0b304614ce83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</a><br>至此，你已经用 node.js 完成了一个简单的服务器搭建，并用浏览器以<a href=\"http://localhost:8080向你的服务器发起请求并成功得到响应了\" target=\"_blank\" rel=\"noopener\">http://localhost:8080向你的服务器发起请求并成功得到响应了</a></p>\n<h3 id=\"静态服务器\"><a href=\"#静态服务器\" class=\"headerlink\" title=\"静态服务器\"></a>静态服务器</h3><p>页面不会变化，展示静态页面<img src=\"http://upload-images.jianshu.io/upload_images/7094266-19e00ec3472ba838.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br><strong>同样用 node 尝试一个简单的静态服务器</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http = require(&apos;http&apos;)</span><br><span class=\"line\">//用来读取内容</span><br><span class=\"line\">var fs = require(&apos;fs&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var server = http.createServer(function(req, res)&#123;</span><br><span class=\"line\">  try&#123;</span><br><span class=\"line\">    //.readFileSync 用于同步读取文件:当前目录下的 hi 文件 下的 目标</span><br><span class=\"line\">    var fileContent = fs.readFileSync(__dirname + &apos;/hi&apos; + req.url)</span><br><span class=\"line\">    res.write(fileContent)</span><br><span class=\"line\">  &#125;catch(e)&#123;</span><br><span class=\"line\">    res.writeHead(404, &apos;not found&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res.end()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080)</span><br><span class=\"line\">console.log(&apos;visit http://localhost:8080&apos; )</span><br></pre></td></tr></table></figure>\n<p>我在 hi 文件下新建了一个 html 文件<img src=\"https://upload-images.jianshu.io/upload_images/7094266-f1c53aa1769fd9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>命令行<img src=\"https://upload-images.jianshu.io/upload_images/7094266-9dcba127af327a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这次输入的就是<a href=\"http://localhost:8080/index.html![](https://upload-images.jianshu.io/upload_images/7094266-986cc0ea222a9586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)成功拉\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/index.html![](https://upload-images.jianshu.io/upload_images/7094266-986cc0ea222a9586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)成功拉</a></p>\n<h3 id=\"动态服务器\"><a href=\"#动态服务器\" class=\"headerlink\" title=\"动态服务器\"></a>动态服务器</h3><p>有个动态软件，可执行动态页面<img src=\"http://upload-images.jianshu.io/upload_images/7094266-47d1ffd2b592f7e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"><br>这一部分涉及的知识就多了，无法用简单的小示例完整展现，后续应该会有相关博客</p>\n<h3 id=\"以上例子均为-url-同源\"><a href=\"#以上例子均为-url-同源\" class=\"headerlink\" title=\"以上例子均为 url 同源\"></a>以上例子均为 url 同源</h3><p>当浏览器向服务器发送请求时，会遇到<strong>不同源</strong>的情况：（有关浏览器同源的详细概念可以参考<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">阮一峰博客</a>）<br>不同源两种情况下的规避方法： 1.服务器同意请求：<br>JSONP：需要后端支持（附上我学习 JSONP 的相关<a href=\"https://www.jianshu.com/p/2a2fe02917e7\" target=\"_blank\" rel=\"noopener\">博客</a>）<br>CORS(Cross-Origin Resource Sharing)：跨域资源共享（AJAX 相关<a href=\"https://www.jianshu.com/p/4591a66c50f5\" target=\"_blank\" rel=\"noopener\">博客</a>） 2.服务器不同意请求：<br>利用服务器中转：自己搭建一个服务器，由于服务器访问服务器没有同源要求，可直接访问，自己服务器作为中转，把自己服务器变为情况 1，即可通过访问自己服务器再访问到其他服务器相关内容<br>这方面的知识同样可以参考<br><a href=\"http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Javascript/%E8%B7%A8%E5%9F%9F.html\" target=\"_blank\" rel=\"noopener\">饥人谷博客-跨域</a></p>\n<hr>\n<p>本文仅供个人学习使用</p>\n<p>相关参考及资源链接已在文中标注</p>\n"},{"title":"hash 模式和 history 模式小记","date":"2019-11-28T13:55:33.000Z","_content":"\n# 前端路由\n\n随着 ajax 的流行，异步数据请求体验极具提升，用户得以在不刷新浏览器的情况下进行页面交互，而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互时无刷新，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。\n\n# 前端路由常用的两种模式\n\n类似于服务端路由解析对应的 url 路径，返回对应的页面/资源的方式，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。\n这样自然 url 每次变化的时候，都会造成页面的刷新。那么在改变 url 的情况下，如何保证页面的不刷新？\n\n## hash 模式\n\n在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：\n\n```html\nhttp://www.xxx.com/#/login\n```\n\n这种 # 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发[`window.onhashchange`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange)事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听 hashchange 来实现更新页面部分内容的操作：\n\n```\nfunction hashChanged() {\n   if (location.hash === \"#ada\") {\n        ada();\n    }\n}\nwindow.addEventListener('hashchange', hashChanged)\n```\n\n### 为什么改变 hash 不刷新页面？——[URL 的井号‘#’](http://www.ruanyifeng.com/blog/2011/03/url_hash.html)\n\n‘#’ 代表网页中的一个位置，它后面的字符，就是该位置的标识符，它只对浏览器有用，服务器不识别，因此 HTTP 请求不会包含 # (想要请求 url 包含 # ，可使用 [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)\n进行部分转义)\n\n`改变 hash ，只会让浏览器滚动到相应位置，不会重载网页`\n\n## history 模式\n\n2014 年后，HTML5 引入了  [history.pushState()](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)  和  [history.replaceState()](<https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_replaceState()_method>)  方法，它们分别可以添加和修改历史记录条目，通过这两个 API 可以改变 url 地址而无须重新加载页面。\n同时还有[`window.onpopstate`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate \"window.onpopstate是popstate事件在window对象上的事件处理程序.\")事件：\n在浏览器点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法) 可以触发 popstate 事件\n\n```\nfunction stateChange() {\n   // 一些 history 方法调用\n}\nwindow.addEventListener('popstate', stateChange)\n```\n\n通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。\n\n用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。**但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。**为了避免出现这种情况，history 模式需要服务器的支持，把所有路由都重定向到根页面。\n\n## hash 模式和 history 模式对比\n\n1.  无 # 的 history 模式更自然\n2.  history 模式需要 ie9 以上，相对于 hash 模式的 ie8 兼容性差\n3.  history 模式需服务器端配合，反过来说 hash 模式不支持服务端渲染\n\n## 控制 vue-router 内的自动降级\n\nvue-router 默认 hash 模式，且在 history 模式下当浏览器不支持 history.pushState 时默认回退到 hash 模式\n因此在 IE9 下的服务端渲染需要设置 fallback 为 false\n","source":"_posts/hash-模式和-history-模式小记.md","raw":"---\ntitle: hash 模式和 history 模式小记\ndate: 2019-11-28 21:55:33\ntags: 设计模式\n---\n\n# 前端路由\n\n随着 ajax 的流行，异步数据请求体验极具提升，用户得以在不刷新浏览器的情况下进行页面交互，而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互时无刷新，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。\n\n# 前端路由常用的两种模式\n\n类似于服务端路由解析对应的 url 路径，返回对应的页面/资源的方式，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。\n这样自然 url 每次变化的时候，都会造成页面的刷新。那么在改变 url 的情况下，如何保证页面的不刷新？\n\n## hash 模式\n\n在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：\n\n```html\nhttp://www.xxx.com/#/login\n```\n\n这种 # 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发[`window.onhashchange`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange)事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听 hashchange 来实现更新页面部分内容的操作：\n\n```\nfunction hashChanged() {\n   if (location.hash === \"#ada\") {\n        ada();\n    }\n}\nwindow.addEventListener('hashchange', hashChanged)\n```\n\n### 为什么改变 hash 不刷新页面？——[URL 的井号‘#’](http://www.ruanyifeng.com/blog/2011/03/url_hash.html)\n\n‘#’ 代表网页中的一个位置，它后面的字符，就是该位置的标识符，它只对浏览器有用，服务器不识别，因此 HTTP 请求不会包含 # (想要请求 url 包含 # ，可使用 [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)\n进行部分转义)\n\n`改变 hash ，只会让浏览器滚动到相应位置，不会重载网页`\n\n## history 模式\n\n2014 年后，HTML5 引入了  [history.pushState()](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)  和  [history.replaceState()](<https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_replaceState()_method>)  方法，它们分别可以添加和修改历史记录条目，通过这两个 API 可以改变 url 地址而无须重新加载页面。\n同时还有[`window.onpopstate`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate \"window.onpopstate是popstate事件在window对象上的事件处理程序.\")事件：\n在浏览器点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法) 可以触发 popstate 事件\n\n```\nfunction stateChange() {\n   // 一些 history 方法调用\n}\nwindow.addEventListener('popstate', stateChange)\n```\n\n通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。\n\n用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。**但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。**为了避免出现这种情况，history 模式需要服务器的支持，把所有路由都重定向到根页面。\n\n## hash 模式和 history 模式对比\n\n1.  无 # 的 history 模式更自然\n2.  history 模式需要 ie9 以上，相对于 hash 模式的 ie8 兼容性差\n3.  history 模式需服务器端配合，反过来说 hash 模式不支持服务端渲染\n\n## 控制 vue-router 内的自动降级\n\nvue-router 默认 hash 模式，且在 history 模式下当浏览器不支持 history.pushState 时默认回退到 hash 模式\n因此在 IE9 下的服务端渲染需要设置 fallback 为 false\n","slug":"hash-模式和-history-模式小记","published":1,"updated":"2020-04-03T16:34:47.433Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyx000hws99b2f79j4n","content":"<h1 id=\"前端路由\"><a href=\"#前端路由\" class=\"headerlink\" title=\"前端路由\"></a>前端路由</h1><p>随着 ajax 的流行，异步数据请求体验极具提升，用户得以在不刷新浏览器的情况下进行页面交互，而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互时无刷新，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</p>\n<h1 id=\"前端路由常用的两种模式\"><a href=\"#前端路由常用的两种模式\" class=\"headerlink\" title=\"前端路由常用的两种模式\"></a>前端路由常用的两种模式</h1><p>类似于服务端路由解析对应的 url 路径，返回对应的页面/资源的方式，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。<br>这样自然 url 每次变化的时候，都会造成页面的刷新。那么在改变 url 的情况下，如何保证页面的不刷新？</p>\n<h2 id=\"hash-模式\"><a href=\"#hash-模式\" class=\"headerlink\" title=\"hash 模式\"></a>hash 模式</h2><p>在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.xxx.com/#/login</span><br></pre></td></tr></table></figure>\n<p>这种 # 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange\" target=\"_blank\" rel=\"noopener\"><code>window.onhashchange</code></a>事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听 hashchange 来实现更新页面部分内容的操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hashChanged() &#123;</span><br><span class=\"line\">   if (location.hash === &quot;#ada&quot;) &#123;</span><br><span class=\"line\">        ada();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.addEventListener(&apos;hashchange&apos;, hashChanged)</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么改变-hash-不刷新页面？——URL-的井号‘-’\"><a href=\"#为什么改变-hash-不刷新页面？——URL-的井号‘-’\" class=\"headerlink\" title=\"为什么改变 hash 不刷新页面？——URL 的井号‘#’\"></a>为什么改变 hash 不刷新页面？——<a href=\"http://www.ruanyifeng.com/blog/2011/03/url_hash.html\" target=\"_blank\" rel=\"noopener\">URL 的井号‘#’</a></h3><p>‘#’ 代表网页中的一个位置，它后面的字符，就是该位置的标识符，它只对浏览器有用，服务器不识别，因此 HTTP 请求不会包含 # (想要请求 url 包含 # ，可使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" target=\"_blank\" rel=\"noopener\">encodeURIComponent()</a><br>进行部分转义)</p>\n<p><code>改变 hash ，只会让浏览器滚动到相应位置，不会重载网页</code></p>\n<h2 id=\"history-模式\"><a href=\"#history-模式\" class=\"headerlink\" title=\"history 模式\"></a>history 模式</h2><p>2014 年后，HTML5 引入了  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History/pushState\" target=\"_blank\" rel=\"noopener\">history.pushState()</a>  和  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_replaceState(\" target=\"_blank\" rel=\"noopener\">history.replaceState()</a>_method&gt;)  方法，它们分别可以添加和修改历史记录条目，通过这两个 API 可以改变 url 地址而无须重新加载页面。<br>同时还有<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate\" title=\"window.onpopstate是popstate事件在window对象上的事件处理程序.\" target=\"_blank\" rel=\"noopener\"><code>window.onpopstate</code></a>事件：<br>在浏览器点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法) 可以触发 popstate 事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function stateChange() &#123;</span><br><span class=\"line\">   // 一些 history 方法调用</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.addEventListener(&apos;popstate&apos;, stateChange)</span><br></pre></td></tr></table></figure>\n<p>通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。</p>\n<p>用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。<strong>但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。</strong>为了避免出现这种情况，history 模式需要服务器的支持，把所有路由都重定向到根页面。</p>\n<h2 id=\"hash-模式和-history-模式对比\"><a href=\"#hash-模式和-history-模式对比\" class=\"headerlink\" title=\"hash 模式和 history 模式对比\"></a>hash 模式和 history 模式对比</h2><ol>\n<li>无 # 的 history 模式更自然</li>\n<li>history 模式需要 ie9 以上，相对于 hash 模式的 ie8 兼容性差</li>\n<li>history 模式需服务器端配合，反过来说 hash 模式不支持服务端渲染</li>\n</ol>\n<h2 id=\"控制-vue-router-内的自动降级\"><a href=\"#控制-vue-router-内的自动降级\" class=\"headerlink\" title=\"控制 vue-router 内的自动降级\"></a>控制 vue-router 内的自动降级</h2><p>vue-router 默认 hash 模式，且在 history 模式下当浏览器不支持 history.pushState 时默认回退到 hash 模式<br>因此在 IE9 下的服务端渲染需要设置 fallback 为 false</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端路由\"><a href=\"#前端路由\" class=\"headerlink\" title=\"前端路由\"></a>前端路由</h1><p>随着 ajax 的流行，异步数据请求体验极具提升，用户得以在不刷新浏览器的情况下进行页面交互，而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互时无刷新，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</p>\n<h1 id=\"前端路由常用的两种模式\"><a href=\"#前端路由常用的两种模式\" class=\"headerlink\" title=\"前端路由常用的两种模式\"></a>前端路由常用的两种模式</h1><p>类似于服务端路由解析对应的 url 路径，返回对应的页面/资源的方式，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。<br>这样自然 url 每次变化的时候，都会造成页面的刷新。那么在改变 url 的情况下，如何保证页面的不刷新？</p>\n<h2 id=\"hash-模式\"><a href=\"#hash-模式\" class=\"headerlink\" title=\"hash 模式\"></a>hash 模式</h2><p>在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.xxx.com/#/login</span><br></pre></td></tr></table></figure>\n<p>这种 # 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange\" target=\"_blank\" rel=\"noopener\"><code>window.onhashchange</code></a>事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听 hashchange 来实现更新页面部分内容的操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hashChanged() &#123;</span><br><span class=\"line\">   if (location.hash === &quot;#ada&quot;) &#123;</span><br><span class=\"line\">        ada();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.addEventListener(&apos;hashchange&apos;, hashChanged)</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么改变-hash-不刷新页面？——URL-的井号‘-’\"><a href=\"#为什么改变-hash-不刷新页面？——URL-的井号‘-’\" class=\"headerlink\" title=\"为什么改变 hash 不刷新页面？——URL 的井号‘#’\"></a>为什么改变 hash 不刷新页面？——<a href=\"http://www.ruanyifeng.com/blog/2011/03/url_hash.html\" target=\"_blank\" rel=\"noopener\">URL 的井号‘#’</a></h3><p>‘#’ 代表网页中的一个位置，它后面的字符，就是该位置的标识符，它只对浏览器有用，服务器不识别，因此 HTTP 请求不会包含 # (想要请求 url 包含 # ，可使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" target=\"_blank\" rel=\"noopener\">encodeURIComponent()</a><br>进行部分转义)</p>\n<p><code>改变 hash ，只会让浏览器滚动到相应位置，不会重载网页</code></p>\n<h2 id=\"history-模式\"><a href=\"#history-模式\" class=\"headerlink\" title=\"history 模式\"></a>history 模式</h2><p>2014 年后，HTML5 引入了  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History/pushState\" target=\"_blank\" rel=\"noopener\">history.pushState()</a>  和  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_replaceState(\" target=\"_blank\" rel=\"noopener\">history.replaceState()</a>_method&gt;)  方法，它们分别可以添加和修改历史记录条目，通过这两个 API 可以改变 url 地址而无须重新加载页面。<br>同时还有<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate\" title=\"window.onpopstate是popstate事件在window对象上的事件处理程序.\" target=\"_blank\" rel=\"noopener\"><code>window.onpopstate</code></a>事件：<br>在浏览器点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法) 可以触发 popstate 事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function stateChange() &#123;</span><br><span class=\"line\">   // 一些 history 方法调用</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.addEventListener(&apos;popstate&apos;, stateChange)</span><br></pre></td></tr></table></figure>\n<p>通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。</p>\n<p>用了 HTML5 的实现，单页路由的 url 就不会多出一个 #，变得更加美观。<strong>但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。</strong>为了避免出现这种情况，history 模式需要服务器的支持，把所有路由都重定向到根页面。</p>\n<h2 id=\"hash-模式和-history-模式对比\"><a href=\"#hash-模式和-history-模式对比\" class=\"headerlink\" title=\"hash 模式和 history 模式对比\"></a>hash 模式和 history 模式对比</h2><ol>\n<li>无 # 的 history 模式更自然</li>\n<li>history 模式需要 ie9 以上，相对于 hash 模式的 ie8 兼容性差</li>\n<li>history 模式需服务器端配合，反过来说 hash 模式不支持服务端渲染</li>\n</ol>\n<h2 id=\"控制-vue-router-内的自动降级\"><a href=\"#控制-vue-router-内的自动降级\" class=\"headerlink\" title=\"控制 vue-router 内的自动降级\"></a>控制 vue-router 内的自动降级</h2><p>vue-router 默认 hash 模式，且在 history 模式下当浏览器不支持 history.pushState 时默认回退到 hash 模式<br>因此在 IE9 下的服务端渲染需要设置 fallback 为 false</p>\n"},{"title":"git 入门——在本地使用 git","date":"2018-06-05T13:05:27.000Z","_content":"\n# 什么是 git\n\ngit 是世界上最好的分布式版本控制系统\n\n什么意思？可以看廖雪峰的[git 教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)前面部分了解其概念\n\n# 如何在本地使用 git\n\n首先，打开你的命令行，本次我使用的是 Windows 上的 git bash，进入你的桌面 cd Desktop/\n\n![](https://upload-images.jianshu.io/upload_images/7094266-43b9dc80ef559196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在桌面创建一个文件夹，如 git-demo-1\n\nmkdir git-demo-1\n\n![](https://upload-images.jianshu.io/upload_images/7094266-0dc68b973297288f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**1\\. git init 初始化本地仓库 .git**\n\n进入这个目录：cd git-demo-1\n\n然后输入命令：git init\n\n这句命令会在 git-demo-1 里创建一个 .git 目录\n\n可以用 ls -la 观察这个目录\n\n![](https://upload-images.jianshu.io/upload_images/7094266-234bac65ee856269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**2\\. git status -sb 观察当前文件状态**\n\n在 git-demo-1 目录里创建一个文件如 index.html\n\ntouch index.html\n\n运行  git status -sb  可以看到文件前面有 ??\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5e3a74ba0f7d5209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**3\\. git add 文件名或 git add.**\n\n?? 表示 git 不知道如何对待这个新的文件\n\n此时要用 git add 将文件添加到「暂存区」\n\ngit add index.html（若文件较多，一个个加麻烦，可直接用 git add. 一次性将所有变动加到暂存区）\n\n然后可以再 git status -sb 观察其状态\n\n![](https://upload-images.jianshu.io/upload_images/7094266-aae00cd046749ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n?? 变成了 A 即告诉 git 这些文件我要加到仓库里\n\n**4. git commit -m \"信息\" 将文件正式提交到本地仓库（.git）**\n\n同样你可以一个个提交文件\n\ngit commit index.html -m '添加 index.html'\n\n或者一次提交所有文件\n\ngit commit . -m \"添加了几个文件\"\n\n再运行  git status -sb\n\n![](https://upload-images.jianshu.io/upload_images/7094266-0dc17938fa6c7440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n出现## master 说明你已经将文件上传成功了\n\n这时你可以用  git log 看历史变动\n\n![](https://upload-images.jianshu.io/upload_images/7094266-497d1b90a4b1e1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，一次在本地使用 git 的过程就完成了\n\n如果对已有文件有新的变动，我们只需要依次执行 git add xxx 和 git commit -m 'xxx' 两个命令即可\n\n---\n\n# 总结一下就是\n\n**1\\. git init 初始化本地仓库 .git**\n\n**2\\. git add 文件名或 git add.**\n\n**3. git commit -m \"信息\" 将文件正式提交到本地仓库（.git）**\n\n**有新的变动， git add xxx 和 git commit -m 'xxx'**\n\n**过程中用  git status -sb 观察当前文件状态**\n\n**最后可用  git log 看历史变动**\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n一些参考：\n\n[git 教程](http://www.runoob.com/git/git-tutorial.html)\n\n[常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n\n[廖大大-git](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n","source":"_posts/git入门——在本地使用git.md","raw":"---\ntitle: git 入门——在本地使用 git\ndate: 2018-06-05 21:05:27\ntags: git\n---\n\n# 什么是 git\n\ngit 是世界上最好的分布式版本控制系统\n\n什么意思？可以看廖雪峰的[git 教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)前面部分了解其概念\n\n# 如何在本地使用 git\n\n首先，打开你的命令行，本次我使用的是 Windows 上的 git bash，进入你的桌面 cd Desktop/\n\n![](https://upload-images.jianshu.io/upload_images/7094266-43b9dc80ef559196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在桌面创建一个文件夹，如 git-demo-1\n\nmkdir git-demo-1\n\n![](https://upload-images.jianshu.io/upload_images/7094266-0dc68b973297288f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**1\\. git init 初始化本地仓库 .git**\n\n进入这个目录：cd git-demo-1\n\n然后输入命令：git init\n\n这句命令会在 git-demo-1 里创建一个 .git 目录\n\n可以用 ls -la 观察这个目录\n\n![](https://upload-images.jianshu.io/upload_images/7094266-234bac65ee856269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**2\\. git status -sb 观察当前文件状态**\n\n在 git-demo-1 目录里创建一个文件如 index.html\n\ntouch index.html\n\n运行  git status -sb  可以看到文件前面有 ??\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5e3a74ba0f7d5209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**3\\. git add 文件名或 git add.**\n\n?? 表示 git 不知道如何对待这个新的文件\n\n此时要用 git add 将文件添加到「暂存区」\n\ngit add index.html（若文件较多，一个个加麻烦，可直接用 git add. 一次性将所有变动加到暂存区）\n\n然后可以再 git status -sb 观察其状态\n\n![](https://upload-images.jianshu.io/upload_images/7094266-aae00cd046749ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n?? 变成了 A 即告诉 git 这些文件我要加到仓库里\n\n**4. git commit -m \"信息\" 将文件正式提交到本地仓库（.git）**\n\n同样你可以一个个提交文件\n\ngit commit index.html -m '添加 index.html'\n\n或者一次提交所有文件\n\ngit commit . -m \"添加了几个文件\"\n\n再运行  git status -sb\n\n![](https://upload-images.jianshu.io/upload_images/7094266-0dc17938fa6c7440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n出现## master 说明你已经将文件上传成功了\n\n这时你可以用  git log 看历史变动\n\n![](https://upload-images.jianshu.io/upload_images/7094266-497d1b90a4b1e1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，一次在本地使用 git 的过程就完成了\n\n如果对已有文件有新的变动，我们只需要依次执行 git add xxx 和 git commit -m 'xxx' 两个命令即可\n\n---\n\n# 总结一下就是\n\n**1\\. git init 初始化本地仓库 .git**\n\n**2\\. git add 文件名或 git add.**\n\n**3. git commit -m \"信息\" 将文件正式提交到本地仓库（.git）**\n\n**有新的变动， git add xxx 和 git commit -m 'xxx'**\n\n**过程中用  git status -sb 观察当前文件状态**\n\n**最后可用  git log 看历史变动**\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n一些参考：\n\n[git 教程](http://www.runoob.com/git/git-tutorial.html)\n\n[常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n\n[廖大大-git](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n","slug":"git入门——在本地使用git","published":1,"updated":"2020-03-28T17:39:34.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyy000iws99n7bxqb8f","content":"<h1 id=\"什么是-git\"><a href=\"#什么是-git\" class=\"headerlink\" title=\"什么是 git\"></a>什么是 git</h1><p>git 是世界上最好的分布式版本控制系统</p>\n<p>什么意思？可以看廖雪峰的<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">git 教程</a>前面部分了解其概念</p>\n<h1 id=\"如何在本地使用-git\"><a href=\"#如何在本地使用-git\" class=\"headerlink\" title=\"如何在本地使用 git\"></a>如何在本地使用 git</h1><p>首先，打开你的命令行，本次我使用的是 Windows 上的 git bash，进入你的桌面 cd Desktop/</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-43b9dc80ef559196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在桌面创建一个文件夹，如 git-demo-1</p>\n<p>mkdir git-demo-1</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0dc68b973297288f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>1. git init 初始化本地仓库 .git</strong></p>\n<p>进入这个目录：cd git-demo-1</p>\n<p>然后输入命令：git init</p>\n<p>这句命令会在 git-demo-1 里创建一个 .git 目录</p>\n<p>可以用 ls -la 观察这个目录</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-234bac65ee856269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>2. git status -sb 观察当前文件状态</strong></p>\n<p>在 git-demo-1 目录里创建一个文件如 index.html</p>\n<p>touch index.html</p>\n<p>运行  git status -sb  可以看到文件前面有 ??</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5e3a74ba0f7d5209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>3. git add 文件名或 git add.</strong></p>\n<p>?? 表示 git 不知道如何对待这个新的文件</p>\n<p>此时要用 git add 将文件添加到「暂存区」</p>\n<p>git add index.html（若文件较多，一个个加麻烦，可直接用 git add. 一次性将所有变动加到暂存区）</p>\n<p>然后可以再 git status -sb 观察其状态</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-aae00cd046749ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>?? 变成了 A 即告诉 git 这些文件我要加到仓库里</p>\n<p><strong>4. git commit -m “信息” 将文件正式提交到本地仓库（.git）</strong></p>\n<p>同样你可以一个个提交文件</p>\n<p>git commit index.html -m ‘添加 index.html’</p>\n<p>或者一次提交所有文件</p>\n<p>git commit . -m “添加了几个文件”</p>\n<p>再运行  git status -sb</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0dc17938fa6c7440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>出现## master 说明你已经将文件上传成功了</p>\n<p>这时你可以用  git log 看历史变动</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-497d1b90a4b1e1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>至此，一次在本地使用 git 的过程就完成了</p>\n<p>如果对已有文件有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可</p>\n<hr>\n<h1 id=\"总结一下就是\"><a href=\"#总结一下就是\" class=\"headerlink\" title=\"总结一下就是\"></a>总结一下就是</h1><p><strong>1. git init 初始化本地仓库 .git</strong></p>\n<p><strong>2. git add 文件名或 git add.</strong></p>\n<p><strong>3. git commit -m “信息” 将文件正式提交到本地仓库（.git）</strong></p>\n<p><strong>有新的变动， git add xxx 和 git commit -m ‘xxx’</strong></p>\n<p><strong>过程中用  git status -sb 观察当前文件状态</strong></p>\n<p><strong>最后可用  git log 看历史变动</strong></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p>一些参考：</p>\n<p><a href=\"http://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener\">git 教程</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">常用 Git 命令清单</a></p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖大大-git</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-git\"><a href=\"#什么是-git\" class=\"headerlink\" title=\"什么是 git\"></a>什么是 git</h1><p>git 是世界上最好的分布式版本控制系统</p>\n<p>什么意思？可以看廖雪峰的<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">git 教程</a>前面部分了解其概念</p>\n<h1 id=\"如何在本地使用-git\"><a href=\"#如何在本地使用-git\" class=\"headerlink\" title=\"如何在本地使用 git\"></a>如何在本地使用 git</h1><p>首先，打开你的命令行，本次我使用的是 Windows 上的 git bash，进入你的桌面 cd Desktop/</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-43b9dc80ef559196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在桌面创建一个文件夹，如 git-demo-1</p>\n<p>mkdir git-demo-1</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0dc68b973297288f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>1. git init 初始化本地仓库 .git</strong></p>\n<p>进入这个目录：cd git-demo-1</p>\n<p>然后输入命令：git init</p>\n<p>这句命令会在 git-demo-1 里创建一个 .git 目录</p>\n<p>可以用 ls -la 观察这个目录</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-234bac65ee856269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>2. git status -sb 观察当前文件状态</strong></p>\n<p>在 git-demo-1 目录里创建一个文件如 index.html</p>\n<p>touch index.html</p>\n<p>运行  git status -sb  可以看到文件前面有 ??</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5e3a74ba0f7d5209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>3. git add 文件名或 git add.</strong></p>\n<p>?? 表示 git 不知道如何对待这个新的文件</p>\n<p>此时要用 git add 将文件添加到「暂存区」</p>\n<p>git add index.html（若文件较多，一个个加麻烦，可直接用 git add. 一次性将所有变动加到暂存区）</p>\n<p>然后可以再 git status -sb 观察其状态</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-aae00cd046749ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>?? 变成了 A 即告诉 git 这些文件我要加到仓库里</p>\n<p><strong>4. git commit -m “信息” 将文件正式提交到本地仓库（.git）</strong></p>\n<p>同样你可以一个个提交文件</p>\n<p>git commit index.html -m ‘添加 index.html’</p>\n<p>或者一次提交所有文件</p>\n<p>git commit . -m “添加了几个文件”</p>\n<p>再运行  git status -sb</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0dc17938fa6c7440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>出现## master 说明你已经将文件上传成功了</p>\n<p>这时你可以用  git log 看历史变动</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-497d1b90a4b1e1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>至此，一次在本地使用 git 的过程就完成了</p>\n<p>如果对已有文件有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可</p>\n<hr>\n<h1 id=\"总结一下就是\"><a href=\"#总结一下就是\" class=\"headerlink\" title=\"总结一下就是\"></a>总结一下就是</h1><p><strong>1. git init 初始化本地仓库 .git</strong></p>\n<p><strong>2. git add 文件名或 git add.</strong></p>\n<p><strong>3. git commit -m “信息” 将文件正式提交到本地仓库（.git）</strong></p>\n<p><strong>有新的变动， git add xxx 和 git commit -m ‘xxx’</strong></p>\n<p><strong>过程中用  git status -sb 观察当前文件状态</strong></p>\n<p><strong>最后可用  git log 看历史变动</strong></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p>一些参考：</p>\n<p><a href=\"http://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener\">git 教程</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">常用 Git 命令清单</a></p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖大大-git</a></p>\n"},{"title":"windows 7与 linux 双系统安装（免U盘）","date":"2018-06-03T14:30:14.000Z","_content":"\n之前一直看到 linux 系统的安利，决定在原 windows 7 系统下装个 linux 系统来学习。网上找了大量教程，遇到了各种各样的问题，花费了很长时间，终于成功。由于身边没有 U 盘，选择了免 U 盘安装的便捷方法。本次选择的 linux 系统版本为使用量最多的 ubuntu。下面分享安装的过程中的问题及解决方法。\n\n**系统环境：**\n\nwindows 7（win10 相同）\n\n**准备工具：**\n\n1.EasyBCD，一款用来配置与调整启动配置数据的软件，本次我使用的是 2.3 版本。\n\n2.Ubuntu 系统，[官网下载](https://link.zhihu.com/?target=https%3A//cn.ubuntu.com/download/)，选择自己喜欢的版本，本次我选用的是 Ubuntu 17.04 版本。\n\n**windows 分区：**\n\n从 windows 系统磁盘中分出 40-100G 空间作为 linux 系统存储空间\n\n1.桌面右键我的电脑，点击管理->磁盘管理\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-08c675192441c530.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.选择一个可用空间多的盘，右击选 压缩卷。压缩相应大小空间，本次我选用的是 80G，即 81920（可自行按实际情况选择 40-100G）\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-1e878e73901c0b1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3.压缩完成后生成的盘为为分配，选择新建简单卷，一直点下一步就可以了。\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-651995342bc7e591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n4.若出现无法新建简单卷的情况，如下（未出现即分区成功，可直接看下一过程）\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-45a5f96809ab9018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n主分区和逻辑分区已满情况：磁盘主分区加上逻辑分区（绿色框区域）超过 4 个区，就会出现这种情况。（想了解可看[遇到此情况原因](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qiushisoftware/article/details/19337945)）\n\n由于我原本的逻辑分区空间不足，我选择的办法是将某个主分区转换成逻辑分区，这样就相当于将磁盘转化到 3.的盘的状态，即主分区和逻辑分区不超过 4 个。用到的软件是 DiskGenius [下载地址](https://link.zhihu.com/?target=http%3A//www.diskgenius.cn/download.php)\n\n选中原来想分区的主分区盘 右击->转化为逻辑分区即可\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-09adb29a2c6cc10d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后重复步骤 3 就能成功\n\n**Ubuntu：**\n\n将下载好的 Ubuntu iOS 镜像文件放到电脑某个盘根目录下，本次我选择的是 F 盘，然后解压到当前目录下（选个文件少的盘，安装完成后这些解压文件和镜像都没用了，文件多的话删除的时候比较蛋疼，好在解压下来的文件一般有相同的修改日期，可作为删除参考依据）。保证解压后的这些文件和 Ubuntu iOS 镜像文件在同一个盘的根目录下，要不然安装过程中可能出现找不到系统文件的情况。\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-0d9f66878975eea7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-8f38604e93644e1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**EasyBCD：**\n\n打开 EasyBCD，选择添加新条目。在下半部分框里点击 ISO 项，名称随便填，路径选择你的 ubuntu ISO 镜像所在的地方。模式从磁盘运行。选完后，添加条目\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-fc7fd3391c25169b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后点击编辑引导菜单，就可以看到刚才添加的条目了。选择倒计时，如果 Use Metro bootloader 没有勾选上，勾选下。完成后保存设置。\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-16069c81c35d9de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**进入 Ubuntu 安装：**\n\n主要安装过程我参考了[\\_牙牙](https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/563525e5cc40)的简书  [地址](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559)  所给方法进行（由于图片无法截取，只能贴其博客了，大家可以按其博客从“4.关机重启，会出现两个选项，选 Ubuntu iOS，单击进入安装引导过程“开始）\n\n当我进行到这一步时候\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-fc2b00988be311dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n出现了“因为不能卸载以下挂载点上分区：/cdrom”的提示框（找不到图了，遇到应该会懂）此时不要点继续（我点了继续然后安装了一晚上没动静），点后退。\n\n解决方法是在此界面时选择试用 Ubuntu\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-7e0728cbb8a2de16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n进入后按快捷键 ctrl+alt+T 进入终端\n\n输入 sudo umount -l /cdrom 回车即可继续进行安装 Ubuntu（‘-l’中‘l’是小写的 L）\n\n若还是未安装成功，多尝试几遍，有与上述不一致的问题多 google，每个电脑情况不同，但是遇到问题基本上前人都解决过了，一定能有效解决。（ **Ctrl+Alt+Del**可以立即终结电脑的异常状态，因此安装未成功可用此快捷键快速重启）\n\n相信你一定能愉快得开始玩耍 linux 系统的。\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n**主要参考博客：**\n\n[win10 下装 ubuntu 双系统（免 U 盘）](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559)\n\n其他参考链接已在文中注明。\n","source":"_posts/windows-7与-linux-双系统安装（免U盘）.md","raw":"---\ntitle: windows 7与 linux 双系统安装（免U盘）\ndate: 2018-06-03 22:30:14\ntags: linux\n---\n\n之前一直看到 linux 系统的安利，决定在原 windows 7 系统下装个 linux 系统来学习。网上找了大量教程，遇到了各种各样的问题，花费了很长时间，终于成功。由于身边没有 U 盘，选择了免 U 盘安装的便捷方法。本次选择的 linux 系统版本为使用量最多的 ubuntu。下面分享安装的过程中的问题及解决方法。\n\n**系统环境：**\n\nwindows 7（win10 相同）\n\n**准备工具：**\n\n1.EasyBCD，一款用来配置与调整启动配置数据的软件，本次我使用的是 2.3 版本。\n\n2.Ubuntu 系统，[官网下载](https://link.zhihu.com/?target=https%3A//cn.ubuntu.com/download/)，选择自己喜欢的版本，本次我选用的是 Ubuntu 17.04 版本。\n\n**windows 分区：**\n\n从 windows 系统磁盘中分出 40-100G 空间作为 linux 系统存储空间\n\n1.桌面右键我的电脑，点击管理->磁盘管理\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-08c675192441c530.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.选择一个可用空间多的盘，右击选 压缩卷。压缩相应大小空间，本次我选用的是 80G，即 81920（可自行按实际情况选择 40-100G）\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-1e878e73901c0b1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3.压缩完成后生成的盘为为分配，选择新建简单卷，一直点下一步就可以了。\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-651995342bc7e591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n4.若出现无法新建简单卷的情况，如下（未出现即分区成功，可直接看下一过程）\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-45a5f96809ab9018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n主分区和逻辑分区已满情况：磁盘主分区加上逻辑分区（绿色框区域）超过 4 个区，就会出现这种情况。（想了解可看[遇到此情况原因](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qiushisoftware/article/details/19337945)）\n\n由于我原本的逻辑分区空间不足，我选择的办法是将某个主分区转换成逻辑分区，这样就相当于将磁盘转化到 3.的盘的状态，即主分区和逻辑分区不超过 4 个。用到的软件是 DiskGenius [下载地址](https://link.zhihu.com/?target=http%3A//www.diskgenius.cn/download.php)\n\n选中原来想分区的主分区盘 右击->转化为逻辑分区即可\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-09adb29a2c6cc10d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后重复步骤 3 就能成功\n\n**Ubuntu：**\n\n将下载好的 Ubuntu iOS 镜像文件放到电脑某个盘根目录下，本次我选择的是 F 盘，然后解压到当前目录下（选个文件少的盘，安装完成后这些解压文件和镜像都没用了，文件多的话删除的时候比较蛋疼，好在解压下来的文件一般有相同的修改日期，可作为删除参考依据）。保证解压后的这些文件和 Ubuntu iOS 镜像文件在同一个盘的根目录下，要不然安装过程中可能出现找不到系统文件的情况。\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-0d9f66878975eea7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-8f38604e93644e1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**EasyBCD：**\n\n打开 EasyBCD，选择添加新条目。在下半部分框里点击 ISO 项，名称随便填，路径选择你的 ubuntu ISO 镜像所在的地方。模式从磁盘运行。选完后，添加条目\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-fc7fd3391c25169b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后点击编辑引导菜单，就可以看到刚才添加的条目了。选择倒计时，如果 Use Metro bootloader 没有勾选上，勾选下。完成后保存设置。\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-16069c81c35d9de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**进入 Ubuntu 安装：**\n\n主要安装过程我参考了[\\_牙牙](https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/563525e5cc40)的简书  [地址](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559)  所给方法进行（由于图片无法截取，只能贴其博客了，大家可以按其博客从“4.关机重启，会出现两个选项，选 Ubuntu iOS，单击进入安装引导过程“开始）\n\n当我进行到这一步时候\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-fc2b00988be311dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n出现了“因为不能卸载以下挂载点上分区：/cdrom”的提示框（找不到图了，遇到应该会懂）此时不要点继续（我点了继续然后安装了一晚上没动静），点后退。\n\n解决方法是在此界面时选择试用 Ubuntu\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-7e0728cbb8a2de16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n进入后按快捷键 ctrl+alt+T 进入终端\n\n输入 sudo umount -l /cdrom 回车即可继续进行安装 Ubuntu（‘-l’中‘l’是小写的 L）\n\n若还是未安装成功，多尝试几遍，有与上述不一致的问题多 google，每个电脑情况不同，但是遇到问题基本上前人都解决过了，一定能有效解决。（ **Ctrl+Alt+Del**可以立即终结电脑的异常状态，因此安装未成功可用此快捷键快速重启）\n\n相信你一定能愉快得开始玩耍 linux 系统的。\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n**主要参考博客：**\n\n[win10 下装 ubuntu 双系统（免 U 盘）](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559)\n\n其他参考链接已在文中注明。\n","slug":"windows-7与-linux-双系统安装（免U盘）","published":1,"updated":"2020-03-28T17:37:25.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswyz000jws99ikzzseh9","content":"<p>之前一直看到 linux 系统的安利，决定在原 windows 7 系统下装个 linux 系统来学习。网上找了大量教程，遇到了各种各样的问题，花费了很长时间，终于成功。由于身边没有 U 盘，选择了免 U 盘安装的便捷方法。本次选择的 linux 系统版本为使用量最多的 ubuntu。下面分享安装的过程中的问题及解决方法。</p>\n<p><strong>系统环境：</strong></p>\n<p>windows 7（win10 相同）</p>\n<p><strong>准备工具：</strong></p>\n<p>1.EasyBCD，一款用来配置与调整启动配置数据的软件，本次我使用的是 2.3 版本。</p>\n<p>2.Ubuntu 系统，<a href=\"https://link.zhihu.com/?target=https%3A//cn.ubuntu.com/download/\" target=\"_blank\" rel=\"noopener\">官网下载</a>，选择自己喜欢的版本，本次我选用的是 Ubuntu 17.04 版本。</p>\n<p><strong>windows 分区：</strong></p>\n<p>从 windows 系统磁盘中分出 40-100G 空间作为 linux 系统存储空间</p>\n<p>1.桌面右键我的电脑，点击管理-&gt;磁盘管理</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-08c675192441c530.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>2.选择一个可用空间多的盘，右击选 压缩卷。压缩相应大小空间，本次我选用的是 80G，即 81920（可自行按实际情况选择 40-100G）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-1e878e73901c0b1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>3.压缩完成后生成的盘为为分配，选择新建简单卷，一直点下一步就可以了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-651995342bc7e591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>4.若出现无法新建简单卷的情况，如下（未出现即分区成功，可直接看下一过程）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-45a5f96809ab9018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>主分区和逻辑分区已满情况：磁盘主分区加上逻辑分区（绿色框区域）超过 4 个区，就会出现这种情况。（想了解可看<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qiushisoftware/article/details/19337945\" target=\"_blank\" rel=\"noopener\">遇到此情况原因</a>）</p>\n<p>由于我原本的逻辑分区空间不足，我选择的办法是将某个主分区转换成逻辑分区，这样就相当于将磁盘转化到 3.的盘的状态，即主分区和逻辑分区不超过 4 个。用到的软件是 DiskGenius <a href=\"https://link.zhihu.com/?target=http%3A//www.diskgenius.cn/download.php\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p>选中原来想分区的主分区盘 右击-&gt;转化为逻辑分区即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-09adb29a2c6cc10d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后重复步骤 3 就能成功</p>\n<p><strong>Ubuntu：</strong></p>\n<p>将下载好的 Ubuntu iOS 镜像文件放到电脑某个盘根目录下，本次我选择的是 F 盘，然后解压到当前目录下（选个文件少的盘，安装完成后这些解压文件和镜像都没用了，文件多的话删除的时候比较蛋疼，好在解压下来的文件一般有相同的修改日期，可作为删除参考依据）。保证解压后的这些文件和 Ubuntu iOS 镜像文件在同一个盘的根目录下，要不然安装过程中可能出现找不到系统文件的情况。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0d9f66878975eea7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8f38604e93644e1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><strong>EasyBCD：</strong></p>\n<p>打开 EasyBCD，选择添加新条目。在下半部分框里点击 ISO 项，名称随便填，路径选择你的 ubuntu ISO 镜像所在的地方。模式从磁盘运行。选完后，添加条目</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fc7fd3391c25169b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后点击编辑引导菜单，就可以看到刚才添加的条目了。选择倒计时，如果 Use Metro bootloader 没有勾选上，勾选下。完成后保存设置。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-16069c81c35d9de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><strong>进入 Ubuntu 安装：</strong></p>\n<p>主要安装过程我参考了<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/563525e5cc40\" target=\"_blank\" rel=\"noopener\">_牙牙</a>的简书  <a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559\" target=\"_blank\" rel=\"noopener\">地址</a>  所给方法进行（由于图片无法截取，只能贴其博客了，大家可以按其博客从“4.关机重启，会出现两个选项，选 Ubuntu iOS，单击进入安装引导过程“开始）</p>\n<p>当我进行到这一步时候</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fc2b00988be311dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>出现了“因为不能卸载以下挂载点上分区：/cdrom”的提示框（找不到图了，遇到应该会懂）此时不要点继续（我点了继续然后安装了一晚上没动静），点后退。</p>\n<p>解决方法是在此界面时选择试用 Ubuntu</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-7e0728cbb8a2de16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>进入后按快捷键 ctrl+alt+T 进入终端</p>\n<p>输入 sudo umount -l /cdrom 回车即可继续进行安装 Ubuntu（‘-l’中‘l’是小写的 L）</p>\n<p>若还是未安装成功，多尝试几遍，有与上述不一致的问题多 google，每个电脑情况不同，但是遇到问题基本上前人都解决过了，一定能有效解决。（ <strong>Ctrl+Alt+Del</strong>可以立即终结电脑的异常状态，因此安装未成功可用此快捷键快速重启）</p>\n<p>相信你一定能愉快得开始玩耍 linux 系统的。</p>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p><strong>主要参考博客：</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559\" target=\"_blank\" rel=\"noopener\">win10 下装 ubuntu 双系统（免 U 盘）</a></p>\n<p>其他参考链接已在文中注明。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前一直看到 linux 系统的安利，决定在原 windows 7 系统下装个 linux 系统来学习。网上找了大量教程，遇到了各种各样的问题，花费了很长时间，终于成功。由于身边没有 U 盘，选择了免 U 盘安装的便捷方法。本次选择的 linux 系统版本为使用量最多的 ubuntu。下面分享安装的过程中的问题及解决方法。</p>\n<p><strong>系统环境：</strong></p>\n<p>windows 7（win10 相同）</p>\n<p><strong>准备工具：</strong></p>\n<p>1.EasyBCD，一款用来配置与调整启动配置数据的软件，本次我使用的是 2.3 版本。</p>\n<p>2.Ubuntu 系统，<a href=\"https://link.zhihu.com/?target=https%3A//cn.ubuntu.com/download/\" target=\"_blank\" rel=\"noopener\">官网下载</a>，选择自己喜欢的版本，本次我选用的是 Ubuntu 17.04 版本。</p>\n<p><strong>windows 分区：</strong></p>\n<p>从 windows 系统磁盘中分出 40-100G 空间作为 linux 系统存储空间</p>\n<p>1.桌面右键我的电脑，点击管理-&gt;磁盘管理</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-08c675192441c530.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>2.选择一个可用空间多的盘，右击选 压缩卷。压缩相应大小空间，本次我选用的是 80G，即 81920（可自行按实际情况选择 40-100G）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-1e878e73901c0b1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>3.压缩完成后生成的盘为为分配，选择新建简单卷，一直点下一步就可以了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-651995342bc7e591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>4.若出现无法新建简单卷的情况，如下（未出现即分区成功，可直接看下一过程）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-45a5f96809ab9018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>主分区和逻辑分区已满情况：磁盘主分区加上逻辑分区（绿色框区域）超过 4 个区，就会出现这种情况。（想了解可看<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qiushisoftware/article/details/19337945\" target=\"_blank\" rel=\"noopener\">遇到此情况原因</a>）</p>\n<p>由于我原本的逻辑分区空间不足，我选择的办法是将某个主分区转换成逻辑分区，这样就相当于将磁盘转化到 3.的盘的状态，即主分区和逻辑分区不超过 4 个。用到的软件是 DiskGenius <a href=\"https://link.zhihu.com/?target=http%3A//www.diskgenius.cn/download.php\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p>选中原来想分区的主分区盘 右击-&gt;转化为逻辑分区即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-09adb29a2c6cc10d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后重复步骤 3 就能成功</p>\n<p><strong>Ubuntu：</strong></p>\n<p>将下载好的 Ubuntu iOS 镜像文件放到电脑某个盘根目录下，本次我选择的是 F 盘，然后解压到当前目录下（选个文件少的盘，安装完成后这些解压文件和镜像都没用了，文件多的话删除的时候比较蛋疼，好在解压下来的文件一般有相同的修改日期，可作为删除参考依据）。保证解压后的这些文件和 Ubuntu iOS 镜像文件在同一个盘的根目录下，要不然安装过程中可能出现找不到系统文件的情况。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0d9f66878975eea7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8f38604e93644e1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><strong>EasyBCD：</strong></p>\n<p>打开 EasyBCD，选择添加新条目。在下半部分框里点击 ISO 项，名称随便填，路径选择你的 ubuntu ISO 镜像所在的地方。模式从磁盘运行。选完后，添加条目</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fc7fd3391c25169b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后点击编辑引导菜单，就可以看到刚才添加的条目了。选择倒计时，如果 Use Metro bootloader 没有勾选上，勾选下。完成后保存设置。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-16069c81c35d9de9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><strong>进入 Ubuntu 安装：</strong></p>\n<p>主要安装过程我参考了<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/563525e5cc40\" target=\"_blank\" rel=\"noopener\">_牙牙</a>的简书  <a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559\" target=\"_blank\" rel=\"noopener\">地址</a>  所给方法进行（由于图片无法截取，只能贴其博客了，大家可以按其博客从“4.关机重启，会出现两个选项，选 Ubuntu iOS，单击进入安装引导过程“开始）</p>\n<p>当我进行到这一步时候</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fc2b00988be311dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>出现了“因为不能卸载以下挂载点上分区：/cdrom”的提示框（找不到图了，遇到应该会懂）此时不要点继续（我点了继续然后安装了一晚上没动静），点后退。</p>\n<p>解决方法是在此界面时选择试用 Ubuntu</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-7e0728cbb8a2de16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>进入后按快捷键 ctrl+alt+T 进入终端</p>\n<p>输入 sudo umount -l /cdrom 回车即可继续进行安装 Ubuntu（‘-l’中‘l’是小写的 L）</p>\n<p>若还是未安装成功，多尝试几遍，有与上述不一致的问题多 google，每个电脑情况不同，但是遇到问题基本上前人都解决过了，一定能有效解决。（ <strong>Ctrl+Alt+Del</strong>可以立即终结电脑的异常状态，因此安装未成功可用此快捷键快速重启）</p>\n<p>相信你一定能愉快得开始玩耍 linux 系统的。</p>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p><strong>主要参考博客：</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/417c1001a559\" target=\"_blank\" rel=\"noopener\">win10 下装 ubuntu 双系统（免 U 盘）</a></p>\n<p>其他参考链接已在文中注明。</p>\n"},{"title":"一些命令行入门学习的知识和细节","date":"2018-06-03T14:26:58.000Z","_content":"\n# 命令行？\n\n命令行：只有命令，方便\n\nwindows：图形界面\n\n一个程序员应该学会命令行\n\n## 下面是一些简单的知识\n\n命令行里“目录”（对应 windows 里的“文件夹”）\n\n命令行一些符号\n\n**~**：用户目录\n\n**/** ：整个硬盘\n\n**. **：当前目录\n\n**.. **：副目录\n\n**& **：提示符号，可以改变\n\n**clear** ：清屏\n\n---\n\n输入**ls -l **（查看路径）回车得到如下\n\n![](https://upload-images.jianshu.io/upload_images/7094266-bb2e7ac4f4e616ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中：\n\n**d** ：**directory**表示   目录(文件夹)\n\n**r** ：**read**表示   可读\n\n**w**：**write**表示   可写\n\n**x** ：表示 可执行\n\n**- **：表示 不可以\n\n第一组  **rwx**  表示管理员权限，第二组  **rwx**  表示 用户所在组的权限，第三组  **rwx**  是访问权限\n\n**Administer**  表示用户；**197121**  表示用户所在组\n\n---\n\n可以用  **touch + 文件名**  创建文件\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c9580aa61009e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**echo**  和  **touch **均可用来创建文件\n\n区别是  **echo**  可以向创建的文件里追加内容** touch**  只用来创建文件且可以改变文件更新时间\n\n## **命令行快捷键**\n\n↑ ↓ 上一命令 / 下一命令\n\n!! 上一命令占位符\n\n**Tab** 自动补全路径\n\n**Alt+.** 上一命令的最后一个参数\n\n**&&** 前面的执行成功了，再执行后面的\n\n**||** 前面的执行失败了，就执行后面的\n\n**;** 前面执行完了，不管成功失败，就执行后面的\n\n**>** 重定向\n\n**|** 管道\n\n## **如何使用其他命令行**\n\n常用命令网上很多，谷歌一下就有，那么一些不常用的命令如何知道有哪些用法和其含义\n\n命令行中查看选项手册**man**：**manual**\n\nwindows 中用**--help**\n\n手册内容太长不想看（用此）[tldr](https://github.com/tldr-pages/tldr#tldr)：**too long didn't read**\n\n还可以用这个网页，命令行[释义](https://explainshell.com/)\n\n点开界面如下\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-0bc203c06c932a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在搜索框输入要查询的命令\n\n如  **ls**\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-a733fcf7a6a0a3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**list directory contents**  列出目录内容\n\n有些命令可以有参数，如** ls**  有**-l -a**等\n\n![](https://upload-images.jianshu.io/upload_images/7094266-156ca27401e98309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n是不是很方便？再试试其他的，比如  **mv**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-e5d1b5db9555a3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**move (rename) files **移动（重命名）文件\n\n以及  **cat**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-356bafdb4d657c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**concatenate files and print on the standard output **连接文件并打印到标准输出设备上\n\n必要时可以参考教程[cat 菜鸟教程](http://www.runoob.com/linux/linux-comm-cat.html)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n","source":"_posts/一些命令行入门学习的知识和细节.md","raw":"---\ntitle: 一些命令行入门学习的知识和细节\ndate: 2018-06-03 22:26:58\ntags: 命令行\n---\n\n# 命令行？\n\n命令行：只有命令，方便\n\nwindows：图形界面\n\n一个程序员应该学会命令行\n\n## 下面是一些简单的知识\n\n命令行里“目录”（对应 windows 里的“文件夹”）\n\n命令行一些符号\n\n**~**：用户目录\n\n**/** ：整个硬盘\n\n**. **：当前目录\n\n**.. **：副目录\n\n**& **：提示符号，可以改变\n\n**clear** ：清屏\n\n---\n\n输入**ls -l **（查看路径）回车得到如下\n\n![](https://upload-images.jianshu.io/upload_images/7094266-bb2e7ac4f4e616ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中：\n\n**d** ：**directory**表示   目录(文件夹)\n\n**r** ：**read**表示   可读\n\n**w**：**write**表示   可写\n\n**x** ：表示 可执行\n\n**- **：表示 不可以\n\n第一组  **rwx**  表示管理员权限，第二组  **rwx**  表示 用户所在组的权限，第三组  **rwx**  是访问权限\n\n**Administer**  表示用户；**197121**  表示用户所在组\n\n---\n\n可以用  **touch + 文件名**  创建文件\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c9580aa61009e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**echo**  和  **touch **均可用来创建文件\n\n区别是  **echo**  可以向创建的文件里追加内容** touch**  只用来创建文件且可以改变文件更新时间\n\n## **命令行快捷键**\n\n↑ ↓ 上一命令 / 下一命令\n\n!! 上一命令占位符\n\n**Tab** 自动补全路径\n\n**Alt+.** 上一命令的最后一个参数\n\n**&&** 前面的执行成功了，再执行后面的\n\n**||** 前面的执行失败了，就执行后面的\n\n**;** 前面执行完了，不管成功失败，就执行后面的\n\n**>** 重定向\n\n**|** 管道\n\n## **如何使用其他命令行**\n\n常用命令网上很多，谷歌一下就有，那么一些不常用的命令如何知道有哪些用法和其含义\n\n命令行中查看选项手册**man**：**manual**\n\nwindows 中用**--help**\n\n手册内容太长不想看（用此）[tldr](https://github.com/tldr-pages/tldr#tldr)：**too long didn't read**\n\n还可以用这个网页，命令行[释义](https://explainshell.com/)\n\n点开界面如下\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-0bc203c06c932a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在搜索框输入要查询的命令\n\n如  **ls**\n\n![image](https://upload-images.jianshu.io/upload_images/7094266-a733fcf7a6a0a3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**list directory contents**  列出目录内容\n\n有些命令可以有参数，如** ls**  有**-l -a**等\n\n![](https://upload-images.jianshu.io/upload_images/7094266-156ca27401e98309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n是不是很方便？再试试其他的，比如  **mv**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-e5d1b5db9555a3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**move (rename) files **移动（重命名）文件\n\n以及  **cat**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-356bafdb4d657c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**concatenate files and print on the standard output **连接文件并打印到标准输出设备上\n\n必要时可以参考教程[cat 菜鸟教程](http://www.runoob.com/linux/linux-comm-cat.html)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n","slug":"一些命令行入门学习的知识和细节","published":1,"updated":"2020-03-28T17:29:04.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz0000kws99rwtrdwdq","content":"<h1 id=\"命令行？\"><a href=\"#命令行？\" class=\"headerlink\" title=\"命令行？\"></a>命令行？</h1><p>命令行：只有命令，方便</p>\n<p>windows：图形界面</p>\n<p>一个程序员应该学会命令行</p>\n<h2 id=\"下面是一些简单的知识\"><a href=\"#下面是一些简单的知识\" class=\"headerlink\" title=\"下面是一些简单的知识\"></a>下面是一些简单的知识</h2><p>命令行里“目录”（对应 windows 里的“文件夹”）</p>\n<p>命令行一些符号</p>\n<p><strong>~</strong>：用户目录</p>\n<p><strong>/</strong> ：整个硬盘</p>\n<p><strong>. </strong>：当前目录</p>\n<p><strong>.. </strong>：副目录</p>\n<p><strong>&amp; </strong>：提示符号，可以改变</p>\n<p><strong>clear</strong> ：清屏</p>\n<hr>\n<p>输入<strong>ls -l </strong>（查看路径）回车得到如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-bb2e7ac4f4e616ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其中：</p>\n<p><strong>d</strong> ：<strong>directory</strong>表示   目录(文件夹)</p>\n<p><strong>r</strong> ：<strong>read</strong>表示   可读</p>\n<p><strong>w</strong>：<strong>write</strong>表示   可写</p>\n<p><strong>x</strong> ：表示 可执行</p>\n<p><strong>- </strong>：表示 不可以</p>\n<p>第一组  <strong>rwx</strong>  表示管理员权限，第二组  <strong>rwx</strong>  表示 用户所在组的权限，第三组  <strong>rwx</strong>  是访问权限</p>\n<p><strong>Administer</strong>  表示用户；<strong>197121</strong>  表示用户所在组</p>\n<hr>\n<p>可以用  <strong>touch + 文件名</strong>  创建文件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c9580aa61009e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>echo</strong>  和  <strong>touch </strong>均可用来创建文件</p>\n<p>区别是  <strong>echo</strong>  可以向创建的文件里追加内容<strong> touch</strong>  只用来创建文件且可以改变文件更新时间</p>\n<h2 id=\"命令行快捷键\"><a href=\"#命令行快捷键\" class=\"headerlink\" title=\"命令行快捷键\"></a><strong>命令行快捷键</strong></h2><p>↑ ↓ 上一命令 / 下一命令</p>\n<p>!! 上一命令占位符</p>\n<p><strong>Tab</strong> 自动补全路径</p>\n<p><strong>Alt+.</strong> 上一命令的最后一个参数</p>\n<p><strong>&amp;&amp;</strong> 前面的执行成功了，再执行后面的</p>\n<p><strong>||</strong> 前面的执行失败了，就执行后面的</p>\n<p><strong>;</strong> 前面执行完了，不管成功失败，就执行后面的</p>\n<p><strong>&gt;</strong> 重定向</p>\n<p><strong>|</strong> 管道</p>\n<h2 id=\"如何使用其他命令行\"><a href=\"#如何使用其他命令行\" class=\"headerlink\" title=\"如何使用其他命令行\"></a><strong>如何使用其他命令行</strong></h2><p>常用命令网上很多，谷歌一下就有，那么一些不常用的命令如何知道有哪些用法和其含义</p>\n<p>命令行中查看选项手册<strong>man</strong>：<strong>manual</strong></p>\n<p>windows 中用<strong>–help</strong></p>\n<p>手册内容太长不想看（用此）<a href=\"https://github.com/tldr-pages/tldr#tldr\">tldr</a>：<strong>too long didn’t read</strong></p>\n<p>还可以用这个网页，命令行<a href=\"https://explainshell.com/\" target=\"_blank\" rel=\"noopener\">释义</a></p>\n<p>点开界面如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0bc203c06c932a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在搜索框输入要查询的命令</p>\n<p>如  <strong>ls</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a733fcf7a6a0a3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><strong>list directory contents</strong>  列出目录内容</p>\n<p>有些命令可以有参数，如<strong> ls</strong>  有<strong>-l -a</strong>等</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-156ca27401e98309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>是不是很方便？再试试其他的，比如  <strong>mv</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e5d1b5db9555a3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>move (rename) files </strong>移动（重命名）文件</p>\n<p>以及  <strong>cat</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-356bafdb4d657c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>concatenate files and print on the standard output </strong>连接文件并打印到标准输出设备上</p>\n<p>必要时可以参考教程<a href=\"http://www.runoob.com/linux/linux-comm-cat.html\" target=\"_blank\" rel=\"noopener\">cat 菜鸟教程</a></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"命令行？\"><a href=\"#命令行？\" class=\"headerlink\" title=\"命令行？\"></a>命令行？</h1><p>命令行：只有命令，方便</p>\n<p>windows：图形界面</p>\n<p>一个程序员应该学会命令行</p>\n<h2 id=\"下面是一些简单的知识\"><a href=\"#下面是一些简单的知识\" class=\"headerlink\" title=\"下面是一些简单的知识\"></a>下面是一些简单的知识</h2><p>命令行里“目录”（对应 windows 里的“文件夹”）</p>\n<p>命令行一些符号</p>\n<p><strong>~</strong>：用户目录</p>\n<p><strong>/</strong> ：整个硬盘</p>\n<p><strong>. </strong>：当前目录</p>\n<p><strong>.. </strong>：副目录</p>\n<p><strong>&amp; </strong>：提示符号，可以改变</p>\n<p><strong>clear</strong> ：清屏</p>\n<hr>\n<p>输入<strong>ls -l </strong>（查看路径）回车得到如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-bb2e7ac4f4e616ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其中：</p>\n<p><strong>d</strong> ：<strong>directory</strong>表示   目录(文件夹)</p>\n<p><strong>r</strong> ：<strong>read</strong>表示   可读</p>\n<p><strong>w</strong>：<strong>write</strong>表示   可写</p>\n<p><strong>x</strong> ：表示 可执行</p>\n<p><strong>- </strong>：表示 不可以</p>\n<p>第一组  <strong>rwx</strong>  表示管理员权限，第二组  <strong>rwx</strong>  表示 用户所在组的权限，第三组  <strong>rwx</strong>  是访问权限</p>\n<p><strong>Administer</strong>  表示用户；<strong>197121</strong>  表示用户所在组</p>\n<hr>\n<p>可以用  <strong>touch + 文件名</strong>  创建文件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c9580aa61009e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>echo</strong>  和  <strong>touch </strong>均可用来创建文件</p>\n<p>区别是  <strong>echo</strong>  可以向创建的文件里追加内容<strong> touch</strong>  只用来创建文件且可以改变文件更新时间</p>\n<h2 id=\"命令行快捷键\"><a href=\"#命令行快捷键\" class=\"headerlink\" title=\"命令行快捷键\"></a><strong>命令行快捷键</strong></h2><p>↑ ↓ 上一命令 / 下一命令</p>\n<p>!! 上一命令占位符</p>\n<p><strong>Tab</strong> 自动补全路径</p>\n<p><strong>Alt+.</strong> 上一命令的最后一个参数</p>\n<p><strong>&amp;&amp;</strong> 前面的执行成功了，再执行后面的</p>\n<p><strong>||</strong> 前面的执行失败了，就执行后面的</p>\n<p><strong>;</strong> 前面执行完了，不管成功失败，就执行后面的</p>\n<p><strong>&gt;</strong> 重定向</p>\n<p><strong>|</strong> 管道</p>\n<h2 id=\"如何使用其他命令行\"><a href=\"#如何使用其他命令行\" class=\"headerlink\" title=\"如何使用其他命令行\"></a><strong>如何使用其他命令行</strong></h2><p>常用命令网上很多，谷歌一下就有，那么一些不常用的命令如何知道有哪些用法和其含义</p>\n<p>命令行中查看选项手册<strong>man</strong>：<strong>manual</strong></p>\n<p>windows 中用<strong>–help</strong></p>\n<p>手册内容太长不想看（用此）<a href=\"https://github.com/tldr-pages/tldr#tldr\">tldr</a>：<strong>too long didn’t read</strong></p>\n<p>还可以用这个网页，命令行<a href=\"https://explainshell.com/\" target=\"_blank\" rel=\"noopener\">释义</a></p>\n<p>点开界面如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0bc203c06c932a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>在搜索框输入要查询的命令</p>\n<p>如  <strong>ls</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a733fcf7a6a0a3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><strong>list directory contents</strong>  列出目录内容</p>\n<p>有些命令可以有参数，如<strong> ls</strong>  有<strong>-l -a</strong>等</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-156ca27401e98309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>是不是很方便？再试试其他的，比如  <strong>mv</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e5d1b5db9555a3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>move (rename) files </strong>移动（重命名）文件</p>\n<p>以及  <strong>cat</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-356bafdb4d657c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>concatenate files and print on the standard output </strong>连接文件并打印到标准输出设备上</p>\n<p>必要时可以参考教程<a href=\"http://www.runoob.com/linux/linux-comm-cat.html\" target=\"_blank\" rel=\"noopener\">cat 菜鸟教程</a></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n"},{"title":"windows 7与linux双系统安装（后续）","date":"2018-05-26T16:35:45.000Z","_content":"\n前两天美滋滋得安装了 windows 7 下的 linux 双系统 ubuntu，详情见  [链接](https://zhuanlan.zhihu.com/p/37277742) ，以为从此即将开始愉快的学（zhuang）习（bi）之旅了。没想到接下来就是各种强行熟悉其各种命令的噩梦。。。\n\n---\n\n首先是各种无法启动\n\n![image](http://upload-images.jianshu.io/upload_images/7094266-acbb7fb00b6400ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n于是我选择各种重装，结果悲剧了。\n\n![](http://upload-images.jianshu.io/upload_images/7094266-cfe90c6da4aba864.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n每次重启都是这个，崩溃\n\n于是跟着大神们开始启动救援模式，具体可自行 google“grub rescue”这篇是我写文章时打开的 博客  [链接](http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012234115/article/details/38110613)\n\n当我跟着大神们一步步\n\n```\nls （hdx，msdosx）/\n\nset root=hdx，msdosx\n\nset prefix=（hdx，msdosx）/grub\n\ninsmod normal\n\nnormal\n```\n\n终于成功进入 grub2 界面，即可选择系统（每个人不一样，可以多看看不同博客，有细微差别，我当时尝试了不同格式上述命令，终于属于找到自己电脑的，当你都看完你就都懂了）\n\n此时问题又来了，我进不了 ubuntu 啊，因为我就是启动不了才发生后续问题的，这个问题至今未解决。。那怎么办，无法更新 grub 就一直会重启出现 grub rescue 啊（鬼知道我打了多少遍上面的命令，相信你懂得）我找了各种解决办法，包括什么用尝试启动 ubuntu 来下载  [引导修复（boot repair）](http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012260238/article/details/52713724) ，但是我 ubuntu 无法联网啊，U 盘也没有（上一篇免 U 盘装双系统），还有什么 live cd，都没有不会啊 （上述情况任何一样有都有相应解决方法，可视情况选择，具体我给的链接应该涵盖了）\n\n在我都打算用 grub rescue 作为引导启动项的时候（每次开机打一遍上面的命令），我发现了新的简便方法，只需用到 EasyBCD（装系统时用到）。由于我们可以进入 grub2 界面进入 windows 系统，因此操作方便（其实之前一直想尝试用 DiskGenius[参考博客](http://link.zhihu.com/?target=https%3A//blog.csdn.net/pkueecser/article/details/6888392)重建 MBR 的方法，但是怕 windows 系统也崩溃。。其实一直最担心的是这个，好多数据的。。结果担心是多余）\n\n了解 MBR GRUB 可参考博客  [链接](http://link.zhihu.com/?target=https%3A//blog.csdn.net/jscese/article/details/36865449)\n\n通过 EasyBCD 重建 MBR 解决 grub rescue 的问题具体可参考 博客  [链接](http://link.zhihu.com/?target=https%3A//blog.csdn.net/xuehuafeiwu123/article/details/78829717)\n\n当然我的 ubuntu 还没删，万一哪天高兴打算再研究一下，估计不行的话会删尝试虚拟机的方法，不过可能还是用笔记本破釜沉舟直接安装 linux 较好，有空在试吧。\n\n本次装双系统花了 2 个下午加 3 个晚上，终于成功回到了起点。。。\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n**参考博客：**\n\n[ubuntu 无法启动的解决方法 - CSDN 博客](https://blog.csdn.net/xqhrs232/article/details/50967886)\n[双系统 Ubuntu 引导修复（Boot Repair） - CSDN 博客](https://blog.csdn.net/u012260238/article/details/52713724)\n[Win7 与 Ubuntu 双系统时【卸载 Ubuntu】 - CSDN 博客](https://blog.csdn.net/pkueecser/article/details/6888392)\n[Win7+Ubuntu 双系统，如何卸载 Ubuntu 系统？ - CSDN 博客](https://blog.csdn.net/xuehuafeiwu123/article/details/78829717)\n[删除 linux 系统分区后进 windows 出现 grub rescue（已解决） - CSDN 博客](https://blog.csdn.net/u012234115/article/details/38110613)\n[Ubuntu--grub rescue 主引导修复 - CSDN 博客](https://blog.csdn.net/jscese/article/details/36865449)\n","source":"_posts/windows-7与linux双系统安装（后续）.md","raw":"---\ntitle: windows 7与linux双系统安装（后续）\ndate: 2018-05-27 00:35:45\ntags: linux\n---\n\n前两天美滋滋得安装了 windows 7 下的 linux 双系统 ubuntu，详情见  [链接](https://zhuanlan.zhihu.com/p/37277742) ，以为从此即将开始愉快的学（zhuang）习（bi）之旅了。没想到接下来就是各种强行熟悉其各种命令的噩梦。。。\n\n---\n\n首先是各种无法启动\n\n![image](http://upload-images.jianshu.io/upload_images/7094266-acbb7fb00b6400ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n于是我选择各种重装，结果悲剧了。\n\n![](http://upload-images.jianshu.io/upload_images/7094266-cfe90c6da4aba864.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n每次重启都是这个，崩溃\n\n于是跟着大神们开始启动救援模式，具体可自行 google“grub rescue”这篇是我写文章时打开的 博客  [链接](http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012234115/article/details/38110613)\n\n当我跟着大神们一步步\n\n```\nls （hdx，msdosx）/\n\nset root=hdx，msdosx\n\nset prefix=（hdx，msdosx）/grub\n\ninsmod normal\n\nnormal\n```\n\n终于成功进入 grub2 界面，即可选择系统（每个人不一样，可以多看看不同博客，有细微差别，我当时尝试了不同格式上述命令，终于属于找到自己电脑的，当你都看完你就都懂了）\n\n此时问题又来了，我进不了 ubuntu 啊，因为我就是启动不了才发生后续问题的，这个问题至今未解决。。那怎么办，无法更新 grub 就一直会重启出现 grub rescue 啊（鬼知道我打了多少遍上面的命令，相信你懂得）我找了各种解决办法，包括什么用尝试启动 ubuntu 来下载  [引导修复（boot repair）](http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012260238/article/details/52713724) ，但是我 ubuntu 无法联网啊，U 盘也没有（上一篇免 U 盘装双系统），还有什么 live cd，都没有不会啊 （上述情况任何一样有都有相应解决方法，可视情况选择，具体我给的链接应该涵盖了）\n\n在我都打算用 grub rescue 作为引导启动项的时候（每次开机打一遍上面的命令），我发现了新的简便方法，只需用到 EasyBCD（装系统时用到）。由于我们可以进入 grub2 界面进入 windows 系统，因此操作方便（其实之前一直想尝试用 DiskGenius[参考博客](http://link.zhihu.com/?target=https%3A//blog.csdn.net/pkueecser/article/details/6888392)重建 MBR 的方法，但是怕 windows 系统也崩溃。。其实一直最担心的是这个，好多数据的。。结果担心是多余）\n\n了解 MBR GRUB 可参考博客  [链接](http://link.zhihu.com/?target=https%3A//blog.csdn.net/jscese/article/details/36865449)\n\n通过 EasyBCD 重建 MBR 解决 grub rescue 的问题具体可参考 博客  [链接](http://link.zhihu.com/?target=https%3A//blog.csdn.net/xuehuafeiwu123/article/details/78829717)\n\n当然我的 ubuntu 还没删，万一哪天高兴打算再研究一下，估计不行的话会删尝试虚拟机的方法，不过可能还是用笔记本破釜沉舟直接安装 linux 较好，有空在试吧。\n\n本次装双系统花了 2 个下午加 3 个晚上，终于成功回到了起点。。。\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n**参考博客：**\n\n[ubuntu 无法启动的解决方法 - CSDN 博客](https://blog.csdn.net/xqhrs232/article/details/50967886)\n[双系统 Ubuntu 引导修复（Boot Repair） - CSDN 博客](https://blog.csdn.net/u012260238/article/details/52713724)\n[Win7 与 Ubuntu 双系统时【卸载 Ubuntu】 - CSDN 博客](https://blog.csdn.net/pkueecser/article/details/6888392)\n[Win7+Ubuntu 双系统，如何卸载 Ubuntu 系统？ - CSDN 博客](https://blog.csdn.net/xuehuafeiwu123/article/details/78829717)\n[删除 linux 系统分区后进 windows 出现 grub rescue（已解决） - CSDN 博客](https://blog.csdn.net/u012234115/article/details/38110613)\n[Ubuntu--grub rescue 主引导修复 - CSDN 博客](https://blog.csdn.net/jscese/article/details/36865449)\n","slug":"windows-7与linux双系统安装（后续）","published":1,"updated":"2020-03-28T17:37:30.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz1000lws99fdraodnw","content":"<p>前两天美滋滋得安装了 windows 7 下的 linux 双系统 ubuntu，详情见  <a href=\"https://zhuanlan.zhihu.com/p/37277742\" target=\"_blank\" rel=\"noopener\">链接</a> ，以为从此即将开始愉快的学（zhuang）习（bi）之旅了。没想到接下来就是各种强行熟悉其各种命令的噩梦。。。</p>\n<hr>\n<p>首先是各种无法启动</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/7094266-acbb7fb00b6400ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>于是我选择各种重装，结果悲剧了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/7094266-cfe90c6da4aba864.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>每次重启都是这个，崩溃</p>\n<p>于是跟着大神们开始启动救援模式，具体可自行 google“grub rescue”这篇是我写文章时打开的 博客  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012234115/article/details/38110613\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>当我跟着大神们一步步</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls （hdx，msdosx）/</span><br><span class=\"line\"></span><br><span class=\"line\">set root=hdx，msdosx</span><br><span class=\"line\"></span><br><span class=\"line\">set prefix=（hdx，msdosx）/grub</span><br><span class=\"line\"></span><br><span class=\"line\">insmod normal</span><br><span class=\"line\"></span><br><span class=\"line\">normal</span><br></pre></td></tr></table></figure>\n<p>终于成功进入 grub2 界面，即可选择系统（每个人不一样，可以多看看不同博客，有细微差别，我当时尝试了不同格式上述命令，终于属于找到自己电脑的，当你都看完你就都懂了）</p>\n<p>此时问题又来了，我进不了 ubuntu 啊，因为我就是启动不了才发生后续问题的，这个问题至今未解决。。那怎么办，无法更新 grub 就一直会重启出现 grub rescue 啊（鬼知道我打了多少遍上面的命令，相信你懂得）我找了各种解决办法，包括什么用尝试启动 ubuntu 来下载  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012260238/article/details/52713724\" target=\"_blank\" rel=\"noopener\">引导修复（boot repair）</a> ，但是我 ubuntu 无法联网啊，U 盘也没有（上一篇免 U 盘装双系统），还有什么 live cd，都没有不会啊 （上述情况任何一样有都有相应解决方法，可视情况选择，具体我给的链接应该涵盖了）</p>\n<p>在我都打算用 grub rescue 作为引导启动项的时候（每次开机打一遍上面的命令），我发现了新的简便方法，只需用到 EasyBCD（装系统时用到）。由于我们可以进入 grub2 界面进入 windows 系统，因此操作方便（其实之前一直想尝试用 DiskGenius<a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/pkueecser/article/details/6888392\" target=\"_blank\" rel=\"noopener\">参考博客</a>重建 MBR 的方法，但是怕 windows 系统也崩溃。。其实一直最担心的是这个，好多数据的。。结果担心是多余）</p>\n<p>了解 MBR GRUB 可参考博客  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/jscese/article/details/36865449\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>通过 EasyBCD 重建 MBR 解决 grub rescue 的问题具体可参考 博客  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/xuehuafeiwu123/article/details/78829717\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>当然我的 ubuntu 还没删，万一哪天高兴打算再研究一下，估计不行的话会删尝试虚拟机的方法，不过可能还是用笔记本破釜沉舟直接安装 linux 较好，有空在试吧。</p>\n<p>本次装双系统花了 2 个下午加 3 个晚上，终于成功回到了起点。。。</p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p><strong>参考博客：</strong></p>\n<p><a href=\"https://blog.csdn.net/xqhrs232/article/details/50967886\" target=\"_blank\" rel=\"noopener\">ubuntu 无法启动的解决方法 - CSDN 博客</a><br><a href=\"https://blog.csdn.net/u012260238/article/details/52713724\" target=\"_blank\" rel=\"noopener\">双系统 Ubuntu 引导修复（Boot Repair） - CSDN 博客</a><br><a href=\"https://blog.csdn.net/pkueecser/article/details/6888392\" target=\"_blank\" rel=\"noopener\">Win7 与 Ubuntu 双系统时【卸载 Ubuntu】 - CSDN 博客</a><br><a href=\"https://blog.csdn.net/xuehuafeiwu123/article/details/78829717\" target=\"_blank\" rel=\"noopener\">Win7+Ubuntu 双系统，如何卸载 Ubuntu 系统？ - CSDN 博客</a><br><a href=\"https://blog.csdn.net/u012234115/article/details/38110613\" target=\"_blank\" rel=\"noopener\">删除 linux 系统分区后进 windows 出现 grub rescue（已解决） - CSDN 博客</a><br><a href=\"https://blog.csdn.net/jscese/article/details/36865449\" target=\"_blank\" rel=\"noopener\">Ubuntu–grub rescue 主引导修复 - CSDN 博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前两天美滋滋得安装了 windows 7 下的 linux 双系统 ubuntu，详情见  <a href=\"https://zhuanlan.zhihu.com/p/37277742\" target=\"_blank\" rel=\"noopener\">链接</a> ，以为从此即将开始愉快的学（zhuang）习（bi）之旅了。没想到接下来就是各种强行熟悉其各种命令的噩梦。。。</p>\n<hr>\n<p>首先是各种无法启动</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/7094266-acbb7fb00b6400ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>于是我选择各种重装，结果悲剧了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/7094266-cfe90c6da4aba864.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>每次重启都是这个，崩溃</p>\n<p>于是跟着大神们开始启动救援模式，具体可自行 google“grub rescue”这篇是我写文章时打开的 博客  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012234115/article/details/38110613\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>当我跟着大神们一步步</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls （hdx，msdosx）/</span><br><span class=\"line\"></span><br><span class=\"line\">set root=hdx，msdosx</span><br><span class=\"line\"></span><br><span class=\"line\">set prefix=（hdx，msdosx）/grub</span><br><span class=\"line\"></span><br><span class=\"line\">insmod normal</span><br><span class=\"line\"></span><br><span class=\"line\">normal</span><br></pre></td></tr></table></figure>\n<p>终于成功进入 grub2 界面，即可选择系统（每个人不一样，可以多看看不同博客，有细微差别，我当时尝试了不同格式上述命令，终于属于找到自己电脑的，当你都看完你就都懂了）</p>\n<p>此时问题又来了，我进不了 ubuntu 啊，因为我就是启动不了才发生后续问题的，这个问题至今未解决。。那怎么办，无法更新 grub 就一直会重启出现 grub rescue 啊（鬼知道我打了多少遍上面的命令，相信你懂得）我找了各种解决办法，包括什么用尝试启动 ubuntu 来下载  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/u012260238/article/details/52713724\" target=\"_blank\" rel=\"noopener\">引导修复（boot repair）</a> ，但是我 ubuntu 无法联网啊，U 盘也没有（上一篇免 U 盘装双系统），还有什么 live cd，都没有不会啊 （上述情况任何一样有都有相应解决方法，可视情况选择，具体我给的链接应该涵盖了）</p>\n<p>在我都打算用 grub rescue 作为引导启动项的时候（每次开机打一遍上面的命令），我发现了新的简便方法，只需用到 EasyBCD（装系统时用到）。由于我们可以进入 grub2 界面进入 windows 系统，因此操作方便（其实之前一直想尝试用 DiskGenius<a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/pkueecser/article/details/6888392\" target=\"_blank\" rel=\"noopener\">参考博客</a>重建 MBR 的方法，但是怕 windows 系统也崩溃。。其实一直最担心的是这个，好多数据的。。结果担心是多余）</p>\n<p>了解 MBR GRUB 可参考博客  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/jscese/article/details/36865449\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>通过 EasyBCD 重建 MBR 解决 grub rescue 的问题具体可参考 博客  <a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/xuehuafeiwu123/article/details/78829717\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>当然我的 ubuntu 还没删，万一哪天高兴打算再研究一下，估计不行的话会删尝试虚拟机的方法，不过可能还是用笔记本破釜沉舟直接安装 linux 较好，有空在试吧。</p>\n<p>本次装双系统花了 2 个下午加 3 个晚上，终于成功回到了起点。。。</p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p><strong>参考博客：</strong></p>\n<p><a href=\"https://blog.csdn.net/xqhrs232/article/details/50967886\" target=\"_blank\" rel=\"noopener\">ubuntu 无法启动的解决方法 - CSDN 博客</a><br><a href=\"https://blog.csdn.net/u012260238/article/details/52713724\" target=\"_blank\" rel=\"noopener\">双系统 Ubuntu 引导修复（Boot Repair） - CSDN 博客</a><br><a href=\"https://blog.csdn.net/pkueecser/article/details/6888392\" target=\"_blank\" rel=\"noopener\">Win7 与 Ubuntu 双系统时【卸载 Ubuntu】 - CSDN 博客</a><br><a href=\"https://blog.csdn.net/xuehuafeiwu123/article/details/78829717\" target=\"_blank\" rel=\"noopener\">Win7+Ubuntu 双系统，如何卸载 Ubuntu 系统？ - CSDN 博客</a><br><a href=\"https://blog.csdn.net/u012234115/article/details/38110613\" target=\"_blank\" rel=\"noopener\">删除 linux 系统分区后进 windows 出现 grub rescue（已解决） - CSDN 博客</a><br><a href=\"https://blog.csdn.net/jscese/article/details/36865449\" target=\"_blank\" rel=\"noopener\">Ubuntu–grub rescue 主引导修复 - CSDN 博客</a></p>\n"},{"title":"从「从输入 URL 到页面加载」谈及Web性能优化","date":"2018-12-29T06:09:32.000Z","_content":"\n# 如何理解 Web 性能优化\n\n事实上就是用户觉得页面加载很快，用户从输入 URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。\n对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。\n\n# 从输入 URL 到页面加载发生了什么\n\n一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。\n\n## 0. 缓存\n\n当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。\n\n## 1. DNS 查询\n\nDNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nDNS 查询完成之前，浏览器无法从服务器下载任何数据。\n\n### 优化方案：减少 DNS 查询\n\n#### 1.1 DNS 缓存\n\nISP、局域网、操作系统、浏览器等都会有相应的 DNS 缓存机制。\n\n#### 1.2 减少页面的唯一域名\n\n因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。\n\n## 2. TCP 连接\n\n经典的三次握手和四次挥手，不展开赘述。\n简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。\n\n## 3. HTTP 请求及响应\n\n直接讲优化策略\n\n#### 3.1 避免不必要的重定向\n\n> 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问http://astrology.yahoo.com/astrology将被301重定向到 http://astrology.yahoo.com/astrology/（注意末尾的 /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。\n\n#### 3.2 Cookie\n\n##### 3.2.1 减少 Cookie 大小\n\n每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：\n\n- 去除不必要的 Cookie；\n- 尽量压缩 Cookie 大小；\n- 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；\n- 设置合适的过期时间。\n\n##### 3.2.2 静态资源使用无 Cookie 域名\n\n静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。\n\n#### 3.3 添加 Expires 或 Cache-Control 响应头\n\nHTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。\n\n- 静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；\n- 动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。\n\n#### 3.4 配置 Etag\n\n通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。\n\n#### 3.5 使用 Gzip\n\n使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。\nGzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。\n从 HTTP/1.1 开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。\n\n```\nAccept-Encoding: gzip, deflate\n```\n\n服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。\n\n```\nContent-Encoding: gzip\n```\n\n需要注意的是，已经压缩过的内容如图片和 PDF 不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。\n\n### 值得一提\n\nHTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。\n另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：\n\n#### 3.6 延迟加载（懒加载）\n\n页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：\n\n- 非首屏使用的数据、样式、脚本、图片等；\n- 用户交互时才会显示的内容。\n\n遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。\n\n> 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者 type 属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。\n\n#### 3.7 预加载\n\n预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。\n\n## 4. 浏览器解析渲染页面\n\n响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。\n\n#### 4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;\n\n> 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“[怪异模式(兼容模式)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode)”的渲染模式。“`&lt;!DOCTYPE html&gt;`\" 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。\n\n不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。\n\n#### 4.2 CSS 放在 &lt;head&gt; 中\n\n把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。\n这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。\n如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的 HEAD 部分能让页面看起来加载地更快。\n\n#### 4.2 把脚本放在页面底部\n\n浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。\n一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：\n\n- defer 属性；\n- HTML5 新增的 async 属性。\n\n#### 4.3 使用外部 JavaScript 和 CSS\n\n外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。\n当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。\n\n#### 4.4 合并和压缩 JS/CSS 等文件\n\n通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。\n\n#### 4.5 减少 DOM 操作和使用高效的事件处理\n\n- 缓存已经访问过的元素；\n- 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；\n- 操作 className，而不是多次读写 style；\n- 避免使用 JavaScript 修复布局；\n- 减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；\n- 尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。\n\n#### 4.6 图片优化\n\n如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。\n\n#### 4.7 使用 CND\n\n> 内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\n\n动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。\n\n# 总结\n\n![](https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。\n深入阅读 [从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！](https://zhuanlan.zhihu.com/p/34453198)\n\n本文参考：\n[前端性能优化之雅虎 35 条军规](https://juejin.im/post/5b73ef38f265da281e048e51)\n[前端经典面试题: 从输入 URL 到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)\nMDN\n维基百科\n","source":"_posts/从「从输入URL到页面加载」谈及Web性能优化.md","raw":"---\ntitle: 从「从输入 URL 到页面加载」谈及Web性能优化\ndate: 2018-12-29 14:09:32\ntags: Web 性能优化\n---\n\n# 如何理解 Web 性能优化\n\n事实上就是用户觉得页面加载很快，用户从输入 URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。\n对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。\n\n# 从输入 URL 到页面加载发生了什么\n\n一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。\n\n## 0. 缓存\n\n当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。\n\n## 1. DNS 查询\n\nDNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。\n\n![](https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nDNS 查询完成之前，浏览器无法从服务器下载任何数据。\n\n### 优化方案：减少 DNS 查询\n\n#### 1.1 DNS 缓存\n\nISP、局域网、操作系统、浏览器等都会有相应的 DNS 缓存机制。\n\n#### 1.2 减少页面的唯一域名\n\n因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。\n\n## 2. TCP 连接\n\n经典的三次握手和四次挥手，不展开赘述。\n简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。\n\n## 3. HTTP 请求及响应\n\n直接讲优化策略\n\n#### 3.1 避免不必要的重定向\n\n> 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问http://astrology.yahoo.com/astrology将被301重定向到 http://astrology.yahoo.com/astrology/（注意末尾的 /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。\n\n#### 3.2 Cookie\n\n##### 3.2.1 减少 Cookie 大小\n\n每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：\n\n- 去除不必要的 Cookie；\n- 尽量压缩 Cookie 大小；\n- 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；\n- 设置合适的过期时间。\n\n##### 3.2.2 静态资源使用无 Cookie 域名\n\n静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。\n\n#### 3.3 添加 Expires 或 Cache-Control 响应头\n\nHTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。\n\n- 静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；\n- 动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。\n\n#### 3.4 配置 Etag\n\n通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。\n\n#### 3.5 使用 Gzip\n\n使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。\nGzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。\n从 HTTP/1.1 开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。\n\n```\nAccept-Encoding: gzip, deflate\n```\n\n服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。\n\n```\nContent-Encoding: gzip\n```\n\n需要注意的是，已经压缩过的内容如图片和 PDF 不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。\n\n### 值得一提\n\nHTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。\n另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：\n\n#### 3.6 延迟加载（懒加载）\n\n页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：\n\n- 非首屏使用的数据、样式、脚本、图片等；\n- 用户交互时才会显示的内容。\n\n遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。\n\n> 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者 type 属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。\n\n#### 3.7 预加载\n\n预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。\n\n## 4. 浏览器解析渲染页面\n\n响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。\n\n#### 4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;\n\n> 这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“[怪异模式(兼容模式)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode)”的渲染模式。“`&lt;!DOCTYPE html&gt;`\" 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。\n\n不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。\n\n#### 4.2 CSS 放在 &lt;head&gt; 中\n\n把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。\n这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。\n如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的 HEAD 部分能让页面看起来加载地更快。\n\n#### 4.2 把脚本放在页面底部\n\n浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。\n一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：\n\n- defer 属性；\n- HTML5 新增的 async 属性。\n\n#### 4.3 使用外部 JavaScript 和 CSS\n\n外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。\n当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。\n\n#### 4.4 合并和压缩 JS/CSS 等文件\n\n通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。\n\n#### 4.5 减少 DOM 操作和使用高效的事件处理\n\n- 缓存已经访问过的元素；\n- 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；\n- 操作 className，而不是多次读写 style；\n- 避免使用 JavaScript 修复布局；\n- 减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；\n- 尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。\n\n#### 4.6 图片优化\n\n如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。\n\n#### 4.7 使用 CND\n\n> 内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\n\n动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。\n\n# 总结\n\n![](https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。\n深入阅读 [从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！](https://zhuanlan.zhihu.com/p/34453198)\n\n本文参考：\n[前端性能优化之雅虎 35 条军规](https://juejin.im/post/5b73ef38f265da281e048e51)\n[前端经典面试题: 从输入 URL 到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)\nMDN\n维基百科\n","slug":"从「从输入URL到页面加载」谈及Web性能优化","published":1,"updated":"2020-03-28T17:37:50.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz1000mws99xxlc7g9t","content":"<h1 id=\"如何理解-Web-性能优化\"><a href=\"#如何理解-Web-性能优化\" class=\"headerlink\" title=\"如何理解 Web 性能优化\"></a>如何理解 Web 性能优化</h1><p>事实上就是用户觉得页面加载很快，用户从输入 URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。<br>对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。</p>\n<h1 id=\"从输入-URL-到页面加载发生了什么\"><a href=\"#从输入-URL-到页面加载发生了什么\" class=\"headerlink\" title=\"从输入 URL 到页面加载发生了什么\"></a>从输入 URL 到页面加载发生了什么</h1><p>一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。</p>\n<h2 id=\"0-缓存\"><a href=\"#0-缓存\" class=\"headerlink\" title=\"0. 缓存\"></a>0. 缓存</h2><p>当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。</p>\n<h2 id=\"1-DNS-查询\"><a href=\"#1-DNS-查询\" class=\"headerlink\" title=\"1. DNS 查询\"></a>1. DNS 查询</h2><p>DNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>DNS 查询完成之前，浏览器无法从服务器下载任何数据。</p>\n<h3 id=\"优化方案：减少-DNS-查询\"><a href=\"#优化方案：减少-DNS-查询\" class=\"headerlink\" title=\"优化方案：减少 DNS 查询\"></a>优化方案：减少 DNS 查询</h3><h4 id=\"1-1-DNS-缓存\"><a href=\"#1-1-DNS-缓存\" class=\"headerlink\" title=\"1.1 DNS 缓存\"></a>1.1 DNS 缓存</h4><p>ISP、局域网、操作系统、浏览器等都会有相应的 DNS 缓存机制。</p>\n<h4 id=\"1-2-减少页面的唯一域名\"><a href=\"#1-2-减少页面的唯一域名\" class=\"headerlink\" title=\"1.2 减少页面的唯一域名\"></a>1.2 减少页面的唯一域名</h4><p>因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。</p>\n<h2 id=\"2-TCP-连接\"><a href=\"#2-TCP-连接\" class=\"headerlink\" title=\"2. TCP 连接\"></a>2. TCP 连接</h2><p>经典的三次握手和四次挥手，不展开赘述。<br>简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。</p>\n<h2 id=\"3-HTTP-请求及响应\"><a href=\"#3-HTTP-请求及响应\" class=\"headerlink\" title=\"3. HTTP 请求及响应\"></a>3. HTTP 请求及响应</h2><p>直接讲优化策略</p>\n<h4 id=\"3-1-避免不必要的重定向\"><a href=\"#3-1-避免不必要的重定向\" class=\"headerlink\" title=\"3.1 避免不必要的重定向\"></a>3.1 避免不必要的重定向</h4><blockquote>\n<p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问<a href=\"http://astrology.yahoo.com/astrology将被301重定向到\" target=\"_blank\" rel=\"noopener\">http://astrology.yahoo.com/astrology将被301重定向到</a> <a href=\"http://astrology.yahoo.com/astrology/（注意末尾的\" target=\"_blank\" rel=\"noopener\">http://astrology.yahoo.com/astrology/（注意末尾的</a> /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。</p>\n</blockquote>\n<h4 id=\"3-2-Cookie\"><a href=\"#3-2-Cookie\" class=\"headerlink\" title=\"3.2 Cookie\"></a>3.2 Cookie</h4><h5 id=\"3-2-1-减少-Cookie-大小\"><a href=\"#3-2-1-减少-Cookie-大小\" class=\"headerlink\" title=\"3.2.1 减少 Cookie 大小\"></a>3.2.1 减少 Cookie 大小</h5><p>每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：</p>\n<ul>\n<li>去除不必要的 Cookie；</li>\n<li>尽量压缩 Cookie 大小；</li>\n<li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li>\n<li>设置合适的过期时间。</li>\n</ul>\n<h5 id=\"3-2-2-静态资源使用无-Cookie-域名\"><a href=\"#3-2-2-静态资源使用无-Cookie-域名\" class=\"headerlink\" title=\"3.2.2 静态资源使用无 Cookie 域名\"></a>3.2.2 静态资源使用无 Cookie 域名</h5><p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p>\n<h4 id=\"3-3-添加-Expires-或-Cache-Control-响应头\"><a href=\"#3-3-添加-Expires-或-Cache-Control-响应头\" class=\"headerlink\" title=\"3.3 添加 Expires 或 Cache-Control 响应头\"></a>3.3 添加 Expires 或 Cache-Control 响应头</h4><p>HTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。</p>\n<ul>\n<li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li>\n<li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li>\n</ul>\n<h4 id=\"3-4-配置-Etag\"><a href=\"#3-4-配置-Etag\" class=\"headerlink\" title=\"3.4 配置 Etag\"></a>3.4 配置 Etag</h4><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p>\n<h4 id=\"3-5-使用-Gzip\"><a href=\"#3-5-使用-Gzip\" class=\"headerlink\" title=\"3.5 使用 Gzip\"></a>3.5 使用 Gzip</h4><p>使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。<br>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。<br>从 HTTP/1.1 开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>\n<p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，已经压缩过的内容如图片和 PDF 不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。</p>\n<h3 id=\"值得一提\"><a href=\"#值得一提\" class=\"headerlink\" title=\"值得一提\"></a>值得一提</h3><p>HTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。<br>另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：</p>\n<h4 id=\"3-6-延迟加载（懒加载）\"><a href=\"#3-6-延迟加载（懒加载）\" class=\"headerlink\" title=\"3.6 延迟加载（懒加载）\"></a>3.6 延迟加载（懒加载）</h4><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>\n<ul>\n<li>非首屏使用的数据、样式、脚本、图片等；</li>\n<li>用户交互时才会显示的内容。</li>\n</ul>\n<p>遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。</p>\n<blockquote>\n<p>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者 type 属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p>\n</blockquote>\n<h4 id=\"3-7-预加载\"><a href=\"#3-7-预加载\" class=\"headerlink\" title=\"3.7 预加载\"></a>3.7 预加载</h4><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p>\n<h2 id=\"4-浏览器解析渲染页面\"><a href=\"#4-浏览器解析渲染页面\" class=\"headerlink\" title=\"4. 浏览器解析渲染页面\"></a>4. 浏览器解析渲染页面</h2><p>响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。</p>\n<h4 id=\"4-1-写对文档类型声明-lt-DOCTYPE-html-gt\"><a href=\"#4-1-写对文档类型声明-lt-DOCTYPE-html-gt\" class=\"headerlink\" title=\"4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;\"></a>4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;</h4><blockquote>\n<p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\" target=\"_blank\" rel=\"noopener\">怪异模式(兼容模式)</a>”的渲染模式。“<code>&amp;lt;!DOCTYPE html&amp;gt;</code>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p>\n</blockquote>\n<p>不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。</p>\n<h4 id=\"4-2-CSS-放在-lt-head-gt-中\"><a href=\"#4-2-CSS-放在-lt-head-gt-中\" class=\"headerlink\" title=\"4.2 CSS 放在 &lt;head&gt; 中\"></a>4.2 CSS 放在 &lt;head&gt; 中</h4><p>把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。<br>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。<br>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的 HEAD 部分能让页面看起来加载地更快。</p>\n<h4 id=\"4-2-把脚本放在页面底部\"><a href=\"#4-2-把脚本放在页面底部\" class=\"headerlink\" title=\"4.2 把脚本放在页面底部\"></a>4.2 把脚本放在页面底部</h4><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。<br>一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：</p>\n<ul>\n<li>defer 属性；</li>\n<li>HTML5 新增的 async 属性。</li>\n</ul>\n<h4 id=\"4-3-使用外部-JavaScript-和-CSS\"><a href=\"#4-3-使用外部-JavaScript-和-CSS\" class=\"headerlink\" title=\"4.3 使用外部 JavaScript 和 CSS\"></a>4.3 使用外部 JavaScript 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p>\n<h4 id=\"4-4-合并和压缩-JS-CSS-等文件\"><a href=\"#4-4-合并和压缩-JS-CSS-等文件\" class=\"headerlink\" title=\"4.4 合并和压缩 JS/CSS 等文件\"></a>4.4 合并和压缩 JS/CSS 等文件</h4><p>通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。</p>\n<h4 id=\"4-5-减少-DOM-操作和使用高效的事件处理\"><a href=\"#4-5-减少-DOM-操作和使用高效的事件处理\" class=\"headerlink\" title=\"4.5 减少 DOM 操作和使用高效的事件处理\"></a>4.5 减少 DOM 操作和使用高效的事件处理</h4><ul>\n<li>缓存已经访问过的元素；</li>\n<li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li>\n<li>操作 className，而不是多次读写 style；</li>\n<li>避免使用 JavaScript 修复布局；</li>\n<li>减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；</li>\n<li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li>\n</ul>\n<h4 id=\"4-6-图片优化\"><a href=\"#4-6-图片优化\" class=\"headerlink\" title=\"4.6 图片优化\"></a>4.6 图片优化</h4><p>如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。</p>\n<h4 id=\"4-7-使用-CND\"><a href=\"#4-7-使用-CND\" class=\"headerlink\" title=\"4.7 使用 CND\"></a>4.7 使用 CND</h4><blockquote>\n<p>内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>\n</blockquote>\n<p>动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。<br>深入阅读 <a href=\"https://zhuanlan.zhihu.com/p/34453198\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p>\n<p>本文参考：<br><a href=\"https://juejin.im/post/5b73ef38f265da281e048e51\" target=\"_blank\" rel=\"noopener\">前端性能优化之雅虎 35 条军规</a><br><a href=\"https://segmentfault.com/a/1190000006879700\" target=\"_blank\" rel=\"noopener\">前端经典面试题: 从输入 URL 到页面加载发生了什么？</a><br>MDN<br>维基百科</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"如何理解-Web-性能优化\"><a href=\"#如何理解-Web-性能优化\" class=\"headerlink\" title=\"如何理解 Web 性能优化\"></a>如何理解 Web 性能优化</h1><p>事实上就是用户觉得页面加载很快，用户从输入 URL（网址）到页面在浏览器上加载出来的时间很短；与之相对的有如服务器性能优化（如网页占的 CPU 少），一定要区分开来。<br>对于用户众多的网站，节约下的加载时间或能带来可观的收入，这便是前端 Web 性能优化的意义。</p>\n<h1 id=\"从输入-URL-到页面加载发生了什么\"><a href=\"#从输入-URL-到页面加载发生了什么\" class=\"headerlink\" title=\"从输入 URL 到页面加载发生了什么\"></a>从输入 URL 到页面加载发生了什么</h1><p>一道所有前端耳熟能详的经典面试题，也确实是需要前端去深入研究的东西。下面我会简单介绍其过程，并罗列相关的 Web 优化方案。</p>\n<h2 id=\"0-缓存\"><a href=\"#0-缓存\" class=\"headerlink\" title=\"0. 缓存\"></a>0. 缓存</h2><p>当我们在浏览器上输入网址，浏览器首先会查看是否有缓存，如果之前已经访问过该网站，则会有缓存，那浏览器就不必再向服务器发请求了，用户则能够很快得看到内容。Web 性能优化有极大一部分都是优化缓存，缓存事实上又分为数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存等，部分内容后文介绍。</p>\n<h2 id=\"1-DNS-查询\"><a href=\"#1-DNS-查询\" class=\"headerlink\" title=\"1. DNS 查询\"></a>1. DNS 查询</h2><p>DNS 查询就像电话簿，你在浏览器地址栏输入网址，通过 DNS 查询得到域名的真实 IP。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-d21c9b5e4b39ad6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>DNS 查询完成之前，浏览器无法从服务器下载任何数据。</p>\n<h3 id=\"优化方案：减少-DNS-查询\"><a href=\"#优化方案：减少-DNS-查询\" class=\"headerlink\" title=\"优化方案：减少 DNS 查询\"></a>优化方案：减少 DNS 查询</h3><h4 id=\"1-1-DNS-缓存\"><a href=\"#1-1-DNS-缓存\" class=\"headerlink\" title=\"1.1 DNS 缓存\"></a>1.1 DNS 缓存</h4><p>ISP、局域网、操作系统、浏览器等都会有相应的 DNS 缓存机制。</p>\n<h4 id=\"1-2-减少页面的唯一域名\"><a href=\"#1-2-减少页面的唯一域名\" class=\"headerlink\" title=\"1.2 减少页面的唯一域名\"></a>1.2 减少页面的唯一域名</h4><p>因为每次 DNS 查询就是查找唯一域名的过程，那么域名越少，DNS 查询就越少，应该尽量将资源放在同一域名。当然这样做又有其他问题，下文详解。</p>\n<h2 id=\"2-TCP-连接\"><a href=\"#2-TCP-连接\" class=\"headerlink\" title=\"2. TCP 连接\"></a>2. TCP 连接</h2><p>经典的三次握手和四次挥手，不展开赘述。<br>简单讲讲优化方案：TCP 连接复用（TCP Connection Reuse），在 HTTP 请求头中的 Connection 上加 keep-alive；HTTP/2.0 多路复用等。</p>\n<h2 id=\"3-HTTP-请求及响应\"><a href=\"#3-HTTP-请求及响应\" class=\"headerlink\" title=\"3. HTTP 请求及响应\"></a>3. HTTP 请求及响应</h2><p>直接讲优化策略</p>\n<h4 id=\"3-1-避免不必要的重定向\"><a href=\"#3-1-避免不必要的重定向\" class=\"headerlink\" title=\"3.1 避免不必要的重定向\"></a>3.1 避免不必要的重定向</h4><blockquote>\n<p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。比如，访问<a href=\"http://astrology.yahoo.com/astrology将被301重定向到\" target=\"_blank\" rel=\"noopener\">http://astrology.yahoo.com/astrology将被301重定向到</a> <a href=\"http://astrology.yahoo.com/astrology/（注意末尾的\" target=\"_blank\" rel=\"noopener\">http://astrology.yahoo.com/astrology/（注意末尾的</a> /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。</p>\n</blockquote>\n<h4 id=\"3-2-Cookie\"><a href=\"#3-2-Cookie\" class=\"headerlink\" title=\"3.2 Cookie\"></a>3.2 Cookie</h4><h5 id=\"3-2-1-减少-Cookie-大小\"><a href=\"#3-2-1-减少-Cookie-大小\" class=\"headerlink\" title=\"3.2.1 减少 Cookie 大小\"></a>3.2.1 减少 Cookie 大小</h5><p>每次请求都会带上对应的 Cookie，减少 Cookie 大小可以降低其对响应速度的影响：</p>\n<ul>\n<li>去除不必要的 Cookie；</li>\n<li>尽量压缩 Cookie 大小；</li>\n<li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li>\n<li>设置合适的过期时间。</li>\n</ul>\n<h5 id=\"3-2-2-静态资源使用无-Cookie-域名\"><a href=\"#3-2-2-静态资源使用无-Cookie-域名\" class=\"headerlink\" title=\"3.2.2 静态资源使用无 Cookie 域名\"></a>3.2.2 静态资源使用无 Cookie 域名</h5><p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p>\n<h4 id=\"3-3-添加-Expires-或-Cache-Control-响应头\"><a href=\"#3-3-添加-Expires-或-Cache-Control-响应头\" class=\"headerlink\" title=\"3.3 添加 Expires 或 Cache-Control 响应头\"></a>3.3 添加 Expires 或 Cache-Control 响应头</h4><p>HTTP/1.1 增加的 Cache-Control，它比 Expires 等好在其设定时间是相对的，避免了用户本地设置时间落后所造成的无法良好缓存的问题等。</p>\n<ul>\n<li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li>\n<li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li>\n</ul>\n<h4 id=\"3-4-配置-Etag\"><a href=\"#3-4-配置-Etag\" class=\"headerlink\" title=\"3.4 配置 Etag\"></a>3.4 配置 Etag</h4><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p>\n<h4 id=\"3-5-使用-Gzip\"><a href=\"#3-5-使用-Gzip\" class=\"headerlink\" title=\"3.5 使用 Gzip\"></a>3.5 使用 Gzip</h4><p>使用 Gzip 就是将 HTML、CSS、JS、XML、JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快。<br>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 Gzip 解码。<br>从 HTTP/1.1 开始，客户端就有了支持压缩的 Accept-Encoding HTTP 请求头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>\n<p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，已经压缩过的内容如图片和 PDF 不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且还可能增加文件体积。</p>\n<h3 id=\"值得一提\"><a href=\"#值得一提\" class=\"headerlink\" title=\"值得一提\"></a>值得一提</h3><p>HTTP 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求，但是同一域名最多同时发送 4~8 个（不同浏览器不同）请求，那么当资源过多时，可以采用增加域名的方法增加并发量。当然这一方法又与上述 DNS 查询的优化方案矛盾，真正使用的时候就需要权衡。<br>另外，既然一次只能发的请求有限，就应该将重要的需要优先展示的资源先请求：</p>\n<h4 id=\"3-6-延迟加载（懒加载）\"><a href=\"#3-6-延迟加载（懒加载）\" class=\"headerlink\" title=\"3.6 延迟加载（懒加载）\"></a>3.6 延迟加载（懒加载）</h4><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>\n<ul>\n<li>非首屏使用的数据、样式、脚本、图片等；</li>\n<li>用户交互时才会显示的内容。</li>\n</ul>\n<p>遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。</p>\n<blockquote>\n<p>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的&lt;textarea&gt;，或者 type 属性为非执行脚本的 &lt;script&gt; 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p>\n</blockquote>\n<h4 id=\"3-7-预加载\"><a href=\"#3-7-预加载\" class=\"headerlink\" title=\"3.7 预加载\"></a>3.7 预加载</h4><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p>\n<h2 id=\"4-浏览器解析渲染页面\"><a href=\"#4-浏览器解析渲染页面\" class=\"headerlink\" title=\"4. 浏览器解析渲染页面\"></a>4. 浏览器解析渲染页面</h2><p>响应完成后，浏览器下载完资源，就开始解析资源生成页面了。对于前端来说，这部分内容是完全需要我们去掌控的，我们也来简单介绍一下对应的优化内容，部分内容如懒加载等上面已经提及就不再重复。</p>\n<h4 id=\"4-1-写对文档类型声明-lt-DOCTYPE-html-gt\"><a href=\"#4-1-写对文档类型声明-lt-DOCTYPE-html-gt\" class=\"headerlink\" title=\"4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;\"></a>4.1 写对文档类型声明 &lt;!DOCTYPE html&gt;</h4><blockquote>\n<p>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\" target=\"_blank\" rel=\"noopener\">怪异模式(兼容模式)</a>”的渲染模式。“<code>&amp;lt;!DOCTYPE html&amp;gt;</code>“ 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p>\n</blockquote>\n<p>不写或写错文档类型声明，会浪费浏览器渲染页面的时间或引起错误排版。</p>\n<h4 id=\"4-2-CSS-放在-lt-head-gt-中\"><a href=\"#4-2-CSS-放在-lt-head-gt-中\" class=\"headerlink\" title=\"4.2 CSS 放在 &lt;head&gt; 中\"></a>4.2 CSS 放在 &lt;head&gt; 中</h4><p>把样式表放在 &lt;head&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。<br>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。<br>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的 HEAD 部分能让页面看起来加载地更快。</p>\n<h4 id=\"4-2-把脚本放在页面底部\"><a href=\"#4-2-把脚本放在页面底部\" class=\"headerlink\" title=\"4.2 把脚本放在页面底部\"></a>4.2 把脚本放在页面底部</h4><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源，并且，没有 js 并不邮箱呈现在用户目前的内容的观感。因此，最好将脚本放在底部，以提高页面加载速度。<br>一些特殊场景无法将脚本放到页面底部的，可以考虑&lt;script&gt;的以下属性：</p>\n<ul>\n<li>defer 属性；</li>\n<li>HTML5 新增的 async 属性。</li>\n</ul>\n<h4 id=\"4-3-使用外部-JavaScript-和-CSS\"><a href=\"#4-3-使用外部-JavaScript-和-CSS\" class=\"headerlink\" title=\"4.3 使用外部 JavaScript 和 CSS\"></a>4.3 使用外部 JavaScript 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p>\n<h4 id=\"4-4-合并和压缩-JS-CSS-等文件\"><a href=\"#4-4-合并和压缩-JS-CSS-等文件\" class=\"headerlink\" title=\"4.4 合并和压缩 JS/CSS 等文件\"></a>4.4 合并和压缩 JS/CSS 等文件</h4><p>通过该方法减少页面所需资源，减少请求数量，加快响应时间。现在 webpack 打包工具都已经默认实现了。</p>\n<h4 id=\"4-5-减少-DOM-操作和使用高效的事件处理\"><a href=\"#4-5-减少-DOM-操作和使用高效的事件处理\" class=\"headerlink\" title=\"4.5 减少 DOM 操作和使用高效的事件处理\"></a>4.5 减少 DOM 操作和使用高效的事件处理</h4><ul>\n<li>缓存已经访问过的元素；</li>\n<li>使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；</li>\n<li>操作 className，而不是多次读写 style；</li>\n<li>避免使用 JavaScript 修复布局；</li>\n<li>减少绑定事件监听的节点，如通过事件委托（当然现在浏览器功能强大，影响不大）；</li>\n<li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li>\n</ul>\n<h4 id=\"4-6-图片优化\"><a href=\"#4-6-图片优化\" class=\"headerlink\" title=\"4.6 图片优化\"></a>4.6 图片优化</h4><p>如何将图片变得又小又好看是一个工程师实力的体现，这里不过多赘述，大家可以查看我后文提供的资源。</p>\n<h4 id=\"4-7-使用-CND\"><a href=\"#4-7-使用-CND\" class=\"headerlink\" title=\"4.7 使用 CND\"></a>4.7 使用 CND</h4><blockquote>\n<p>内容分发网络（Content delivery network 或 Content distribution network）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>\n</blockquote>\n<p>动态 CDN，使用离你最近的服务器；CDN 没有 Cookie，使用 CDN 可以减少 Cookie；CND 会自动合并脚本文件等，减少请求数量；当然，使用 CND 同时也增加了一个域名，增大了同时请求数量。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-2696c8f1d212f5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>该文大量参考了雅虎 35 军规，增加了一些自己的理解并舍弃了一些已经过时的内容。细节内容比较少，主要是笼统地将 Web 性能优化的思路做了梳理，很多内容都值得我们去深入研究。当然其中部分内容顺序还是不佳，因为很多内容事实上是贯穿在整个过程当中的，正如 Web 性能优化是个整体，需要权衡所有冲突。希望本文可以给你一些在面试官问道你时的思路。<br>深入阅读 <a href=\"https://zhuanlan.zhihu.com/p/34453198\" target=\"_blank\" rel=\"noopener\">从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></p>\n<p>本文参考：<br><a href=\"https://juejin.im/post/5b73ef38f265da281e048e51\" target=\"_blank\" rel=\"noopener\">前端性能优化之雅虎 35 条军规</a><br><a href=\"https://segmentfault.com/a/1190000006879700\" target=\"_blank\" rel=\"noopener\">前端经典面试题: 从输入 URL 到页面加载发生了什么？</a><br>MDN<br>维基百科</p>\n"},{"title":"一次性理解立即执行函数和闭包","date":"2018-08-19T16:29:46.000Z","_content":"\n# Immediately-Invoked Function Expression（IIFE）：立即调用函数表达式\n\n**使用全局变量可能会造成一些不必要的麻烦\n因此我们要使用局部变量**\n\n在 java 语言中我们可以用 { } 将代码包裹起来，使它们成为局部变量\n但是这在 ES5 中不行，因为 var 有变量提升\n\n```\n{\n  var a = 1;\n}\n// 上面代码等同于\nvar a\n{\n  a = 1;\n}\n```\n\n**ES6 里面引入了 let 的概念，于是有了块级作用域**\n解决了这个问题，IIFE 似乎就变得不那么必要了\n\n```\n{\n  let a = 1;\n}\na\n// Uncaught ReferenceError: a is not defined\n```\n\n但是了解 IIFE 可以让我们初学者更好得理解函数表达式、变量提升等的概念，以及了解前端语言的发展进程，知道前人一步步将原本不那么美好的 js 变得规范化的过程，学习他们的智慧。\n\n**ES5 里面，没有块级作用域，只有函数（函数作用域）可提供局部变量环境**\n于是我们声明一个 function xxx，然后 xxx.call()\n\n```\nfunction xxx(){\n  var a = 1;\n}.call()\n```\n\n但是这个时候 xxx 也是全局变量（全局函数）\n所以我们不能给这个函数名字，即需要使用**匿名函数**\n\n```\nfunction(){\n  var a = 1;\n}.call()\n// Uncaught SyntaxError: Unexpected token (\n```\n\n但是这在 Chrome 里会报错，js 语法错误\n\n**这是由于浏览器认为这是一个函数声明\n解决办法：让浏览器去解析这个函数表达式**\n如给函数取反\n\n```\n! function(){\n  var a = 1;\n}.call()\n// 我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系\n```\n\n类似的还有\n\n```\n+function(){}()\n-function(){}()\n~function(){}()\nvoid function(){}()\nnew function(){}()\n// function(){}() === function(){}.call()\n//用 .call() 更清楚\n```\n\n如果实在不想改变函数返回值，也可以用圆括号\n\n```\n(function(){}).call()\n(function(){}.call())\n```\n\n但是方法会有不好的情况：如果括号前面有东西\n\n```\na\n(function(){}).call()\n//等价于\na().call()\n//这不是我们想要的\n//同理\na\n(function(){}.call())\n//等价于\na()\n```\n\n所以不推荐\n\n你也可以用一个随机变量名函数而不用匿名函数，永远都不会变量污染的那种变量（这种方法好吗？）\n\n```\nfunction ada231231284u3lkda(){\n  var a = 1;\n}.call()\n```\n\n**当然最推荐的还是用取反 ！，这就好像是个警示：我要开始用 IIFE 了**\n\n---\n\n**IIFE 达到了局部变量的效果，外面访问不到立即执行函数里面的变量（避免变量污染）**\n\n**但有时候我们需要访问 IIFE 里面的内容，怎么办？**\n最简单的方法是直接用全局变量 window\n\n```\n! function(){\n  var a = window.a = {\n    n: 1\n  }\n}.call()\n// 另一个立即执行函数通过 window.a 访问\n! function(){\n  var b = window.a\n  console.log(a)\n}.call() // {n: 1}\n```\n\n**我们还可以在 IIFE 里面使用闭包来隐藏 a**\n\n```\n! function(){\n  var a = {\n    n: 1\n  }\n  // 声明一个匿名函数保存于 window.nAdd1\n  window.nAdd1 = function(){\n    a.n += 1\n    // return 新的 a.n\n    return a.n\n  }\n}.call()\n// 匿名函数可以操作函数外面的变量 a ，这就是闭包\n// 另一个立即执行函数通过 window 访问\n! function(){\n  var b = window.nAdd1()\n  console.log(newN)\n}.call() // 2\n```\n\n**IIFE 使得 a 成为局部变量而无法被外部访问\n闭包使得匿名函数可以操作 a\nwindow.nAdd1 保存了匿名函数的地址\n任何地方都可以使用 window.nAdd1\n=> 任何地方都可以使用 window.nAdd1 操作 a，但是不能直接访问 a\n这就是 window 和闭包联合作用的效果**\n\n# 闭包\n\n将上面代码整合在一起，就是闭包的常见形式\n\n```\nfunction fn(){\n  var a = {\n    n: 1\n  }\n  function fn2(){\n    a.n += 1\n    return a.n\n  }\n  return fn2\n}\nvar fn1 = fn()\nfn1() // 2\n// 上面代码其实就是\n(function(){\n  var a = {\n    n: 1\n  }\n  return function(){\n    a.n += 1\n    return a.n\n  }\n}.call()) // IIFE\n.call()// 2\n```\n\n**现在我们明白了为什么闭包一般在 IIFE 里出现**\nIIFE 提供局部变量的环境，才有闭包的用武之地\n**return 的作用**\n上面代码中的 return 和 window 的作用一样，是为了让外部能够访问函数作用域内部的函数，当然 return a.n 的作用也是如此\n\n**而闭包的作用，至此应该理解了**\n\n---\n\n本文仅作为个人学习使用\n\n相关参考：\n[Immediately-Invoked Function Expression (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife)\n[「每日一题」什么是立即执行函数？有什么作用？](https://zhuanlan.zhihu.com/p/22465092)\n[「每日一题」JS 中的闭包是什么？](https://zhuanlan.zhihu.com/p/22486908)\n[JS 标准参考教程——IIFE](https://wangdoc.com/javascript/types/function.html#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88iife%EF%BC%89)\n[ES6 入门——let#块级作用域](http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F)\n","source":"_posts/一次性理解立即执行函数和闭包.md","raw":"---\ntitle: 一次性理解立即执行函数和闭包\ndate: 2018-08-20 00:29:46\ntags: JavaScript\n---\n\n# Immediately-Invoked Function Expression（IIFE）：立即调用函数表达式\n\n**使用全局变量可能会造成一些不必要的麻烦\n因此我们要使用局部变量**\n\n在 java 语言中我们可以用 { } 将代码包裹起来，使它们成为局部变量\n但是这在 ES5 中不行，因为 var 有变量提升\n\n```\n{\n  var a = 1;\n}\n// 上面代码等同于\nvar a\n{\n  a = 1;\n}\n```\n\n**ES6 里面引入了 let 的概念，于是有了块级作用域**\n解决了这个问题，IIFE 似乎就变得不那么必要了\n\n```\n{\n  let a = 1;\n}\na\n// Uncaught ReferenceError: a is not defined\n```\n\n但是了解 IIFE 可以让我们初学者更好得理解函数表达式、变量提升等的概念，以及了解前端语言的发展进程，知道前人一步步将原本不那么美好的 js 变得规范化的过程，学习他们的智慧。\n\n**ES5 里面，没有块级作用域，只有函数（函数作用域）可提供局部变量环境**\n于是我们声明一个 function xxx，然后 xxx.call()\n\n```\nfunction xxx(){\n  var a = 1;\n}.call()\n```\n\n但是这个时候 xxx 也是全局变量（全局函数）\n所以我们不能给这个函数名字，即需要使用**匿名函数**\n\n```\nfunction(){\n  var a = 1;\n}.call()\n// Uncaught SyntaxError: Unexpected token (\n```\n\n但是这在 Chrome 里会报错，js 语法错误\n\n**这是由于浏览器认为这是一个函数声明\n解决办法：让浏览器去解析这个函数表达式**\n如给函数取反\n\n```\n! function(){\n  var a = 1;\n}.call()\n// 我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系\n```\n\n类似的还有\n\n```\n+function(){}()\n-function(){}()\n~function(){}()\nvoid function(){}()\nnew function(){}()\n// function(){}() === function(){}.call()\n//用 .call() 更清楚\n```\n\n如果实在不想改变函数返回值，也可以用圆括号\n\n```\n(function(){}).call()\n(function(){}.call())\n```\n\n但是方法会有不好的情况：如果括号前面有东西\n\n```\na\n(function(){}).call()\n//等价于\na().call()\n//这不是我们想要的\n//同理\na\n(function(){}.call())\n//等价于\na()\n```\n\n所以不推荐\n\n你也可以用一个随机变量名函数而不用匿名函数，永远都不会变量污染的那种变量（这种方法好吗？）\n\n```\nfunction ada231231284u3lkda(){\n  var a = 1;\n}.call()\n```\n\n**当然最推荐的还是用取反 ！，这就好像是个警示：我要开始用 IIFE 了**\n\n---\n\n**IIFE 达到了局部变量的效果，外面访问不到立即执行函数里面的变量（避免变量污染）**\n\n**但有时候我们需要访问 IIFE 里面的内容，怎么办？**\n最简单的方法是直接用全局变量 window\n\n```\n! function(){\n  var a = window.a = {\n    n: 1\n  }\n}.call()\n// 另一个立即执行函数通过 window.a 访问\n! function(){\n  var b = window.a\n  console.log(a)\n}.call() // {n: 1}\n```\n\n**我们还可以在 IIFE 里面使用闭包来隐藏 a**\n\n```\n! function(){\n  var a = {\n    n: 1\n  }\n  // 声明一个匿名函数保存于 window.nAdd1\n  window.nAdd1 = function(){\n    a.n += 1\n    // return 新的 a.n\n    return a.n\n  }\n}.call()\n// 匿名函数可以操作函数外面的变量 a ，这就是闭包\n// 另一个立即执行函数通过 window 访问\n! function(){\n  var b = window.nAdd1()\n  console.log(newN)\n}.call() // 2\n```\n\n**IIFE 使得 a 成为局部变量而无法被外部访问\n闭包使得匿名函数可以操作 a\nwindow.nAdd1 保存了匿名函数的地址\n任何地方都可以使用 window.nAdd1\n=> 任何地方都可以使用 window.nAdd1 操作 a，但是不能直接访问 a\n这就是 window 和闭包联合作用的效果**\n\n# 闭包\n\n将上面代码整合在一起，就是闭包的常见形式\n\n```\nfunction fn(){\n  var a = {\n    n: 1\n  }\n  function fn2(){\n    a.n += 1\n    return a.n\n  }\n  return fn2\n}\nvar fn1 = fn()\nfn1() // 2\n// 上面代码其实就是\n(function(){\n  var a = {\n    n: 1\n  }\n  return function(){\n    a.n += 1\n    return a.n\n  }\n}.call()) // IIFE\n.call()// 2\n```\n\n**现在我们明白了为什么闭包一般在 IIFE 里出现**\nIIFE 提供局部变量的环境，才有闭包的用武之地\n**return 的作用**\n上面代码中的 return 和 window 的作用一样，是为了让外部能够访问函数作用域内部的函数，当然 return a.n 的作用也是如此\n\n**而闭包的作用，至此应该理解了**\n\n---\n\n本文仅作为个人学习使用\n\n相关参考：\n[Immediately-Invoked Function Expression (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife)\n[「每日一题」什么是立即执行函数？有什么作用？](https://zhuanlan.zhihu.com/p/22465092)\n[「每日一题」JS 中的闭包是什么？](https://zhuanlan.zhihu.com/p/22486908)\n[JS 标准参考教程——IIFE](https://wangdoc.com/javascript/types/function.html#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88iife%EF%BC%89)\n[ES6 入门——let#块级作用域](http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F)\n","slug":"一次性理解立即执行函数和闭包","published":1,"updated":"2020-03-28T17:28:51.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz2000nws99ggw9neod","content":"<h1 id=\"Immediately-Invoked-Function-Expression（IIFE）：立即调用函数表达式\"><a href=\"#Immediately-Invoked-Function-Expression（IIFE）：立即调用函数表达式\" class=\"headerlink\" title=\"Immediately-Invoked Function Expression（IIFE）：立即调用函数表达式\"></a>Immediately-Invoked Function Expression（IIFE）：立即调用函数表达式</h1><p><strong>使用全局变量可能会造成一些不必要的麻烦<br>因此我们要使用局部变量</strong></p>\n<p>在 java 语言中我们可以用 { } 将代码包裹起来，使它们成为局部变量<br>但是这在 ES5 中不行，因为 var 有变量提升</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 上面代码等同于</span><br><span class=\"line\">var a</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  a = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>ES6 里面引入了 let 的概念，于是有了块级作用域</strong><br>解决了这个问题，IIFE 似乎就变得不那么必要了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a</span><br><span class=\"line\">// Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>\n<p>但是了解 IIFE 可以让我们初学者更好得理解函数表达式、变量提升等的概念，以及了解前端语言的发展进程，知道前人一步步将原本不那么美好的 js 变得规范化的过程，学习他们的智慧。</p>\n<p><strong>ES5 里面，没有块级作用域，只有函数（函数作用域）可提供局部变量环境</strong><br>于是我们声明一个 function xxx，然后 xxx.call()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>但是这个时候 xxx 也是全局变量（全局函数）<br>所以我们不能给这个函数名字，即需要使用<strong>匿名函数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// Uncaught SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure>\n<p>但是这在 Chrome 里会报错，js 语法错误</p>\n<p><strong>这是由于浏览器认为这是一个函数声明<br>解决办法：让浏览器去解析这个函数表达式</strong><br>如给函数取反</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// 我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系</span><br></pre></td></tr></table></figure>\n<p>类似的还有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+function()&#123;&#125;()</span><br><span class=\"line\">-function()&#123;&#125;()</span><br><span class=\"line\">~function()&#123;&#125;()</span><br><span class=\"line\">void function()&#123;&#125;()</span><br><span class=\"line\">new function()&#123;&#125;()</span><br><span class=\"line\">// function()&#123;&#125;() === function()&#123;&#125;.call()</span><br><span class=\"line\">//用 .call() 更清楚</span><br></pre></td></tr></table></figure>\n<p>如果实在不想改变函数返回值，也可以用圆括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;&#125;).call()</span><br><span class=\"line\">(function()&#123;&#125;.call())</span><br></pre></td></tr></table></figure>\n<p>但是方法会有不好的情况：如果括号前面有东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">(function()&#123;&#125;).call()</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">a().call()</span><br><span class=\"line\">//这不是我们想要的</span><br><span class=\"line\">//同理</span><br><span class=\"line\">a</span><br><span class=\"line\">(function()&#123;&#125;.call())</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<p>所以不推荐</p>\n<p>你也可以用一个随机变量名函数而不用匿名函数，永远都不会变量污染的那种变量（这种方法好吗？）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ada231231284u3lkda()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p><strong>当然最推荐的还是用取反 ！，这就好像是个警示：我要开始用 IIFE 了</strong></p>\n<hr>\n<p><strong>IIFE 达到了局部变量的效果，外面访问不到立即执行函数里面的变量（避免变量污染）</strong></p>\n<p><strong>但有时候我们需要访问 IIFE 里面的内容，怎么办？</strong><br>最简单的方法是直接用全局变量 window</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var a = window.a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// 另一个立即执行函数通过 window.a 访问</span><br><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var b = window.a</span><br><span class=\"line\">  console.log(a)</span><br><span class=\"line\">&#125;.call() // &#123;n: 1&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们还可以在 IIFE 里面使用闭包来隐藏 a</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 声明一个匿名函数保存于 window.nAdd1</span><br><span class=\"line\">  window.nAdd1 = function()&#123;</span><br><span class=\"line\">    a.n += 1</span><br><span class=\"line\">    // return 新的 a.n</span><br><span class=\"line\">    return a.n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// 匿名函数可以操作函数外面的变量 a ，这就是闭包</span><br><span class=\"line\">// 另一个立即执行函数通过 window 访问</span><br><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var b = window.nAdd1()</span><br><span class=\"line\">  console.log(newN)</span><br><span class=\"line\">&#125;.call() // 2</span><br></pre></td></tr></table></figure>\n<p><strong>IIFE 使得 a 成为局部变量而无法被外部访问<br>闭包使得匿名函数可以操作 a<br>window.nAdd1 保存了匿名函数的地址<br>任何地方都可以使用 window.nAdd1<br>=&gt; 任何地方都可以使用 window.nAdd1 操作 a，但是不能直接访问 a<br>这就是 window 和闭包联合作用的效果</strong></p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>将上面代码整合在一起，就是闭包的常见形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">  var a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function fn2()&#123;</span><br><span class=\"line\">    a.n += 1</span><br><span class=\"line\">    return a.n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return fn2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn1 = fn()</span><br><span class=\"line\">fn1() // 2</span><br><span class=\"line\">// 上面代码其实就是</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return function()&#123;</span><br><span class=\"line\">    a.n += 1</span><br><span class=\"line\">    return a.n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call()) // IIFE</span><br><span class=\"line\">.call()// 2</span><br></pre></td></tr></table></figure>\n<p><strong>现在我们明白了为什么闭包一般在 IIFE 里出现</strong><br>IIFE 提供局部变量的环境，才有闭包的用武之地<br><strong>return 的作用</strong><br>上面代码中的 return 和 window 的作用一样，是为了让外部能够访问函数作用域内部的函数，当然 return a.n 的作用也是如此</p>\n<p><strong>而闭包的作用，至此应该理解了</strong></p>\n<hr>\n<p>本文仅作为个人学习使用</p>\n<p>相关参考：<br><a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife\" target=\"_blank\" rel=\"noopener\">Immediately-Invoked Function Expression (IIFE)</a><br><a href=\"https://zhuanlan.zhihu.com/p/22465092\" target=\"_blank\" rel=\"noopener\">「每日一题」什么是立即执行函数？有什么作用？</a><br><a href=\"https://zhuanlan.zhihu.com/p/22486908\" target=\"_blank\" rel=\"noopener\">「每日一题」JS 中的闭包是什么？</a><br><a href=\"https://wangdoc.com/javascript/types/function.html#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88iife%EF%BC%89\" target=\"_blank\" rel=\"noopener\">JS 标准参考教程——IIFE</a><br><a href=\"http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\" target=\"_blank\" rel=\"noopener\">ES6 入门——let#块级作用域</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Immediately-Invoked-Function-Expression（IIFE）：立即调用函数表达式\"><a href=\"#Immediately-Invoked-Function-Expression（IIFE）：立即调用函数表达式\" class=\"headerlink\" title=\"Immediately-Invoked Function Expression（IIFE）：立即调用函数表达式\"></a>Immediately-Invoked Function Expression（IIFE）：立即调用函数表达式</h1><p><strong>使用全局变量可能会造成一些不必要的麻烦<br>因此我们要使用局部变量</strong></p>\n<p>在 java 语言中我们可以用 { } 将代码包裹起来，使它们成为局部变量<br>但是这在 ES5 中不行，因为 var 有变量提升</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 上面代码等同于</span><br><span class=\"line\">var a</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  a = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>ES6 里面引入了 let 的概念，于是有了块级作用域</strong><br>解决了这个问题，IIFE 似乎就变得不那么必要了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a</span><br><span class=\"line\">// Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>\n<p>但是了解 IIFE 可以让我们初学者更好得理解函数表达式、变量提升等的概念，以及了解前端语言的发展进程，知道前人一步步将原本不那么美好的 js 变得规范化的过程，学习他们的智慧。</p>\n<p><strong>ES5 里面，没有块级作用域，只有函数（函数作用域）可提供局部变量环境</strong><br>于是我们声明一个 function xxx，然后 xxx.call()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p>但是这个时候 xxx 也是全局变量（全局函数）<br>所以我们不能给这个函数名字，即需要使用<strong>匿名函数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// Uncaught SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure>\n<p>但是这在 Chrome 里会报错，js 语法错误</p>\n<p><strong>这是由于浏览器认为这是一个函数声明<br>解决办法：让浏览器去解析这个函数表达式</strong><br>如给函数取反</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// 我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系</span><br></pre></td></tr></table></figure>\n<p>类似的还有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+function()&#123;&#125;()</span><br><span class=\"line\">-function()&#123;&#125;()</span><br><span class=\"line\">~function()&#123;&#125;()</span><br><span class=\"line\">void function()&#123;&#125;()</span><br><span class=\"line\">new function()&#123;&#125;()</span><br><span class=\"line\">// function()&#123;&#125;() === function()&#123;&#125;.call()</span><br><span class=\"line\">//用 .call() 更清楚</span><br></pre></td></tr></table></figure>\n<p>如果实在不想改变函数返回值，也可以用圆括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;&#125;).call()</span><br><span class=\"line\">(function()&#123;&#125;.call())</span><br></pre></td></tr></table></figure>\n<p>但是方法会有不好的情况：如果括号前面有东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">(function()&#123;&#125;).call()</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">a().call()</span><br><span class=\"line\">//这不是我们想要的</span><br><span class=\"line\">//同理</span><br><span class=\"line\">a</span><br><span class=\"line\">(function()&#123;&#125;.call())</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<p>所以不推荐</p>\n<p>你也可以用一个随机变量名函数而不用匿名函数，永远都不会变量污染的那种变量（这种方法好吗？）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ada231231284u3lkda()&#123;</span><br><span class=\"line\">  var a = 1;</span><br><span class=\"line\">&#125;.call()</span><br></pre></td></tr></table></figure>\n<p><strong>当然最推荐的还是用取反 ！，这就好像是个警示：我要开始用 IIFE 了</strong></p>\n<hr>\n<p><strong>IIFE 达到了局部变量的效果，外面访问不到立即执行函数里面的变量（避免变量污染）</strong></p>\n<p><strong>但有时候我们需要访问 IIFE 里面的内容，怎么办？</strong><br>最简单的方法是直接用全局变量 window</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var a = window.a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// 另一个立即执行函数通过 window.a 访问</span><br><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var b = window.a</span><br><span class=\"line\">  console.log(a)</span><br><span class=\"line\">&#125;.call() // &#123;n: 1&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们还可以在 IIFE 里面使用闭包来隐藏 a</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 声明一个匿名函数保存于 window.nAdd1</span><br><span class=\"line\">  window.nAdd1 = function()&#123;</span><br><span class=\"line\">    a.n += 1</span><br><span class=\"line\">    // return 新的 a.n</span><br><span class=\"line\">    return a.n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call()</span><br><span class=\"line\">// 匿名函数可以操作函数外面的变量 a ，这就是闭包</span><br><span class=\"line\">// 另一个立即执行函数通过 window 访问</span><br><span class=\"line\">! function()&#123;</span><br><span class=\"line\">  var b = window.nAdd1()</span><br><span class=\"line\">  console.log(newN)</span><br><span class=\"line\">&#125;.call() // 2</span><br></pre></td></tr></table></figure>\n<p><strong>IIFE 使得 a 成为局部变量而无法被外部访问<br>闭包使得匿名函数可以操作 a<br>window.nAdd1 保存了匿名函数的地址<br>任何地方都可以使用 window.nAdd1<br>=&gt; 任何地方都可以使用 window.nAdd1 操作 a，但是不能直接访问 a<br>这就是 window 和闭包联合作用的效果</strong></p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>将上面代码整合在一起，就是闭包的常见形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">  var a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function fn2()&#123;</span><br><span class=\"line\">    a.n += 1</span><br><span class=\"line\">    return a.n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return fn2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn1 = fn()</span><br><span class=\"line\">fn1() // 2</span><br><span class=\"line\">// 上面代码其实就是</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var a = &#123;</span><br><span class=\"line\">    n: 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return function()&#123;</span><br><span class=\"line\">    a.n += 1</span><br><span class=\"line\">    return a.n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.call()) // IIFE</span><br><span class=\"line\">.call()// 2</span><br></pre></td></tr></table></figure>\n<p><strong>现在我们明白了为什么闭包一般在 IIFE 里出现</strong><br>IIFE 提供局部变量的环境，才有闭包的用武之地<br><strong>return 的作用</strong><br>上面代码中的 return 和 window 的作用一样，是为了让外部能够访问函数作用域内部的函数，当然 return a.n 的作用也是如此</p>\n<p><strong>而闭包的作用，至此应该理解了</strong></p>\n<hr>\n<p>本文仅作为个人学习使用</p>\n<p>相关参考：<br><a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife\" target=\"_blank\" rel=\"noopener\">Immediately-Invoked Function Expression (IIFE)</a><br><a href=\"https://zhuanlan.zhihu.com/p/22465092\" target=\"_blank\" rel=\"noopener\">「每日一题」什么是立即执行函数？有什么作用？</a><br><a href=\"https://zhuanlan.zhihu.com/p/22486908\" target=\"_blank\" rel=\"noopener\">「每日一题」JS 中的闭包是什么？</a><br><a href=\"https://wangdoc.com/javascript/types/function.html#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88iife%EF%BC%89\" target=\"_blank\" rel=\"noopener\">JS 标准参考教程——IIFE</a><br><a href=\"http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\" target=\"_blank\" rel=\"noopener\">ES6 入门——let#块级作用域</a></p>\n"},{"title":"实现一个 jQuery 的 API","date":"2018-07-28T16:01:59.000Z","_content":"\n最近开始学习 jQuery，jQuery 是 JavaScript  最受欢迎的一个库，它让原本极不方便的 JS DOM API 变得十分易用，那么它是如何做到的呢？\n要理解 jQuery 原理，我们可以用现有的 DOM 知识尝试写一个类似 jQuery 的 API\n\n**首先我们写一个列表，给它加上 id**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a1b5fa2c18276641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**以选项 3 为节点，找到其兄弟节点（代码见截图）**\n\n通过  **var allChildren = item3.parentNode.children**获取 **item3** 父节点的所以子节点，然后遍历所有子节点，选出不是 **item3** 的所有节点，这样就找到选项 3 的所以兄弟节点啦。可以 console.log 一下\n\n（由于 array 是伪数组，不能用 push 的方法，所以我们用到  **array[array.length] = allChildren[i]**的方法）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4e2f54c2e513b5ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们把这些代码**封装**一下（给个函数）\n\n封装的好处有很多：给代码一个名字方便调用；**形成局部变量可以避免覆盖 JS 原始变量（立即调用函数）**等\n\n给这个函数取个名字，如 getSiblings；把 item3 换成 node，这样输入任意节点都可以使用这个函数了；注意不要忘记 return\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ea2f6d7eaf37ac1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样我们就得到了一个函数  **function getSiblings(node){}**\n\n---\n\n现在你已经学会如何封装一个函数，让我们尝试封装函数：**function addClass(node, classes){}**\n\n现在我们要给 item3 加 class 属性\n\n首先我们声明一个 classes 对象，里面有 a、b、c 三个属性；**同时分别给它们一个布尔值，方便 add 和 remove**；遍历各个属性。\n\n可以看到，class b、c 已经被添加到 item3 中了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ab48d3fb806dae12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n同样我们来封装一下这些代码\n\n![](https://upload-images.jianshu.io/upload_images/7094266-8fa1e7aee94ca4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在，只要你给一个 node 和 classes 于此函数，就可以给 该节点添加 classes 所包含的正确属性\n\n# **命名空间：**\n\n**给封装的函数一个名字，方便其他人使用，同时防止与前人命名的冲突。**\n\n```\nvar Adadom = {}\nAdadom.getSiblings(node)\nAdadom.addClass(node, {a: false, b: true,c:true})\n```\n\n得到代码如下，这样做也能**避免将 JS 提供的 DOM 覆盖**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a8a36cf56f38cbee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 能不能把 node 放在前面\n\n```\nnode.getSiblings()\nnode.addClass()\n```\n\n方法一：扩展 Node 接口\n\n直接在 Node.prototype 上加函数\n\nNode 如何取到 item3？用 this ，why？把上面写成 .call 的形式，因为  **this 是 call 的第一个参数。**那么用 this 就显而易见了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-50bd8de7275ed2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但是这样太乱了，总不能所有人都在 Node 原型上加属性吧？所以有了方法 2\n\n方法二：新的接口 BetterNode\n\n示例如下\n\n```\nfunction Node2(node){\n    return {\n        element: node,\n        getSiblings: function(){\n       },\n      addClass: function(){\n    }\n  }\n}\nlet node =document.getElementById('x')\nlet node2 = Node2(node)\nnode2.getSiblings()\nnode2.addClass()\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-9eb49bb5f7b83c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方法叫做「无侵入」即对 Node 无侵入\n\n# 把 Node2 改成 jQuery 吧\n\n```\nfunction jQuery(node){\n    return {\n        element: node,\n        getSiblings: function(){\n        },\n        addClass: function(){\n        }\n      }\n}\nlet node =document.getElementById('x')\nlet node2 =jQuery(node)\nnode2.getSiblings()\nnode2.addClass()\n```\n\n# 再给个缩写吧:alias\n\n**window.\\$ = jQuery**\n\n即  **var node2 = \\$(node)**\n\n但是为了防止记混 node2 到底有没有引入 jQuery\n\n大家通常这样写\n\n```\nvar $node2 = $(node)\n```\n\n至此，你已经知道 jQuery 是个什么了：它就是一个函数，是 JS 原始 DOM 的扩展，便于我们更好得使用 JS 写代码的加强版 DOM API。\n\n完整代码见  [github](https://github.com/Adashuai5/jQuery-demo/tree/master/jQuery%20API)\n\n---\n\n本文主要用于个人学习使用\n","source":"_posts/实现一个-jQuery-的-API.md","raw":"---\ntitle: 实现一个 jQuery 的 API\ndate: 2018-07-29 00:01:59\ntags: JavaScript\n---\n\n最近开始学习 jQuery，jQuery 是 JavaScript  最受欢迎的一个库，它让原本极不方便的 JS DOM API 变得十分易用，那么它是如何做到的呢？\n要理解 jQuery 原理，我们可以用现有的 DOM 知识尝试写一个类似 jQuery 的 API\n\n**首先我们写一个列表，给它加上 id**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a1b5fa2c18276641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**以选项 3 为节点，找到其兄弟节点（代码见截图）**\n\n通过  **var allChildren = item3.parentNode.children**获取 **item3** 父节点的所以子节点，然后遍历所有子节点，选出不是 **item3** 的所有节点，这样就找到选项 3 的所以兄弟节点啦。可以 console.log 一下\n\n（由于 array 是伪数组，不能用 push 的方法，所以我们用到  **array[array.length] = allChildren[i]**的方法）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4e2f54c2e513b5ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们把这些代码**封装**一下（给个函数）\n\n封装的好处有很多：给代码一个名字方便调用；**形成局部变量可以避免覆盖 JS 原始变量（立即调用函数）**等\n\n给这个函数取个名字，如 getSiblings；把 item3 换成 node，这样输入任意节点都可以使用这个函数了；注意不要忘记 return\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ea2f6d7eaf37ac1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样我们就得到了一个函数  **function getSiblings(node){}**\n\n---\n\n现在你已经学会如何封装一个函数，让我们尝试封装函数：**function addClass(node, classes){}**\n\n现在我们要给 item3 加 class 属性\n\n首先我们声明一个 classes 对象，里面有 a、b、c 三个属性；**同时分别给它们一个布尔值，方便 add 和 remove**；遍历各个属性。\n\n可以看到，class b、c 已经被添加到 item3 中了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ab48d3fb806dae12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n同样我们来封装一下这些代码\n\n![](https://upload-images.jianshu.io/upload_images/7094266-8fa1e7aee94ca4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在，只要你给一个 node 和 classes 于此函数，就可以给 该节点添加 classes 所包含的正确属性\n\n# **命名空间：**\n\n**给封装的函数一个名字，方便其他人使用，同时防止与前人命名的冲突。**\n\n```\nvar Adadom = {}\nAdadom.getSiblings(node)\nAdadom.addClass(node, {a: false, b: true,c:true})\n```\n\n得到代码如下，这样做也能**避免将 JS 提供的 DOM 覆盖**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a8a36cf56f38cbee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 能不能把 node 放在前面\n\n```\nnode.getSiblings()\nnode.addClass()\n```\n\n方法一：扩展 Node 接口\n\n直接在 Node.prototype 上加函数\n\nNode 如何取到 item3？用 this ，why？把上面写成 .call 的形式，因为  **this 是 call 的第一个参数。**那么用 this 就显而易见了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-50bd8de7275ed2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但是这样太乱了，总不能所有人都在 Node 原型上加属性吧？所以有了方法 2\n\n方法二：新的接口 BetterNode\n\n示例如下\n\n```\nfunction Node2(node){\n    return {\n        element: node,\n        getSiblings: function(){\n       },\n      addClass: function(){\n    }\n  }\n}\nlet node =document.getElementById('x')\nlet node2 = Node2(node)\nnode2.getSiblings()\nnode2.addClass()\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-9eb49bb5f7b83c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方法叫做「无侵入」即对 Node 无侵入\n\n# 把 Node2 改成 jQuery 吧\n\n```\nfunction jQuery(node){\n    return {\n        element: node,\n        getSiblings: function(){\n        },\n        addClass: function(){\n        }\n      }\n}\nlet node =document.getElementById('x')\nlet node2 =jQuery(node)\nnode2.getSiblings()\nnode2.addClass()\n```\n\n# 再给个缩写吧:alias\n\n**window.\\$ = jQuery**\n\n即  **var node2 = \\$(node)**\n\n但是为了防止记混 node2 到底有没有引入 jQuery\n\n大家通常这样写\n\n```\nvar $node2 = $(node)\n```\n\n至此，你已经知道 jQuery 是个什么了：它就是一个函数，是 JS 原始 DOM 的扩展，便于我们更好得使用 JS 写代码的加强版 DOM API。\n\n完整代码见  [github](https://github.com/Adashuai5/jQuery-demo/tree/master/jQuery%20API)\n\n---\n\n本文主要用于个人学习使用\n","slug":"实现一个-jQuery-的-API","published":1,"updated":"2020-03-28T17:28:37.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz3000ows99cma38gb8","content":"<p>最近开始学习 jQuery，jQuery 是 JavaScript  最受欢迎的一个库，它让原本极不方便的 JS DOM API 变得十分易用，那么它是如何做到的呢？<br>要理解 jQuery 原理，我们可以用现有的 DOM 知识尝试写一个类似 jQuery 的 API</p>\n<p><strong>首先我们写一个列表，给它加上 id</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a1b5fa2c18276641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>以选项 3 为节点，找到其兄弟节点（代码见截图）</strong></p>\n<p>通过  <strong>var allChildren = item3.parentNode.children</strong>获取 <strong>item3</strong> 父节点的所以子节点，然后遍历所有子节点，选出不是 <strong>item3</strong> 的所有节点，这样就找到选项 3 的所以兄弟节点啦。可以 console.log 一下</p>\n<p>（由于 array 是伪数组，不能用 push 的方法，所以我们用到  <strong>array[array.length] = allChildren[i]</strong>的方法）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4e2f54c2e513b5ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>然后我们把这些代码<strong>封装</strong>一下（给个函数）</p>\n<p>封装的好处有很多：给代码一个名字方便调用；<strong>形成局部变量可以避免覆盖 JS 原始变量（立即调用函数）</strong>等</p>\n<p>给这个函数取个名字，如 getSiblings；把 item3 换成 node，这样输入任意节点都可以使用这个函数了；注意不要忘记 return</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ea2f6d7eaf37ac1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这样我们就得到了一个函数  <strong>function getSiblings(node){}</strong></p>\n<hr>\n<p>现在你已经学会如何封装一个函数，让我们尝试封装函数：<strong>function addClass(node, classes){}</strong></p>\n<p>现在我们要给 item3 加 class 属性</p>\n<p>首先我们声明一个 classes 对象，里面有 a、b、c 三个属性；<strong>同时分别给它们一个布尔值，方便 add 和 remove</strong>；遍历各个属性。</p>\n<p>可以看到，class b、c 已经被添加到 item3 中了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ab48d3fb806dae12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>同样我们来封装一下这些代码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8fa1e7aee94ca4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>现在，只要你给一个 node 和 classes 于此函数，就可以给 该节点添加 classes 所包含的正确属性</p>\n<h1 id=\"命名空间：\"><a href=\"#命名空间：\" class=\"headerlink\" title=\"命名空间：\"></a><strong>命名空间：</strong></h1><p><strong>给封装的函数一个名字，方便其他人使用，同时防止与前人命名的冲突。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Adadom = &#123;&#125;</span><br><span class=\"line\">Adadom.getSiblings(node)</span><br><span class=\"line\">Adadom.addClass(node, &#123;a: false, b: true,c:true&#125;)</span><br></pre></td></tr></table></figure>\n<p>得到代码如下，这样做也能<strong>避免将 JS 提供的 DOM 覆盖</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a8a36cf56f38cbee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"能不能把-node-放在前面\"><a href=\"#能不能把-node-放在前面\" class=\"headerlink\" title=\"能不能把 node 放在前面\"></a>能不能把 node 放在前面</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node.getSiblings()</span><br><span class=\"line\">node.addClass()</span><br></pre></td></tr></table></figure>\n<p>方法一：扩展 Node 接口</p>\n<p>直接在 Node.prototype 上加函数</p>\n<p>Node 如何取到 item3？用 this ，why？把上面写成 .call 的形式，因为  <strong>this 是 call 的第一个参数。</strong>那么用 this 就显而易见了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-50bd8de7275ed2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>但是这样太乱了，总不能所有人都在 Node 原型上加属性吧？所以有了方法 2</p>\n<p>方法二：新的接口 BetterNode</p>\n<p>示例如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Node2(node)&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        element: node,</span><br><span class=\"line\">        getSiblings: function()&#123;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">      addClass: function()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node =document.getElementById(&apos;x&apos;)</span><br><span class=\"line\">let node2 = Node2(node)</span><br><span class=\"line\">node2.getSiblings()</span><br><span class=\"line\">node2.addClass()</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-9eb49bb5f7b83c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这种方法叫做「无侵入」即对 Node 无侵入</p>\n<h1 id=\"把-Node2-改成-jQuery-吧\"><a href=\"#把-Node2-改成-jQuery-吧\" class=\"headerlink\" title=\"把 Node2 改成 jQuery 吧\"></a>把 Node2 改成 jQuery 吧</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jQuery(node)&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        element: node,</span><br><span class=\"line\">        getSiblings: function()&#123;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        addClass: function()&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node =document.getElementById(&apos;x&apos;)</span><br><span class=\"line\">let node2 =jQuery(node)</span><br><span class=\"line\">node2.getSiblings()</span><br><span class=\"line\">node2.addClass()</span><br></pre></td></tr></table></figure>\n<h1 id=\"再给个缩写吧-alias\"><a href=\"#再给个缩写吧-alias\" class=\"headerlink\" title=\"再给个缩写吧:alias\"></a>再给个缩写吧:alias</h1><p><strong>window.\\$ = jQuery</strong></p>\n<p>即  <strong>var node2 = \\$(node)</strong></p>\n<p>但是为了防止记混 node2 到底有没有引入 jQuery</p>\n<p>大家通常这样写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var $node2 = $(node)</span><br></pre></td></tr></table></figure>\n<p>至此，你已经知道 jQuery 是个什么了：它就是一个函数，是 JS 原始 DOM 的扩展，便于我们更好得使用 JS 写代码的加强版 DOM API。</p>\n<p>完整代码见  <a href=\"https://github.com/Adashuai5/jQuery-demo/tree/master/jQuery%20API\">github</a></p>\n<hr>\n<p>本文主要用于个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近开始学习 jQuery，jQuery 是 JavaScript  最受欢迎的一个库，它让原本极不方便的 JS DOM API 变得十分易用，那么它是如何做到的呢？<br>要理解 jQuery 原理，我们可以用现有的 DOM 知识尝试写一个类似 jQuery 的 API</p>\n<p><strong>首先我们写一个列表，给它加上 id</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a1b5fa2c18276641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>以选项 3 为节点，找到其兄弟节点（代码见截图）</strong></p>\n<p>通过  <strong>var allChildren = item3.parentNode.children</strong>获取 <strong>item3</strong> 父节点的所以子节点，然后遍历所有子节点，选出不是 <strong>item3</strong> 的所有节点，这样就找到选项 3 的所以兄弟节点啦。可以 console.log 一下</p>\n<p>（由于 array 是伪数组，不能用 push 的方法，所以我们用到  <strong>array[array.length] = allChildren[i]</strong>的方法）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4e2f54c2e513b5ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>然后我们把这些代码<strong>封装</strong>一下（给个函数）</p>\n<p>封装的好处有很多：给代码一个名字方便调用；<strong>形成局部变量可以避免覆盖 JS 原始变量（立即调用函数）</strong>等</p>\n<p>给这个函数取个名字，如 getSiblings；把 item3 换成 node，这样输入任意节点都可以使用这个函数了；注意不要忘记 return</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ea2f6d7eaf37ac1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这样我们就得到了一个函数  <strong>function getSiblings(node){}</strong></p>\n<hr>\n<p>现在你已经学会如何封装一个函数，让我们尝试封装函数：<strong>function addClass(node, classes){}</strong></p>\n<p>现在我们要给 item3 加 class 属性</p>\n<p>首先我们声明一个 classes 对象，里面有 a、b、c 三个属性；<strong>同时分别给它们一个布尔值，方便 add 和 remove</strong>；遍历各个属性。</p>\n<p>可以看到，class b、c 已经被添加到 item3 中了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ab48d3fb806dae12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>同样我们来封装一下这些代码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8fa1e7aee94ca4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>现在，只要你给一个 node 和 classes 于此函数，就可以给 该节点添加 classes 所包含的正确属性</p>\n<h1 id=\"命名空间：\"><a href=\"#命名空间：\" class=\"headerlink\" title=\"命名空间：\"></a><strong>命名空间：</strong></h1><p><strong>给封装的函数一个名字，方便其他人使用，同时防止与前人命名的冲突。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Adadom = &#123;&#125;</span><br><span class=\"line\">Adadom.getSiblings(node)</span><br><span class=\"line\">Adadom.addClass(node, &#123;a: false, b: true,c:true&#125;)</span><br></pre></td></tr></table></figure>\n<p>得到代码如下，这样做也能<strong>避免将 JS 提供的 DOM 覆盖</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a8a36cf56f38cbee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"能不能把-node-放在前面\"><a href=\"#能不能把-node-放在前面\" class=\"headerlink\" title=\"能不能把 node 放在前面\"></a>能不能把 node 放在前面</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node.getSiblings()</span><br><span class=\"line\">node.addClass()</span><br></pre></td></tr></table></figure>\n<p>方法一：扩展 Node 接口</p>\n<p>直接在 Node.prototype 上加函数</p>\n<p>Node 如何取到 item3？用 this ，why？把上面写成 .call 的形式，因为  <strong>this 是 call 的第一个参数。</strong>那么用 this 就显而易见了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-50bd8de7275ed2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>但是这样太乱了，总不能所有人都在 Node 原型上加属性吧？所以有了方法 2</p>\n<p>方法二：新的接口 BetterNode</p>\n<p>示例如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Node2(node)&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        element: node,</span><br><span class=\"line\">        getSiblings: function()&#123;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">      addClass: function()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node =document.getElementById(&apos;x&apos;)</span><br><span class=\"line\">let node2 = Node2(node)</span><br><span class=\"line\">node2.getSiblings()</span><br><span class=\"line\">node2.addClass()</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-9eb49bb5f7b83c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这种方法叫做「无侵入」即对 Node 无侵入</p>\n<h1 id=\"把-Node2-改成-jQuery-吧\"><a href=\"#把-Node2-改成-jQuery-吧\" class=\"headerlink\" title=\"把 Node2 改成 jQuery 吧\"></a>把 Node2 改成 jQuery 吧</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jQuery(node)&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        element: node,</span><br><span class=\"line\">        getSiblings: function()&#123;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        addClass: function()&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node =document.getElementById(&apos;x&apos;)</span><br><span class=\"line\">let node2 =jQuery(node)</span><br><span class=\"line\">node2.getSiblings()</span><br><span class=\"line\">node2.addClass()</span><br></pre></td></tr></table></figure>\n<h1 id=\"再给个缩写吧-alias\"><a href=\"#再给个缩写吧-alias\" class=\"headerlink\" title=\"再给个缩写吧:alias\"></a>再给个缩写吧:alias</h1><p><strong>window.\\$ = jQuery</strong></p>\n<p>即  <strong>var node2 = \\$(node)</strong></p>\n<p>但是为了防止记混 node2 到底有没有引入 jQuery</p>\n<p>大家通常这样写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var $node2 = $(node)</span><br></pre></td></tr></table></figure>\n<p>至此，你已经知道 jQuery 是个什么了：它就是一个函数，是 JS 原始 DOM 的扩展，便于我们更好得使用 JS 写代码的加强版 DOM API。</p>\n<p>完整代码见  <a href=\"https://github.com/Adashuai5/jQuery-demo/tree/master/jQuery%20API\">github</a></p>\n<hr>\n<p>本文主要用于个人学习使用</p>\n"},{"title":"优先级 和 CSS 预处理","date":"2018-12-20T14:30:16.000Z","_content":"\n## 前言扯淡\n\n前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。\n需求是最好的学习 API 的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。\n\n## 首先是 [优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)\n\n链接是文档，优先级主要是指 CSS 属性的优先级。\n\n> 浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。\n\n简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。\n\n```\n<div>\n  <h1 id=\"title\" class=\"title\" style=\"color: yellow;\">优先级</h1>\n</div>\n<!--优先级显示为 pink-->\n```\n\n```\n*{\n  color: red;\n}\n\nh1{\n  color: green;\n}\n\n.title{\n  color: blue;\n}\n\n#title{\n  color: black;\n}\n\nh1{\n  color: pink !important;\n}\n```\n\n#### 优先级如何确定：\n\n选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）\n\n1. **ID 选择器**（例如, #title）\n2. **类选择器**（class selectors） (例如,.title)，**属性选择器**（attributes selectors）（例如, [type=\"radio\"]），**伪类**（pseudo-classes）（例如, :hover）\n3. **类型选择器**（type selectors）（例如, h1）和 **伪元素**（pseudo-elements）（例如, ::before）\n\n**通配选择符**（universal selector）(\\*), **关系选择符**（combinators） (+, >, ~, ' ') 和 **否定伪类**（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。\n给元素添加的**内联样式** (例如, style=\"color: yellow;\") 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。\n**!important** 是例外，此声明将覆盖任何其他声明，技术上!important 与优先级无关，但它与它直接相关。\n\n#### 如何利用优先级\n\n1. 选择器越具体，优先级越高。\n2. 相同优先级情况下，后面的样式覆盖前面的。\n3. !important 最特殊，有他的声明最优先，但应该避免使用。\n\n上面内容均来自 MDN，也就是我给的链接，还有很多如`无视DOM树中的距离`等没有记录。大家还是直接看 MDN 为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看 MDN 文档而收获一些东西，便是此文的意义了。\n扩展阅读 [真正理解\"CSS 选择器的优先级\"](https://github.com/jincdream/jincdream.github.io/issues/14)\n\n## CSS 预处理（预编译）\n\n当面试关问我知不知道 CSS 预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。\n\n---\n\n(以下内容来自 [再谈 CSS 预处理器](http://efe.baidu.com/blog/revisiting-css-preprocessors/))\nCSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：\n\n- 语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；\n- 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。\n\n所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。\n\n---\n\n这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度 EFE 的文档比我写肯定高到不知道哪里去了。\n那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下\n\n```\ndiv{}\ndiv>ul{}\ndiv>ul>li{}\ndiv>ul>li>a{}\n```\n\n本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。\n\n---\n\n本文仅供个人学习使用\n","source":"_posts/优先级-和-CSS-预处理.md","raw":"---\ntitle: 优先级 和 CSS 预处理\ndate: 2018-12-20 22:30:16\ntags: CSS\n---\n\n## 前言扯淡\n\n前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。\n需求是最好的学习 API 的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。\n\n## 首先是 [优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)\n\n链接是文档，优先级主要是指 CSS 属性的优先级。\n\n> 浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。\n\n简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。\n\n```\n<div>\n  <h1 id=\"title\" class=\"title\" style=\"color: yellow;\">优先级</h1>\n</div>\n<!--优先级显示为 pink-->\n```\n\n```\n*{\n  color: red;\n}\n\nh1{\n  color: green;\n}\n\n.title{\n  color: blue;\n}\n\n#title{\n  color: black;\n}\n\nh1{\n  color: pink !important;\n}\n```\n\n#### 优先级如何确定：\n\n选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）\n\n1. **ID 选择器**（例如, #title）\n2. **类选择器**（class selectors） (例如,.title)，**属性选择器**（attributes selectors）（例如, [type=\"radio\"]），**伪类**（pseudo-classes）（例如, :hover）\n3. **类型选择器**（type selectors）（例如, h1）和 **伪元素**（pseudo-elements）（例如, ::before）\n\n**通配选择符**（universal selector）(\\*), **关系选择符**（combinators） (+, >, ~, ' ') 和 **否定伪类**（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。\n给元素添加的**内联样式** (例如, style=\"color: yellow;\") 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。\n**!important** 是例外，此声明将覆盖任何其他声明，技术上!important 与优先级无关，但它与它直接相关。\n\n#### 如何利用优先级\n\n1. 选择器越具体，优先级越高。\n2. 相同优先级情况下，后面的样式覆盖前面的。\n3. !important 最特殊，有他的声明最优先，但应该避免使用。\n\n上面内容均来自 MDN，也就是我给的链接，还有很多如`无视DOM树中的距离`等没有记录。大家还是直接看 MDN 为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看 MDN 文档而收获一些东西，便是此文的意义了。\n扩展阅读 [真正理解\"CSS 选择器的优先级\"](https://github.com/jincdream/jincdream.github.io/issues/14)\n\n## CSS 预处理（预编译）\n\n当面试关问我知不知道 CSS 预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。\n\n---\n\n(以下内容来自 [再谈 CSS 预处理器](http://efe.baidu.com/blog/revisiting-css-preprocessors/))\nCSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：\n\n- 语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；\n- 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。\n\n所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。\n\n---\n\n这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度 EFE 的文档比我写肯定高到不知道哪里去了。\n那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下\n\n```\ndiv{}\ndiv>ul{}\ndiv>ul>li{}\ndiv>ul>li>a{}\n```\n\n本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。\n\n---\n\n本文仅供个人学习使用\n","slug":"优先级-和-CSS-预处理","published":1,"updated":"2020-03-28T17:29:09.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz4000pws9988jn65x1","content":"<h2 id=\"前言扯淡\"><a href=\"#前言扯淡\" class=\"headerlink\" title=\"前言扯淡\"></a>前言扯淡</h2><p>前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。<br>需求是最好的学习 API 的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。</p>\n<h2 id=\"首先是-优先级\"><a href=\"#首先是-优先级\" class=\"headerlink\" title=\"首先是 优先级\"></a>首先是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\" target=\"_blank\" rel=\"noopener\">优先级</a></h2><p>链接是文档，优先级主要是指 CSS 属性的优先级。</p>\n<blockquote>\n<p>浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。</p>\n</blockquote>\n<p>简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1 id=&quot;title&quot; class=&quot;title&quot; style=&quot;color: yellow;&quot;&gt;优先级&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!--优先级显示为 pink--&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1&#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.title&#123;</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#title&#123;</span><br><span class=\"line\">  color: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1&#123;</span><br><span class=\"line\">  color: pink !important;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"优先级如何确定：\"><a href=\"#优先级如何确定：\" class=\"headerlink\" title=\"优先级如何确定：\"></a>优先级如何确定：</h4><p>选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）</p>\n<ol>\n<li><strong>ID 选择器</strong>（例如, #title）</li>\n<li><strong>类选择器</strong>（class selectors） (例如,.title)，<strong>属性选择器</strong>（attributes selectors）（例如, [type=”radio”]），<strong>伪类</strong>（pseudo-classes）（例如, :hover）</li>\n<li><strong>类型选择器</strong>（type selectors）（例如, h1）和 <strong>伪元素</strong>（pseudo-elements）（例如, ::before）</li>\n</ol>\n<p><strong>通配选择符</strong>（universal selector）(*), <strong>关系选择符</strong>（combinators） (+, &gt;, ~, ‘ ‘) 和 <strong>否定伪类</strong>（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。<br>给元素添加的<strong>内联样式</strong> (例如, style=”color: yellow;”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。<br><strong>!important</strong> 是例外，此声明将覆盖任何其他声明，技术上!important 与优先级无关，但它与它直接相关。</p>\n<h4 id=\"如何利用优先级\"><a href=\"#如何利用优先级\" class=\"headerlink\" title=\"如何利用优先级\"></a>如何利用优先级</h4><ol>\n<li>选择器越具体，优先级越高。</li>\n<li>相同优先级情况下，后面的样式覆盖前面的。</li>\n<li>!important 最特殊，有他的声明最优先，但应该避免使用。</li>\n</ol>\n<p>上面内容均来自 MDN，也就是我给的链接，还有很多如<code>无视DOM树中的距离</code>等没有记录。大家还是直接看 MDN 为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看 MDN 文档而收获一些东西，便是此文的意义了。<br>扩展阅读 <a href=\"https://github.com/jincdream/jincdream.github.io/issues/14\">真正理解”CSS 选择器的优先级”</a></p>\n<h2 id=\"CSS-预处理（预编译）\"><a href=\"#CSS-预处理（预编译）\" class=\"headerlink\" title=\"CSS 预处理（预编译）\"></a>CSS 预处理（预编译）</h2><p>当面试关问我知不知道 CSS 预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。</p>\n<hr>\n<p>(以下内容来自 <a href=\"http://efe.baidu.com/blog/revisiting-css-preprocessors/\" target=\"_blank\" rel=\"noopener\">再谈 CSS 预处理器</a>)<br>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p>\n<ul>\n<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>\n<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>\n</ul>\n<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。</p>\n<hr>\n<p>这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度 EFE 的文档比我写肯定高到不知道哪里去了。<br>那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;&#125;</span><br><span class=\"line\">div&gt;ul&#123;&#125;</span><br><span class=\"line\">div&gt;ul&gt;li&#123;&#125;</span><br><span class=\"line\">div&gt;ul&gt;li&gt;a&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。</p>\n<hr>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言扯淡\"><a href=\"#前言扯淡\" class=\"headerlink\" title=\"前言扯淡\"></a>前言扯淡</h2><p>前两天电话面试，被问道了一些 CSS 的基础问题，虽然答上来了，但是不够全面，而且给自己最大的感受是自己对一些概念十分模棱两可，最直观的体现是有时候知道这个概念，却不知道他叫什么。自以为懂，最为致命。<br>需求是最好的学习 API 的方式，面试找工作是最好的学习沉淀的过程。快俩个月没写博客了，终于今天在回顾时有一点点小的感悟，打算记录下来，主要是给自己看。废话不多说，开始正文。</p>\n<h2 id=\"首先是-优先级\"><a href=\"#首先是-优先级\" class=\"headerlink\" title=\"首先是 优先级\"></a>首先是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\" target=\"_blank\" rel=\"noopener\">优先级</a></h2><p>链接是文档，优先级主要是指 CSS 属性的优先级。</p>\n<blockquote>\n<p>浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。</p>\n</blockquote>\n<p>简单来说，当你给一个元素声明（或该元素继承而来）多个相同属性时（前提），浏览器选择哪一个作为该元素的应用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1 id=&quot;title&quot; class=&quot;title&quot; style=&quot;color: yellow;&quot;&gt;优先级&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!--优先级显示为 pink--&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1&#123;</span><br><span class=\"line\">  color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.title&#123;</span><br><span class=\"line\">  color: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#title&#123;</span><br><span class=\"line\">  color: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">h1&#123;</span><br><span class=\"line\">  color: pink !important;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"优先级如何确定：\"><a href=\"#优先级如何确定：\" class=\"headerlink\" title=\"优先级如何确定：\"></a>优先级如何确定：</h4><p>选择器优先级，下面三种优先级递增：（不细看文档都不知道这些平时在用的选择器的所有名称）</p>\n<ol>\n<li><strong>ID 选择器</strong>（例如, #title）</li>\n<li><strong>类选择器</strong>（class selectors） (例如,.title)，<strong>属性选择器</strong>（attributes selectors）（例如, [type=”radio”]），<strong>伪类</strong>（pseudo-classes）（例如, :hover）</li>\n<li><strong>类型选择器</strong>（type selectors）（例如, h1）和 <strong>伪元素</strong>（pseudo-elements）（例如, ::before）</li>\n</ol>\n<p><strong>通配选择符</strong>（universal selector）(*), <strong>关系选择符</strong>（combinators） (+, &gt;, ~, ‘ ‘) 和 <strong>否定伪类</strong>（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。<br>给元素添加的<strong>内联样式</strong> (例如, style=”color: yellow;”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。<br><strong>!important</strong> 是例外，此声明将覆盖任何其他声明，技术上!important 与优先级无关，但它与它直接相关。</p>\n<h4 id=\"如何利用优先级\"><a href=\"#如何利用优先级\" class=\"headerlink\" title=\"如何利用优先级\"></a>如何利用优先级</h4><ol>\n<li>选择器越具体，优先级越高。</li>\n<li>相同优先级情况下，后面的样式覆盖前面的。</li>\n<li>!important 最特殊，有他的声明最优先，但应该避免使用。</li>\n</ol>\n<p>上面内容均来自 MDN，也就是我给的链接，还有很多如<code>无视DOM树中的距离</code>等没有记录。大家还是直接看 MDN 为宜。这些真的是简单的基础内容，但确实有很多细节，如果能够因为无意看到我的文章去看 MDN 文档而收获一些东西，便是此文的意义了。<br>扩展阅读 <a href=\"https://github.com/jincdream/jincdream.github.io/issues/14\">真正理解”CSS 选择器的优先级”</a></p>\n<h2 id=\"CSS-预处理（预编译）\"><a href=\"#CSS-预处理（预编译）\" class=\"headerlink\" title=\"CSS 预处理（预编译）\"></a>CSS 预处理（预编译）</h2><p>当面试关问我知不知道 CSS 预处理的时候，我一时并没有将其与平常再用的 LESS、SCSS 等预编译器对上。也就是我文章开头提到的，有时我们以为熟知的东西，事实上我们那么陌生。</p>\n<hr>\n<p>(以下内容来自 <a href=\"http://efe.baidu.com/blog/revisiting-css-preprocessors/\" target=\"_blank\" rel=\"noopener\">再谈 CSS 预处理器</a>)<br>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p>\n<ul>\n<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>\n<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li>\n</ul>\n<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。</p>\n<hr>\n<p>这篇文章不打算继续将 LESS、SASS 等的嵌套、变量等语法规则。一来这些内容非一篇文章讲得清（我懒），再者看官方文档是最好的入门方式，同时像上面百度 EFE 的文档比我写肯定高到不知道哪里去了。<br>那么我为什么会将 CSS 预处理和 优先级 放在同一篇文章写呢。也是面试官连续问的这俩个问题（真的很基础了，对我这种转行前端新人十分照顾），再者其实两者有一些联系，CSS 预编译也是在变相解决 优先级 的问题，因为我们需要完美利用优先级，所以我们在写 CSS 时往往选择器需要十分详细，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;&#125;</span><br><span class=\"line\">div&gt;ul&#123;&#125;</span><br><span class=\"line\">div&gt;ul&gt;li&#123;&#125;</span><br><span class=\"line\">div&gt;ul&gt;li&gt;a&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>本着 Dry 宗旨，CSS 预编译的嵌套规则就是为了解决优先级啊。</p>\n<hr>\n<p>本文仅供个人学习使用</p>\n"},{"title":"实现一个 AJAX","date":"2018-08-12T04:28:53.000Z","_content":"\n[AJAX 是什么鬼](https://www.jianshu.com/p/4591a66c50f5) 续篇\n\n# 今天我们给 AJAX 封装一下\n\n之前写了篇有关用原生 JS 写 jQuery 的[博客](https://www.jianshu.com/p/7e663286cb35)\n下面是相关主要代码\n\n```\nwindow.jQuery = function (nodeOrSelector) {\n    let nodes = {}\n    nodes.addClass = function () {}\n    nodes.html = function () {}\n    return nodes\n}\n```\n\n事实上就是用函数给代码封装一下并设定相关参数\n\n```\nwindow.jQuery.ajax = function (url, method, body, succseeFn, failFn) {\n    let request = new XMLHttpRequest()\n    //初始化请求\n    request.open(method, url)\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            if (request.status >= 200 && request.status < 300) {\n                succseeFn.call(undefined, request.responseText)\n            } else if (request.status >= 400) {\n                failFn.call(undefined, request)\n            }\n        }\n    }\n    request.send(body)\n}\n```\n\n```\nwindow.$ = window.jQuery\n```\n\n可以使用\\$.ajax 了\n\n```\nmyButton.addEventListener('click', (e) => {\n    $.ajax(\n        '/ada',\n        'post',\n        'a=1&b=2',\n        (responseText) => {\n            console.log('s')\n        },\n        (request) => {\n            console.log('f')\n        })\n})\n```\n\n**但是这个\\$.ajax 依然有问题** 1.给定的参数顺序太死\n如果我不传其中一个参数，就需要给这个参数所在位置占位，如若 method 是'get'，就不返回 body，那就需要用 undefined 等占位\n\n```\n'/ada',\n'post',\n//null，undefined或'' 占位\n'',\n(responseText) => {\n      console.log('s')\n},\n(request) => {\n      console.log('f')\n})\n```\n\n2.无法直观解释参数意思。\n比如上面代码，如果你没看过前面内容或者原生 JS 代码，你都不知道这些参数分别表达的是什么意思。\n\n**解决方法：给参数命名呗**\n\n```\nwindow.jQuery.ajax = function (options) {\n    //给参数一个选项\n    let method = options.method\n    let url = options.url\n    let body = options.body\n    let succseeFn = options.succseeFn\n    let failFn = options.failFn\n\n    let request = new XMLHttpRequest()\n    //初始化请求\n    request.open(method, url)\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            if (request.status >= 200 && request.status < 300) {\n                succseeFn.call(undefined, request.responseText)\n            } else if (request.status >= 400) {\n                failFn.call(undefined, request)\n            }\n        }\n    }\n    request.send(body)\n}\n\nmyButton.addEventListener('click', (e) => {\n    //以对象的形式传参数\n    $.ajax({\n        url: '/ada',\n        method: 'post',\n        body: 'a=1&b=2',\n        succseeFn: (responseText) => {\n            console.log('s')\n        },\n        failFn: (request) => {\n            console.log('f')\n        }\n    })\n})\n```\n\n**加一个 setRequestHeader：设置请求第二部分**\n\n```\nheaders: {\n    'content-type':'application/x-www-form-urlencoded'\n}\n```\n\n\\$.ajax 部分遍历一下 headers\n\n```\nlet headers = options.headers\n//下面代码放在 requset.open() 后\nfor (let key in headers) {\n    let value = headers[key]\n    request.setRequestHeader(key, value)\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5f2a6c8a84d872fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**如何向 \\$.ajax 传两个参数：如 jQuery.ajax( url [, options ] )**\n\n```\nlet url\nif(arguments.length === 1){\n    url = options.url\n}else if(arguments.length === 2){\n    url = arguments[0]\n    options = arguments[1]\n}\n```\n\n现在我们的\\$.ajax 已经和 jQuery 的一样了\n\n---\n\n**优化一下代码，先不管两个参数那个**\n\n**1.ES6 的 [解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)**\n\n```\n//这6行代码太丑了\nlet url= options\nlet method = options.method\nlet body = options.body\nlet succseeFn = options.succseeFn\nlet failFn = options.failFn\nlet headers = options.headers\n//用ES6解构赋值,上面代码等价于\nlet = {url,method,body,headers,successFn,failFn} = options\n```\n\n可以不要 options 了\n\n```\nwindow.jQuery.ajax = function ({url,method,body,headers,succseeFn,failFn}){}\n```\n\n**2.Promise，相关知识可以[参考](http://es6.ruanyifeng.com/#docs/promise)**\n之前我们给参数命名了，我是知道了这个参数代表什么。\n但是每个人的命名都会不一样，比如 jQuery 的 ajax 对响应成功的命名就是 success 而我的是 successFn。\n这对于不熟悉对应文档的人来说，使用十分不便。\n针对这个问题，就有了 Promise\nPromise 的形式\n\n```\nwindow.Promise = function(fn){\n    //...\n    return {\n        then:function(){}\n    }\n}\n```\n\n用 Promise 函数：resolve,reject 替换 successFn 和 failFn，这个两个参数是 ES6 规定的，这样就不会有上述问题了\nreturn new Promise(function(resolve,reject){})\n\n```\nwindow.jQuery.ajax = function ({url,method,body,headers}) {\n    //之前代码返回值是 undefined，我们return一个Promise\n    return new Promise(function(resolve,reject){\n        let request = new XMLHttpRequest()\n    //初始化请求\n    request.open(method, url)\n    for (let key in headers) {\n        let value = headers[key]\n        request.setRequestHeader(key, value)\n    }\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            if (request.status >= 200 && request.status < 300) {\n                // successFn 就由 resove 代替了\n                resolve.call(undefined, request.responseText)\n            } else if (request.status >= 400) {\n                // failFn 就由 reject 代替了\n                reject.call(undefined, request)\n            }\n        }\n    }\n    request.send(body)\n    })\n}\n\nwindow.$ = window.jQuery\n\nmyButton.addEventListener('click', (e) => {\n    //以对象的形式传参数\n    $.ajax({\n        url: '/ada',\n        method: 'post',\n        headers: {\n            'content-type': 'application/x-www-form-urlencoded',\n            'ada': '18'\n        }\n    }).then(\n        //成功后执行的代码\n        (responseText)=>{console.log(responseText)},\n        //失败后执行的代码\n        (request)=>{console.log(request)}\n      )\n})\n```\n\nthen 后再 then\n\n```\n.then(\n    //成功后执行的代码\n    (responseText)=>{console.log(responseText);return '处理成功'},\n    //失败后执行的代码\n    (request)=>{console.log(request);return '处理失败'}\n    ).then(\n    //上一次成功后的return\n    (responseText)=>{console.log(responseText)},\n    //上一次失败后的return\n    (request)=>{console.log(request)}\n)\n```\n\n可以看下结果![](https://upload-images.jianshu.io/upload_images/7094266-46960dc591ffab15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n完整代码请看 [github](https://github.com/Adashuai5/node-demo/tree/master/jQuery.AJAX)\n\n---\n\n#小记\n**AJAX 的所有功能**\n客户端的 JS 发起请求（浏览器上的）\n服务端的 JS 发送响应（Node.js 上的）\n**1.JS 可以设置任意请求 header**\n第一部分 request.open(method, url)\n第二部分 request.setRequstHeader('content-type','application/x-www-form-urlencoded')\n第四部分 request.send(body)\n**2.JS 可以获取任意响应 header**\n第一部分 request.status / request.statusText\n第二部分 request.getResponseHeader() / request.getAllResponseHeaders()\n第四部分 request.responseText\n图解![](https://upload-images.jianshu.io/upload_images/7094266-82d62fca23713ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**有关回调 (callback:打电话回来)：**\n\n```\nsuccseeFn.call(undefined, request.responseText)\n//这种形式就是回调\nsuccseeFn: () => {}\n```\n\n**promise 的 .then() 和 .then().then() 理解**\n\n```\n.then(\n  fn1,fn2\n).then(\n  fn3,fn4\n  )\n\n```\n\n.then( , ) 逗号左边为成功执行，右边为失败执行\n我们可以称第一个： **.then( fn1 , fn2 )**为第一负责人；第二个： **.then( fn3 , fn4 )**为第二负责人\n第一负责人成功则执行 fn1 ，失败则执行 fn2；第一负责人处理完成处理则第二负责人执行 fn3 ，处理不好（如代码有问题）则执行 fn4\n\n---\n\n本文仅供个人学习使用\n","source":"_posts/实现一个AJAX.md","raw":"---\ntitle: 实现一个 AJAX\ndate: 2018-08-12 12:28:53\ntags: JavaScript\n---\n\n[AJAX 是什么鬼](https://www.jianshu.com/p/4591a66c50f5) 续篇\n\n# 今天我们给 AJAX 封装一下\n\n之前写了篇有关用原生 JS 写 jQuery 的[博客](https://www.jianshu.com/p/7e663286cb35)\n下面是相关主要代码\n\n```\nwindow.jQuery = function (nodeOrSelector) {\n    let nodes = {}\n    nodes.addClass = function () {}\n    nodes.html = function () {}\n    return nodes\n}\n```\n\n事实上就是用函数给代码封装一下并设定相关参数\n\n```\nwindow.jQuery.ajax = function (url, method, body, succseeFn, failFn) {\n    let request = new XMLHttpRequest()\n    //初始化请求\n    request.open(method, url)\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            if (request.status >= 200 && request.status < 300) {\n                succseeFn.call(undefined, request.responseText)\n            } else if (request.status >= 400) {\n                failFn.call(undefined, request)\n            }\n        }\n    }\n    request.send(body)\n}\n```\n\n```\nwindow.$ = window.jQuery\n```\n\n可以使用\\$.ajax 了\n\n```\nmyButton.addEventListener('click', (e) => {\n    $.ajax(\n        '/ada',\n        'post',\n        'a=1&b=2',\n        (responseText) => {\n            console.log('s')\n        },\n        (request) => {\n            console.log('f')\n        })\n})\n```\n\n**但是这个\\$.ajax 依然有问题** 1.给定的参数顺序太死\n如果我不传其中一个参数，就需要给这个参数所在位置占位，如若 method 是'get'，就不返回 body，那就需要用 undefined 等占位\n\n```\n'/ada',\n'post',\n//null，undefined或'' 占位\n'',\n(responseText) => {\n      console.log('s')\n},\n(request) => {\n      console.log('f')\n})\n```\n\n2.无法直观解释参数意思。\n比如上面代码，如果你没看过前面内容或者原生 JS 代码，你都不知道这些参数分别表达的是什么意思。\n\n**解决方法：给参数命名呗**\n\n```\nwindow.jQuery.ajax = function (options) {\n    //给参数一个选项\n    let method = options.method\n    let url = options.url\n    let body = options.body\n    let succseeFn = options.succseeFn\n    let failFn = options.failFn\n\n    let request = new XMLHttpRequest()\n    //初始化请求\n    request.open(method, url)\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            if (request.status >= 200 && request.status < 300) {\n                succseeFn.call(undefined, request.responseText)\n            } else if (request.status >= 400) {\n                failFn.call(undefined, request)\n            }\n        }\n    }\n    request.send(body)\n}\n\nmyButton.addEventListener('click', (e) => {\n    //以对象的形式传参数\n    $.ajax({\n        url: '/ada',\n        method: 'post',\n        body: 'a=1&b=2',\n        succseeFn: (responseText) => {\n            console.log('s')\n        },\n        failFn: (request) => {\n            console.log('f')\n        }\n    })\n})\n```\n\n**加一个 setRequestHeader：设置请求第二部分**\n\n```\nheaders: {\n    'content-type':'application/x-www-form-urlencoded'\n}\n```\n\n\\$.ajax 部分遍历一下 headers\n\n```\nlet headers = options.headers\n//下面代码放在 requset.open() 后\nfor (let key in headers) {\n    let value = headers[key]\n    request.setRequestHeader(key, value)\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5f2a6c8a84d872fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**如何向 \\$.ajax 传两个参数：如 jQuery.ajax( url [, options ] )**\n\n```\nlet url\nif(arguments.length === 1){\n    url = options.url\n}else if(arguments.length === 2){\n    url = arguments[0]\n    options = arguments[1]\n}\n```\n\n现在我们的\\$.ajax 已经和 jQuery 的一样了\n\n---\n\n**优化一下代码，先不管两个参数那个**\n\n**1.ES6 的 [解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)**\n\n```\n//这6行代码太丑了\nlet url= options\nlet method = options.method\nlet body = options.body\nlet succseeFn = options.succseeFn\nlet failFn = options.failFn\nlet headers = options.headers\n//用ES6解构赋值,上面代码等价于\nlet = {url,method,body,headers,successFn,failFn} = options\n```\n\n可以不要 options 了\n\n```\nwindow.jQuery.ajax = function ({url,method,body,headers,succseeFn,failFn}){}\n```\n\n**2.Promise，相关知识可以[参考](http://es6.ruanyifeng.com/#docs/promise)**\n之前我们给参数命名了，我是知道了这个参数代表什么。\n但是每个人的命名都会不一样，比如 jQuery 的 ajax 对响应成功的命名就是 success 而我的是 successFn。\n这对于不熟悉对应文档的人来说，使用十分不便。\n针对这个问题，就有了 Promise\nPromise 的形式\n\n```\nwindow.Promise = function(fn){\n    //...\n    return {\n        then:function(){}\n    }\n}\n```\n\n用 Promise 函数：resolve,reject 替换 successFn 和 failFn，这个两个参数是 ES6 规定的，这样就不会有上述问题了\nreturn new Promise(function(resolve,reject){})\n\n```\nwindow.jQuery.ajax = function ({url,method,body,headers}) {\n    //之前代码返回值是 undefined，我们return一个Promise\n    return new Promise(function(resolve,reject){\n        let request = new XMLHttpRequest()\n    //初始化请求\n    request.open(method, url)\n    for (let key in headers) {\n        let value = headers[key]\n        request.setRequestHeader(key, value)\n    }\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            if (request.status >= 200 && request.status < 300) {\n                // successFn 就由 resove 代替了\n                resolve.call(undefined, request.responseText)\n            } else if (request.status >= 400) {\n                // failFn 就由 reject 代替了\n                reject.call(undefined, request)\n            }\n        }\n    }\n    request.send(body)\n    })\n}\n\nwindow.$ = window.jQuery\n\nmyButton.addEventListener('click', (e) => {\n    //以对象的形式传参数\n    $.ajax({\n        url: '/ada',\n        method: 'post',\n        headers: {\n            'content-type': 'application/x-www-form-urlencoded',\n            'ada': '18'\n        }\n    }).then(\n        //成功后执行的代码\n        (responseText)=>{console.log(responseText)},\n        //失败后执行的代码\n        (request)=>{console.log(request)}\n      )\n})\n```\n\nthen 后再 then\n\n```\n.then(\n    //成功后执行的代码\n    (responseText)=>{console.log(responseText);return '处理成功'},\n    //失败后执行的代码\n    (request)=>{console.log(request);return '处理失败'}\n    ).then(\n    //上一次成功后的return\n    (responseText)=>{console.log(responseText)},\n    //上一次失败后的return\n    (request)=>{console.log(request)}\n)\n```\n\n可以看下结果![](https://upload-images.jianshu.io/upload_images/7094266-46960dc591ffab15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n完整代码请看 [github](https://github.com/Adashuai5/node-demo/tree/master/jQuery.AJAX)\n\n---\n\n#小记\n**AJAX 的所有功能**\n客户端的 JS 发起请求（浏览器上的）\n服务端的 JS 发送响应（Node.js 上的）\n**1.JS 可以设置任意请求 header**\n第一部分 request.open(method, url)\n第二部分 request.setRequstHeader('content-type','application/x-www-form-urlencoded')\n第四部分 request.send(body)\n**2.JS 可以获取任意响应 header**\n第一部分 request.status / request.statusText\n第二部分 request.getResponseHeader() / request.getAllResponseHeaders()\n第四部分 request.responseText\n图解![](https://upload-images.jianshu.io/upload_images/7094266-82d62fca23713ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**有关回调 (callback:打电话回来)：**\n\n```\nsuccseeFn.call(undefined, request.responseText)\n//这种形式就是回调\nsuccseeFn: () => {}\n```\n\n**promise 的 .then() 和 .then().then() 理解**\n\n```\n.then(\n  fn1,fn2\n).then(\n  fn3,fn4\n  )\n\n```\n\n.then( , ) 逗号左边为成功执行，右边为失败执行\n我们可以称第一个： **.then( fn1 , fn2 )**为第一负责人；第二个： **.then( fn3 , fn4 )**为第二负责人\n第一负责人成功则执行 fn1 ，失败则执行 fn2；第一负责人处理完成处理则第二负责人执行 fn3 ，处理不好（如代码有问题）则执行 fn4\n\n---\n\n本文仅供个人学习使用\n","slug":"实现一个AJAX","published":1,"updated":"2020-03-28T17:38:46.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz5000qws99mgxh4ows","content":"<p><a href=\"https://www.jianshu.com/p/4591a66c50f5\" target=\"_blank\" rel=\"noopener\">AJAX 是什么鬼</a> 续篇</p>\n<h1 id=\"今天我们给-AJAX-封装一下\"><a href=\"#今天我们给-AJAX-封装一下\" class=\"headerlink\" title=\"今天我们给 AJAX 封装一下\"></a>今天我们给 AJAX 封装一下</h1><p>之前写了篇有关用原生 JS 写 jQuery 的<a href=\"https://www.jianshu.com/p/7e663286cb35\" target=\"_blank\" rel=\"noopener\">博客</a><br>下面是相关主要代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery = function (nodeOrSelector) &#123;</span><br><span class=\"line\">    let nodes = &#123;&#125;</span><br><span class=\"line\">    nodes.addClass = function () &#123;&#125;</span><br><span class=\"line\">    nodes.html = function () &#123;&#125;</span><br><span class=\"line\">    return nodes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事实上就是用函数给代码封装一下并设定相关参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (url, method, body, succseeFn, failFn) &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求</span><br><span class=\"line\">    request.open(method, url)</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                succseeFn.call(undefined, request.responseText)</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                failFn.call(undefined, request)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.send(body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.$ = window.jQuery</span><br></pre></td></tr></table></figure>\n<p>可以使用\\$.ajax 了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    $.ajax(</span><br><span class=\"line\">        &apos;/ada&apos;,</span><br><span class=\"line\">        &apos;post&apos;,</span><br><span class=\"line\">        &apos;a=1&amp;b=2&apos;,</span><br><span class=\"line\">        (responseText) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;s&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        (request) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;f&apos;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>但是这个\\$.ajax 依然有问题</strong> 1.给定的参数顺序太死<br>如果我不传其中一个参数，就需要给这个参数所在位置占位，如若 method 是’get’，就不返回 body，那就需要用 undefined 等占位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;/ada&apos;,</span><br><span class=\"line\">&apos;post&apos;,</span><br><span class=\"line\">//null，undefined或&apos;&apos; 占位</span><br><span class=\"line\">&apos;&apos;,</span><br><span class=\"line\">(responseText) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;s&apos;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">(request) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;f&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>2.无法直观解释参数意思。<br>比如上面代码，如果你没看过前面内容或者原生 JS 代码，你都不知道这些参数分别表达的是什么意思。</p>\n<p><strong>解决方法：给参数命名呗</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (options) &#123;</span><br><span class=\"line\">    //给参数一个选项</span><br><span class=\"line\">    let method = options.method</span><br><span class=\"line\">    let url = options.url</span><br><span class=\"line\">    let body = options.body</span><br><span class=\"line\">    let succseeFn = options.succseeFn</span><br><span class=\"line\">    let failFn = options.failFn</span><br><span class=\"line\"></span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求</span><br><span class=\"line\">    request.open(method, url)</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                succseeFn.call(undefined, request.responseText)</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                failFn.call(undefined, request)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.send(body)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    //以对象的形式传参数</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: &apos;/ada&apos;,</span><br><span class=\"line\">        method: &apos;post&apos;,</span><br><span class=\"line\">        body: &apos;a=1&amp;b=2&apos;,</span><br><span class=\"line\">        succseeFn: (responseText) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;s&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        failFn: (request) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;f&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>加一个 setRequestHeader：设置请求第二部分</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers: &#123;</span><br><span class=\"line\">    &apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\\$.ajax 部分遍历一下 headers</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let headers = options.headers</span><br><span class=\"line\">//下面代码放在 requset.open() 后</span><br><span class=\"line\">for (let key in headers) &#123;</span><br><span class=\"line\">    let value = headers[key]</span><br><span class=\"line\">    request.setRequestHeader(key, value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5f2a6c8a84d872fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>如何向 \\$.ajax 传两个参数：如 jQuery.ajax( url [, options ] )</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let url</span><br><span class=\"line\">if(arguments.length === 1)&#123;</span><br><span class=\"line\">    url = options.url</span><br><span class=\"line\">&#125;else if(arguments.length === 2)&#123;</span><br><span class=\"line\">    url = arguments[0]</span><br><span class=\"line\">    options = arguments[1]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们的\\$.ajax 已经和 jQuery 的一样了</p>\n<hr>\n<p><strong>优化一下代码，先不管两个参数那个</strong></p>\n<p><strong>1.ES6 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener\">解构赋值</a></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这6行代码太丑了</span><br><span class=\"line\">let url= options</span><br><span class=\"line\">let method = options.method</span><br><span class=\"line\">let body = options.body</span><br><span class=\"line\">let succseeFn = options.succseeFn</span><br><span class=\"line\">let failFn = options.failFn</span><br><span class=\"line\">let headers = options.headers</span><br><span class=\"line\">//用ES6解构赋值,上面代码等价于</span><br><span class=\"line\">let = &#123;url,method,body,headers,successFn,failFn&#125; = options</span><br></pre></td></tr></table></figure>\n<p>可以不要 options 了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (&#123;url,method,body,headers,succseeFn,failFn&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.Promise，相关知识可以<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">参考</a></strong><br>之前我们给参数命名了，我是知道了这个参数代表什么。<br>但是每个人的命名都会不一样，比如 jQuery 的 ajax 对响应成功的命名就是 success 而我的是 successFn。<br>这对于不熟悉对应文档的人来说，使用十分不便。<br>针对这个问题，就有了 Promise<br>Promise 的形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.Promise = function(fn)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        then:function()&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 Promise 函数：resolve,reject 替换 successFn 和 failFn，这个两个参数是 ES6 规定的，这样就不会有上述问题了<br>return new Promise(function(resolve,reject){})</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (&#123;url,method,body,headers&#125;) &#123;</span><br><span class=\"line\">    //之前代码返回值是 undefined，我们return一个Promise</span><br><span class=\"line\">    return new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">        let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求</span><br><span class=\"line\">    request.open(method, url)</span><br><span class=\"line\">    for (let key in headers) &#123;</span><br><span class=\"line\">        let value = headers[key]</span><br><span class=\"line\">        request.setRequestHeader(key, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                // successFn 就由 resove 代替了</span><br><span class=\"line\">                resolve.call(undefined, request.responseText)</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                // failFn 就由 reject 代替了</span><br><span class=\"line\">                reject.call(undefined, request)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.send(body)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.$ = window.jQuery</span><br><span class=\"line\"></span><br><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    //以对象的形式传参数</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: &apos;/ada&apos;,</span><br><span class=\"line\">        method: &apos;post&apos;,</span><br><span class=\"line\">        headers: &#123;</span><br><span class=\"line\">            &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">            &apos;ada&apos;: &apos;18&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).then(</span><br><span class=\"line\">        //成功后执行的代码</span><br><span class=\"line\">        (responseText)=&gt;&#123;console.log(responseText)&#125;,</span><br><span class=\"line\">        //失败后执行的代码</span><br><span class=\"line\">        (request)=&gt;&#123;console.log(request)&#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>then 后再 then</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(</span><br><span class=\"line\">    //成功后执行的代码</span><br><span class=\"line\">    (responseText)=&gt;&#123;console.log(responseText);return &apos;处理成功&apos;&#125;,</span><br><span class=\"line\">    //失败后执行的代码</span><br><span class=\"line\">    (request)=&gt;&#123;console.log(request);return &apos;处理失败&apos;&#125;</span><br><span class=\"line\">    ).then(</span><br><span class=\"line\">    //上一次成功后的return</span><br><span class=\"line\">    (responseText)=&gt;&#123;console.log(responseText)&#125;,</span><br><span class=\"line\">    //上一次失败后的return</span><br><span class=\"line\">    (request)=&gt;&#123;console.log(request)&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>可以看下结果<img src=\"https://upload-images.jianshu.io/upload_images/7094266-46960dc591ffab15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>完整代码请看 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/jQuery.AJAX\">github</a></p>\n<hr>\n<p>#小记<br><strong>AJAX 的所有功能</strong><br>客户端的 JS 发起请求（浏览器上的）<br>服务端的 JS 发送响应（Node.js 上的）<br><strong>1.JS 可以设置任意请求 header</strong><br>第一部分 request.open(method, url)<br>第二部分 request.setRequstHeader(‘content-type’,’application/x-www-form-urlencoded’)<br>第四部分 request.send(body)<br><strong>2.JS 可以获取任意响应 header</strong><br>第一部分 request.status / request.statusText<br>第二部分 request.getResponseHeader() / request.getAllResponseHeaders()<br>第四部分 request.responseText<br>图解<img src=\"https://upload-images.jianshu.io/upload_images/7094266-82d62fca23713ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>有关回调 (callback:打电话回来)：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">succseeFn.call(undefined, request.responseText)</span><br><span class=\"line\">//这种形式就是回调</span><br><span class=\"line\">succseeFn: () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>promise 的 .then() 和 .then().then() 理解</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(</span><br><span class=\"line\">  fn1,fn2</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  fn3,fn4</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>.then( , ) 逗号左边为成功执行，右边为失败执行<br>我们可以称第一个： <strong>.then( fn1 , fn2 )</strong>为第一负责人；第二个： <strong>.then( fn3 , fn4 )</strong>为第二负责人<br>第一负责人成功则执行 fn1 ，失败则执行 fn2；第一负责人处理完成处理则第二负责人执行 fn3 ，处理不好（如代码有问题）则执行 fn4</p>\n<hr>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/4591a66c50f5\" target=\"_blank\" rel=\"noopener\">AJAX 是什么鬼</a> 续篇</p>\n<h1 id=\"今天我们给-AJAX-封装一下\"><a href=\"#今天我们给-AJAX-封装一下\" class=\"headerlink\" title=\"今天我们给 AJAX 封装一下\"></a>今天我们给 AJAX 封装一下</h1><p>之前写了篇有关用原生 JS 写 jQuery 的<a href=\"https://www.jianshu.com/p/7e663286cb35\" target=\"_blank\" rel=\"noopener\">博客</a><br>下面是相关主要代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery = function (nodeOrSelector) &#123;</span><br><span class=\"line\">    let nodes = &#123;&#125;</span><br><span class=\"line\">    nodes.addClass = function () &#123;&#125;</span><br><span class=\"line\">    nodes.html = function () &#123;&#125;</span><br><span class=\"line\">    return nodes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事实上就是用函数给代码封装一下并设定相关参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (url, method, body, succseeFn, failFn) &#123;</span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求</span><br><span class=\"line\">    request.open(method, url)</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                succseeFn.call(undefined, request.responseText)</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                failFn.call(undefined, request)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.send(body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.$ = window.jQuery</span><br></pre></td></tr></table></figure>\n<p>可以使用\\$.ajax 了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    $.ajax(</span><br><span class=\"line\">        &apos;/ada&apos;,</span><br><span class=\"line\">        &apos;post&apos;,</span><br><span class=\"line\">        &apos;a=1&amp;b=2&apos;,</span><br><span class=\"line\">        (responseText) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;s&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        (request) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;f&apos;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>但是这个\\$.ajax 依然有问题</strong> 1.给定的参数顺序太死<br>如果我不传其中一个参数，就需要给这个参数所在位置占位，如若 method 是’get’，就不返回 body，那就需要用 undefined 等占位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;/ada&apos;,</span><br><span class=\"line\">&apos;post&apos;,</span><br><span class=\"line\">//null，undefined或&apos;&apos; 占位</span><br><span class=\"line\">&apos;&apos;,</span><br><span class=\"line\">(responseText) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;s&apos;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">(request) =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;f&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>2.无法直观解释参数意思。<br>比如上面代码，如果你没看过前面内容或者原生 JS 代码，你都不知道这些参数分别表达的是什么意思。</p>\n<p><strong>解决方法：给参数命名呗</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (options) &#123;</span><br><span class=\"line\">    //给参数一个选项</span><br><span class=\"line\">    let method = options.method</span><br><span class=\"line\">    let url = options.url</span><br><span class=\"line\">    let body = options.body</span><br><span class=\"line\">    let succseeFn = options.succseeFn</span><br><span class=\"line\">    let failFn = options.failFn</span><br><span class=\"line\"></span><br><span class=\"line\">    let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求</span><br><span class=\"line\">    request.open(method, url)</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                succseeFn.call(undefined, request.responseText)</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                failFn.call(undefined, request)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.send(body)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    //以对象的形式传参数</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: &apos;/ada&apos;,</span><br><span class=\"line\">        method: &apos;post&apos;,</span><br><span class=\"line\">        body: &apos;a=1&amp;b=2&apos;,</span><br><span class=\"line\">        succseeFn: (responseText) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;s&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        failFn: (request) =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;f&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>加一个 setRequestHeader：设置请求第二部分</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers: &#123;</span><br><span class=\"line\">    &apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\\$.ajax 部分遍历一下 headers</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let headers = options.headers</span><br><span class=\"line\">//下面代码放在 requset.open() 后</span><br><span class=\"line\">for (let key in headers) &#123;</span><br><span class=\"line\">    let value = headers[key]</span><br><span class=\"line\">    request.setRequestHeader(key, value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5f2a6c8a84d872fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>如何向 \\$.ajax 传两个参数：如 jQuery.ajax( url [, options ] )</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let url</span><br><span class=\"line\">if(arguments.length === 1)&#123;</span><br><span class=\"line\">    url = options.url</span><br><span class=\"line\">&#125;else if(arguments.length === 2)&#123;</span><br><span class=\"line\">    url = arguments[0]</span><br><span class=\"line\">    options = arguments[1]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们的\\$.ajax 已经和 jQuery 的一样了</p>\n<hr>\n<p><strong>优化一下代码，先不管两个参数那个</strong></p>\n<p><strong>1.ES6 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener\">解构赋值</a></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这6行代码太丑了</span><br><span class=\"line\">let url= options</span><br><span class=\"line\">let method = options.method</span><br><span class=\"line\">let body = options.body</span><br><span class=\"line\">let succseeFn = options.succseeFn</span><br><span class=\"line\">let failFn = options.failFn</span><br><span class=\"line\">let headers = options.headers</span><br><span class=\"line\">//用ES6解构赋值,上面代码等价于</span><br><span class=\"line\">let = &#123;url,method,body,headers,successFn,failFn&#125; = options</span><br></pre></td></tr></table></figure>\n<p>可以不要 options 了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (&#123;url,method,body,headers,succseeFn,failFn&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.Promise，相关知识可以<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">参考</a></strong><br>之前我们给参数命名了，我是知道了这个参数代表什么。<br>但是每个人的命名都会不一样，比如 jQuery 的 ajax 对响应成功的命名就是 success 而我的是 successFn。<br>这对于不熟悉对应文档的人来说，使用十分不便。<br>针对这个问题，就有了 Promise<br>Promise 的形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.Promise = function(fn)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        then:function()&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 Promise 函数：resolve,reject 替换 successFn 和 failFn，这个两个参数是 ES6 规定的，这样就不会有上述问题了<br>return new Promise(function(resolve,reject){})</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.jQuery.ajax = function (&#123;url,method,body,headers&#125;) &#123;</span><br><span class=\"line\">    //之前代码返回值是 undefined，我们return一个Promise</span><br><span class=\"line\">    return new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">        let request = new XMLHttpRequest()</span><br><span class=\"line\">    //初始化请求</span><br><span class=\"line\">    request.open(method, url)</span><br><span class=\"line\">    for (let key in headers) &#123;</span><br><span class=\"line\">        let value = headers[key]</span><br><span class=\"line\">        request.setRequestHeader(key, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">        if (request.readyState === 4) &#123;</span><br><span class=\"line\">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class=\"line\">                // successFn 就由 resove 代替了</span><br><span class=\"line\">                resolve.call(undefined, request.responseText)</span><br><span class=\"line\">            &#125; else if (request.status &gt;= 400) &#123;</span><br><span class=\"line\">                // failFn 就由 reject 代替了</span><br><span class=\"line\">                reject.call(undefined, request)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request.send(body)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.$ = window.jQuery</span><br><span class=\"line\"></span><br><span class=\"line\">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    //以对象的形式传参数</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: &apos;/ada&apos;,</span><br><span class=\"line\">        method: &apos;post&apos;,</span><br><span class=\"line\">        headers: &#123;</span><br><span class=\"line\">            &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">            &apos;ada&apos;: &apos;18&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).then(</span><br><span class=\"line\">        //成功后执行的代码</span><br><span class=\"line\">        (responseText)=&gt;&#123;console.log(responseText)&#125;,</span><br><span class=\"line\">        //失败后执行的代码</span><br><span class=\"line\">        (request)=&gt;&#123;console.log(request)&#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>then 后再 then</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(</span><br><span class=\"line\">    //成功后执行的代码</span><br><span class=\"line\">    (responseText)=&gt;&#123;console.log(responseText);return &apos;处理成功&apos;&#125;,</span><br><span class=\"line\">    //失败后执行的代码</span><br><span class=\"line\">    (request)=&gt;&#123;console.log(request);return &apos;处理失败&apos;&#125;</span><br><span class=\"line\">    ).then(</span><br><span class=\"line\">    //上一次成功后的return</span><br><span class=\"line\">    (responseText)=&gt;&#123;console.log(responseText)&#125;,</span><br><span class=\"line\">    //上一次失败后的return</span><br><span class=\"line\">    (request)=&gt;&#123;console.log(request)&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>可以看下结果<img src=\"https://upload-images.jianshu.io/upload_images/7094266-46960dc591ffab15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>完整代码请看 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/jQuery.AJAX\">github</a></p>\n<hr>\n<p>#小记<br><strong>AJAX 的所有功能</strong><br>客户端的 JS 发起请求（浏览器上的）<br>服务端的 JS 发送响应（Node.js 上的）<br><strong>1.JS 可以设置任意请求 header</strong><br>第一部分 request.open(method, url)<br>第二部分 request.setRequstHeader(‘content-type’,’application/x-www-form-urlencoded’)<br>第四部分 request.send(body)<br><strong>2.JS 可以获取任意响应 header</strong><br>第一部分 request.status / request.statusText<br>第二部分 request.getResponseHeader() / request.getAllResponseHeaders()<br>第四部分 request.responseText<br>图解<img src=\"https://upload-images.jianshu.io/upload_images/7094266-82d62fca23713ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>有关回调 (callback:打电话回来)：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">succseeFn.call(undefined, request.responseText)</span><br><span class=\"line\">//这种形式就是回调</span><br><span class=\"line\">succseeFn: () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>promise 的 .then() 和 .then().then() 理解</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(</span><br><span class=\"line\">  fn1,fn2</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  fn3,fn4</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>.then( , ) 逗号左边为成功执行，右边为失败执行<br>我们可以称第一个： <strong>.then( fn1 , fn2 )</strong>为第一负责人；第二个： <strong>.then( fn3 , fn4 )</strong>为第二负责人<br>第一负责人成功则执行 fn1 ，失败则执行 fn2；第一负责人处理完成处理则第二负责人执行 fn3 ，处理不好（如代码有问题）则执行 fn4</p>\n<hr>\n<p>本文仅供个人学习使用</p>\n"},{"title":"恢复 github 上不显示的绿块","date":"2018-07-15T16:50:39.000Z","_content":"\ngithub 是一个良好的记录自己代码的 git 版本控制平台，看到自己有关的 contributions 的小绿块是件开心的事。但是如果，你的每次 commit 都没有相应的小绿块，是不是很伤感呢。\n\n之前我的 github 一直存在这个问题，虽然写代码不是为了说有这个小绿块。但是没有的话，commit 的积极性会大受打击。\n\n最后 google 终于找到了解决方法，原来我 github 绑定的是 qq 邮箱，而 git bash 上保存的 email 地址是谷歌邮箱。（其实之前也搜索到这些答案，但是由于确信当时使用的是谷歌邮箱而一直没有去看，当然或许是没想到。）\n\n方法是在 github 的 settings 里 Emails 中 Add 你一直错用的邮箱，这样小绿块就回来了，开心，以后又可以愉快得 commit 了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4913eaff0e17eecc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意只有你的终端里绑定的邮箱有效，上面的方法才可行，即你的小绿块记录会回来；如果你用的是无效邮箱，那就只能改终端绑定邮箱为 github 上邮箱来让未来的小绿块不丢失了（或许还有别的找回无效邮箱提交 commit 小绿块的方法，我不知道）有关教程可看我提供参考链接\n\n---\n\n本文主要用于个人学习使用，也希望能帮到你\n\n参考：\n\n[解决提交到 GitHub 首页不显示的问题](https://blog.csdn.net/Cloudox_/article/details/50284193)\n\n[解决 github 提交 commit,contributions 不统计显示绿色的问题](https://www.cnblogs.com/dongliu/p/5782329.html)\n","source":"_posts/恢复github上不显示的绿块.md","raw":"---\ntitle: 恢复 github 上不显示的绿块\ndate: 2018-07-16 00:50:39\ntags: git\n---\n\ngithub 是一个良好的记录自己代码的 git 版本控制平台，看到自己有关的 contributions 的小绿块是件开心的事。但是如果，你的每次 commit 都没有相应的小绿块，是不是很伤感呢。\n\n之前我的 github 一直存在这个问题，虽然写代码不是为了说有这个小绿块。但是没有的话，commit 的积极性会大受打击。\n\n最后 google 终于找到了解决方法，原来我 github 绑定的是 qq 邮箱，而 git bash 上保存的 email 地址是谷歌邮箱。（其实之前也搜索到这些答案，但是由于确信当时使用的是谷歌邮箱而一直没有去看，当然或许是没想到。）\n\n方法是在 github 的 settings 里 Emails 中 Add 你一直错用的邮箱，这样小绿块就回来了，开心，以后又可以愉快得 commit 了\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4913eaff0e17eecc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意只有你的终端里绑定的邮箱有效，上面的方法才可行，即你的小绿块记录会回来；如果你用的是无效邮箱，那就只能改终端绑定邮箱为 github 上邮箱来让未来的小绿块不丢失了（或许还有别的找回无效邮箱提交 commit 小绿块的方法，我不知道）有关教程可看我提供参考链接\n\n---\n\n本文主要用于个人学习使用，也希望能帮到你\n\n参考：\n\n[解决提交到 GitHub 首页不显示的问题](https://blog.csdn.net/Cloudox_/article/details/50284193)\n\n[解决 github 提交 commit,contributions 不统计显示绿色的问题](https://www.cnblogs.com/dongliu/p/5782329.html)\n","slug":"恢复github上不显示的绿块","published":1,"updated":"2020-03-28T17:37:58.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz5000rws9990w4u6g2","content":"<p>github 是一个良好的记录自己代码的 git 版本控制平台，看到自己有关的 contributions 的小绿块是件开心的事。但是如果，你的每次 commit 都没有相应的小绿块，是不是很伤感呢。</p>\n<p>之前我的 github 一直存在这个问题，虽然写代码不是为了说有这个小绿块。但是没有的话，commit 的积极性会大受打击。</p>\n<p>最后 google 终于找到了解决方法，原来我 github 绑定的是 qq 邮箱，而 git bash 上保存的 email 地址是谷歌邮箱。（其实之前也搜索到这些答案，但是由于确信当时使用的是谷歌邮箱而一直没有去看，当然或许是没想到。）</p>\n<p>方法是在 github 的 settings 里 Emails 中 Add 你一直错用的邮箱，这样小绿块就回来了，开心，以后又可以愉快得 commit 了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4913eaff0e17eecc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>注意只有你的终端里绑定的邮箱有效，上面的方法才可行，即你的小绿块记录会回来；如果你用的是无效邮箱，那就只能改终端绑定邮箱为 github 上邮箱来让未来的小绿块不丢失了（或许还有别的找回无效邮箱提交 commit 小绿块的方法，我不知道）有关教程可看我提供参考链接</p>\n<hr>\n<p>本文主要用于个人学习使用，也希望能帮到你</p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/Cloudox_/article/details/50284193\" target=\"_blank\" rel=\"noopener\">解决提交到 GitHub 首页不显示的问题</a></p>\n<p><a href=\"https://www.cnblogs.com/dongliu/p/5782329.html\" target=\"_blank\" rel=\"noopener\">解决 github 提交 commit,contributions 不统计显示绿色的问题</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>github 是一个良好的记录自己代码的 git 版本控制平台，看到自己有关的 contributions 的小绿块是件开心的事。但是如果，你的每次 commit 都没有相应的小绿块，是不是很伤感呢。</p>\n<p>之前我的 github 一直存在这个问题，虽然写代码不是为了说有这个小绿块。但是没有的话，commit 的积极性会大受打击。</p>\n<p>最后 google 终于找到了解决方法，原来我 github 绑定的是 qq 邮箱，而 git bash 上保存的 email 地址是谷歌邮箱。（其实之前也搜索到这些答案，但是由于确信当时使用的是谷歌邮箱而一直没有去看，当然或许是没想到。）</p>\n<p>方法是在 github 的 settings 里 Emails 中 Add 你一直错用的邮箱，这样小绿块就回来了，开心，以后又可以愉快得 commit 了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4913eaff0e17eecc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>注意只有你的终端里绑定的邮箱有效，上面的方法才可行，即你的小绿块记录会回来；如果你用的是无效邮箱，那就只能改终端绑定邮箱为 github 上邮箱来让未来的小绿块不丢失了（或许还有别的找回无效邮箱提交 commit 小绿块的方法，我不知道）有关教程可看我提供参考链接</p>\n<hr>\n<p>本文主要用于个人学习使用，也希望能帮到你</p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/Cloudox_/article/details/50284193\" target=\"_blank\" rel=\"noopener\">解决提交到 GitHub 首页不显示的问题</a></p>\n<p><a href=\"https://www.cnblogs.com/dongliu/p/5782329.html\" target=\"_blank\" rel=\"noopener\">解决 github 提交 commit,contributions 不统计显示绿色的问题</a></p>\n"},{"title":"有关 HTTP 协议（IP 和端口）","date":"2018-06-08T06:51:05.000Z","_content":"\n# 网络与 IP\n\nHTTP 协议的底层其实是由 TCP 协议和 IP 协议（简称 TCP/IP）构建的\n\n**TCP 传输控制协议（Transmission Control Protocol）**\n\n**1.[TCP 和 UDP 的区别是什么](https://www.nowcoder.com/questionTerminal/63c8b45c91a544bd8febc1f1ff02e3b5?toCommentId=73766)**\n\n简答：TCP 可靠、面向连接、相对 UDP 较慢（求速度）；UDP 不可靠，不面向连接、相对 TCP 较快（求安全）。\n\n2.[TCP 的三次握手指的是什么](https://github.com/jawil/blog/issues/14)\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5c97dd6f5e872dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n简答：每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：\n\n1\\. 客户端：我要连接你了，可以吗\n\n2\\. 服务端：嗯，我准备好了，连接我吧\n\n3\\. 客户端：那我连接你咯。\n\n然后 开始后面步骤\n\n---\n\n**IP 网络协议（英语：Internet Protocol）**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-03aaae9c062d73d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n路由器没有「固定的外网 IP」\n\n路由器给自己的内网  **IP（192.168.1.1）**\n\n本地** IP：127.0.0.1 **表示设备自己\n\n特殊的** IP：0.0.0.0 **不表示任何设备\n\n# 端口\n\n你想要访问一个设备（前提是你使用的是 TCP 或 UDP 协议。还记得吗，HTTP 就使用了 TCP），只指定 IP 是不够的，还**必须**指定 端口（Port）\n\n**原则：一个端口对应一个服务**\n\n要提供 HTTP 服务你最好使用 80 端口（能不能使用别的端口？可以，不过不建议你违反约定）\n\n要提供 HTTPS 服务你最好使用 443 端口（能不能使用别的端口？可以，不过不建议你违反约定）\n\n要提供 FTP 服务你最好使用 21 端口（能不能使用别的端口？可以，不过不建议你违反约定）\n\n**如何知道用何端口？**\n\n0 到 1023 号端口对应的服务 [维基百科](https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3)\n\n**一共由多少端口？**\n\n每个机器一共有 65535（2 的 16 次方减 1）个端口（这是协议规定的）。不过这些端口的使用由一些规定\n\n0 到 1023（2 的 10 次方减 1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口。\n\n其他端口可以给普通用户使用\n\n如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。\n\n**使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可**\n\n**访问网站时候浏览器帮你加了默认端口号，因此你不需要加也可以访问**\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n","source":"_posts/有关-HTTP-协议（IP和端口）.md","raw":"---\ntitle: 有关 HTTP 协议（IP 和端口）\ndate: 2018-06-08 14:51:05\ntags: HTTP\n---\n\n# 网络与 IP\n\nHTTP 协议的底层其实是由 TCP 协议和 IP 协议（简称 TCP/IP）构建的\n\n**TCP 传输控制协议（Transmission Control Protocol）**\n\n**1.[TCP 和 UDP 的区别是什么](https://www.nowcoder.com/questionTerminal/63c8b45c91a544bd8febc1f1ff02e3b5?toCommentId=73766)**\n\n简答：TCP 可靠、面向连接、相对 UDP 较慢（求速度）；UDP 不可靠，不面向连接、相对 TCP 较快（求安全）。\n\n2.[TCP 的三次握手指的是什么](https://github.com/jawil/blog/issues/14)\n\n![](https://upload-images.jianshu.io/upload_images/7094266-5c97dd6f5e872dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n简答：每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：\n\n1\\. 客户端：我要连接你了，可以吗\n\n2\\. 服务端：嗯，我准备好了，连接我吧\n\n3\\. 客户端：那我连接你咯。\n\n然后 开始后面步骤\n\n---\n\n**IP 网络协议（英语：Internet Protocol）**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-03aaae9c062d73d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n路由器没有「固定的外网 IP」\n\n路由器给自己的内网  **IP（192.168.1.1）**\n\n本地** IP：127.0.0.1 **表示设备自己\n\n特殊的** IP：0.0.0.0 **不表示任何设备\n\n# 端口\n\n你想要访问一个设备（前提是你使用的是 TCP 或 UDP 协议。还记得吗，HTTP 就使用了 TCP），只指定 IP 是不够的，还**必须**指定 端口（Port）\n\n**原则：一个端口对应一个服务**\n\n要提供 HTTP 服务你最好使用 80 端口（能不能使用别的端口？可以，不过不建议你违反约定）\n\n要提供 HTTPS 服务你最好使用 443 端口（能不能使用别的端口？可以，不过不建议你违反约定）\n\n要提供 FTP 服务你最好使用 21 端口（能不能使用别的端口？可以，不过不建议你违反约定）\n\n**如何知道用何端口？**\n\n0 到 1023 号端口对应的服务 [维基百科](https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3)\n\n**一共由多少端口？**\n\n每个机器一共有 65535（2 的 16 次方减 1）个端口（这是协议规定的）。不过这些端口的使用由一些规定\n\n0 到 1023（2 的 10 次方减 1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口。\n\n其他端口可以给普通用户使用\n\n如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。\n\n**使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可**\n\n**访问网站时候浏览器帮你加了默认端口号，因此你不需要加也可以访问**\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n","slug":"有关-HTTP-协议（IP和端口）","published":1,"updated":"2020-03-28T17:39:01.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz6000sws99u3t830bi","content":"<h1 id=\"网络与-IP\"><a href=\"#网络与-IP\" class=\"headerlink\" title=\"网络与 IP\"></a>网络与 IP</h1><p>HTTP 协议的底层其实是由 TCP 协议和 IP 协议（简称 TCP/IP）构建的</p>\n<p><strong>TCP 传输控制协议（Transmission Control Protocol）</strong></p>\n<p><strong>1.<a href=\"https://www.nowcoder.com/questionTerminal/63c8b45c91a544bd8febc1f1ff02e3b5?toCommentId=73766\" target=\"_blank\" rel=\"noopener\">TCP 和 UDP 的区别是什么</a></strong></p>\n<p>简答：TCP 可靠、面向连接、相对 UDP 较慢（求速度）；UDP 不可靠，不面向连接、相对 TCP 较快（求安全）。</p>\n<p>2.<a href=\"https://github.com/jawil/blog/issues/14\">TCP 的三次握手指的是什么</a></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5c97dd6f5e872dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>简答：每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：</p>\n<p>1. 客户端：我要连接你了，可以吗</p>\n<p>2. 服务端：嗯，我准备好了，连接我吧</p>\n<p>3. 客户端：那我连接你咯。</p>\n<p>然后 开始后面步骤</p>\n<hr>\n<p><strong>IP 网络协议（英语：Internet Protocol）</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-03aaae9c062d73d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>路由器没有「固定的外网 IP」</p>\n<p>路由器给自己的内网  <strong>IP（192.168.1.1）</strong></p>\n<p>本地<strong> IP：127.0.0.1 </strong>表示设备自己</p>\n<p>特殊的<strong> IP：0.0.0.0 </strong>不表示任何设备</p>\n<h1 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h1><p>你想要访问一个设备（前提是你使用的是 TCP 或 UDP 协议。还记得吗，HTTP 就使用了 TCP），只指定 IP 是不够的，还<strong>必须</strong>指定 端口（Port）</p>\n<p><strong>原则：一个端口对应一个服务</strong></p>\n<p>要提供 HTTP 服务你最好使用 80 端口（能不能使用别的端口？可以，不过不建议你违反约定）</p>\n<p>要提供 HTTPS 服务你最好使用 443 端口（能不能使用别的端口？可以，不过不建议你违反约定）</p>\n<p>要提供 FTP 服务你最好使用 21 端口（能不能使用别的端口？可以，不过不建议你违反约定）</p>\n<p><strong>如何知道用何端口？</strong></p>\n<p>0 到 1023 号端口对应的服务 <a href=\"https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<p><strong>一共由多少端口？</strong></p>\n<p>每个机器一共有 65535（2 的 16 次方减 1）个端口（这是协议规定的）。不过这些端口的使用由一些规定</p>\n<p>0 到 1023（2 的 10 次方减 1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口。</p>\n<p>其他端口可以给普通用户使用</p>\n<p>如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。</p>\n<p><strong>使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可</strong></p>\n<p><strong>访问网站时候浏览器帮你加了默认端口号，因此你不需要加也可以访问</strong></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络与-IP\"><a href=\"#网络与-IP\" class=\"headerlink\" title=\"网络与 IP\"></a>网络与 IP</h1><p>HTTP 协议的底层其实是由 TCP 协议和 IP 协议（简称 TCP/IP）构建的</p>\n<p><strong>TCP 传输控制协议（Transmission Control Protocol）</strong></p>\n<p><strong>1.<a href=\"https://www.nowcoder.com/questionTerminal/63c8b45c91a544bd8febc1f1ff02e3b5?toCommentId=73766\" target=\"_blank\" rel=\"noopener\">TCP 和 UDP 的区别是什么</a></strong></p>\n<p>简答：TCP 可靠、面向连接、相对 UDP 较慢（求速度）；UDP 不可靠，不面向连接、相对 TCP 较快（求安全）。</p>\n<p>2.<a href=\"https://github.com/jawil/blog/issues/14\">TCP 的三次握手指的是什么</a></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-5c97dd6f5e872dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>简答：每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：</p>\n<p>1. 客户端：我要连接你了，可以吗</p>\n<p>2. 服务端：嗯，我准备好了，连接我吧</p>\n<p>3. 客户端：那我连接你咯。</p>\n<p>然后 开始后面步骤</p>\n<hr>\n<p><strong>IP 网络协议（英语：Internet Protocol）</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-03aaae9c062d73d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>路由器没有「固定的外网 IP」</p>\n<p>路由器给自己的内网  <strong>IP（192.168.1.1）</strong></p>\n<p>本地<strong> IP：127.0.0.1 </strong>表示设备自己</p>\n<p>特殊的<strong> IP：0.0.0.0 </strong>不表示任何设备</p>\n<h1 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h1><p>你想要访问一个设备（前提是你使用的是 TCP 或 UDP 协议。还记得吗，HTTP 就使用了 TCP），只指定 IP 是不够的，还<strong>必须</strong>指定 端口（Port）</p>\n<p><strong>原则：一个端口对应一个服务</strong></p>\n<p>要提供 HTTP 服务你最好使用 80 端口（能不能使用别的端口？可以，不过不建议你违反约定）</p>\n<p>要提供 HTTPS 服务你最好使用 443 端口（能不能使用别的端口？可以，不过不建议你违反约定）</p>\n<p>要提供 FTP 服务你最好使用 21 端口（能不能使用别的端口？可以，不过不建议你违反约定）</p>\n<p><strong>如何知道用何端口？</strong></p>\n<p>0 到 1023 号端口对应的服务 <a href=\"https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<p><strong>一共由多少端口？</strong></p>\n<p>每个机器一共有 65535（2 的 16 次方减 1）个端口（这是协议规定的）。不过这些端口的使用由一些规定</p>\n<p>0 到 1023（2 的 10 次方减 1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口。</p>\n<p>其他端口可以给普通用户使用</p>\n<p>如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。</p>\n<p><strong>使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可</strong></p>\n<p><strong>访问网站时候浏览器帮你加了默认端口号，因此你不需要加也可以访问</strong></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n"},{"title":"搞懂这些 你就理解 this 了","date":"2018-08-26T16:48:41.000Z","_content":"\n新人推荐先看阮大大的书的：[相关章节](https://wangdoc.com/javascript/oop/this.html#%E6%B6%B5%E4%B9%89)\n有关 this 的理解，方老师的这篇 [文章](https://zhuanlan.zhihu.com/p/23804247) 已经很完美了\n\n**你应该已经知道并熟记 this 是 call 的第一个参数**\n下面是一些 this 的特殊情况\n\n```\n// 例 1\nbutton.onclick = function f1(){\n    console.log(this) // 触发事件的元素。  button\n}\n```\n\n1 结果：\nf1.call(???)\nthis 是什么？去看 onclick 的源码呀 -> 做不到\nMDN 的开发者知道 onclick 的源码\nMDN 的开发者写了文档\n看文档呀\n\n```\n// 例 2\nbutton.addEventListener('click', function(){\n    console.log(this) // 该元素的引用 button\n}\n```\n\n2 结果：\n去看 addEventListener 的源码呀 -> 做不到\nMDN 的开发者知道 addEventListener 的源码\nMDN 的开发者写了文档\n看文档呀\n\n```\n// 例 3\n$('ul').on('click', 'li' /*selector*/, function(){\n    console.log(this) //this 则代表了与 selector 相匹配的元素。\n    // li 元素\n})\n```\n\n3 结果：\n去看 on 的源码呀 -> 做不到\njQuery 的开发者知道 onclick 的源码\njQuery 的开发者写了文档\n看文档呀\n\n**特例：我可以传一个 this 给它**\n\n```\nbutton.onclick.call({name: 'ada'})\n```\n\n由于 this 是 call 的第一个参数\n这样子 button.onclick 的 this 就变成了 {name:'ada'}\n\n**终极例题**\n理解下面例子，基本上 this 就明白得差不多了\n\n```\nfunction X(){\n    return object = {\n        name: 'object',\n        options: null,\n        f1(x){\n            // 3 下面的 this ？不就是 f1.call()的 this，就是 2 里面的 this：object\n            this.options = x // 4 这里 x 是 options\n            this.f2() // 5 this.f2.call() 显然这里 this 也是 object\n        },\n        f2(){\n            this.options.f2.call(this) // 6 这句代码4告诉我们是 options.f2.call(this) 我们把 this：object 传给了 options （特例）\n        }\n    }\n}\n\nvar options = {\n    name: 'options',\n    f1(){},\n    f2(){\n        console.log(this) // 问 this 是啥 ? // 7  传过来的 object 啊\n    }\n}\n\nvar x = X() // 1 这里的 x 是啥？X() return 的 object\nx.f1(options) // 2 x.f1.call(x,options) 显然这里 this 就是 x === object\n```\n\n问题：上面代码打印的 this 是什么？\n正确答案：object ，思路已经在注释里，按数字顺序理解\n\n---\n\n参考：\n[你怎么还没搞懂 this？](https://zhuanlan.zhihu.com/p/25991271)\n","source":"_posts/搞懂这些-你就理解-this-了.md","raw":"---\ntitle: 搞懂这些 你就理解 this 了\ndate: 2018-08-27 00:48:41\ntags: JavaScript\n---\n\n新人推荐先看阮大大的书的：[相关章节](https://wangdoc.com/javascript/oop/this.html#%E6%B6%B5%E4%B9%89)\n有关 this 的理解，方老师的这篇 [文章](https://zhuanlan.zhihu.com/p/23804247) 已经很完美了\n\n**你应该已经知道并熟记 this 是 call 的第一个参数**\n下面是一些 this 的特殊情况\n\n```\n// 例 1\nbutton.onclick = function f1(){\n    console.log(this) // 触发事件的元素。  button\n}\n```\n\n1 结果：\nf1.call(???)\nthis 是什么？去看 onclick 的源码呀 -> 做不到\nMDN 的开发者知道 onclick 的源码\nMDN 的开发者写了文档\n看文档呀\n\n```\n// 例 2\nbutton.addEventListener('click', function(){\n    console.log(this) // 该元素的引用 button\n}\n```\n\n2 结果：\n去看 addEventListener 的源码呀 -> 做不到\nMDN 的开发者知道 addEventListener 的源码\nMDN 的开发者写了文档\n看文档呀\n\n```\n// 例 3\n$('ul').on('click', 'li' /*selector*/, function(){\n    console.log(this) //this 则代表了与 selector 相匹配的元素。\n    // li 元素\n})\n```\n\n3 结果：\n去看 on 的源码呀 -> 做不到\njQuery 的开发者知道 onclick 的源码\njQuery 的开发者写了文档\n看文档呀\n\n**特例：我可以传一个 this 给它**\n\n```\nbutton.onclick.call({name: 'ada'})\n```\n\n由于 this 是 call 的第一个参数\n这样子 button.onclick 的 this 就变成了 {name:'ada'}\n\n**终极例题**\n理解下面例子，基本上 this 就明白得差不多了\n\n```\nfunction X(){\n    return object = {\n        name: 'object',\n        options: null,\n        f1(x){\n            // 3 下面的 this ？不就是 f1.call()的 this，就是 2 里面的 this：object\n            this.options = x // 4 这里 x 是 options\n            this.f2() // 5 this.f2.call() 显然这里 this 也是 object\n        },\n        f2(){\n            this.options.f2.call(this) // 6 这句代码4告诉我们是 options.f2.call(this) 我们把 this：object 传给了 options （特例）\n        }\n    }\n}\n\nvar options = {\n    name: 'options',\n    f1(){},\n    f2(){\n        console.log(this) // 问 this 是啥 ? // 7  传过来的 object 啊\n    }\n}\n\nvar x = X() // 1 这里的 x 是啥？X() return 的 object\nx.f1(options) // 2 x.f1.call(x,options) 显然这里 this 就是 x === object\n```\n\n问题：上面代码打印的 this 是什么？\n正确答案：object ，思路已经在注释里，按数字顺序理解\n\n---\n\n参考：\n[你怎么还没搞懂 this？](https://zhuanlan.zhihu.com/p/25991271)\n","slug":"搞懂这些-你就理解-this-了","published":1,"updated":"2020-03-28T17:23:14.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz7000tws99tpnuozum","content":"<p>新人推荐先看阮大大的书的：<a href=\"https://wangdoc.com/javascript/oop/this.html#%E6%B6%B5%E4%B9%89\" target=\"_blank\" rel=\"noopener\">相关章节</a><br>有关 this 的理解，方老师的这篇 <a href=\"https://zhuanlan.zhihu.com/p/23804247\" target=\"_blank\" rel=\"noopener\">文章</a> 已经很完美了</p>\n<p><strong>你应该已经知道并熟记 this 是 call 的第一个参数</strong><br>下面是一些 this 的特殊情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例 1</span><br><span class=\"line\">button.onclick = function f1()&#123;</span><br><span class=\"line\">    console.log(this) // 触发事件的元素。  button</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1 结果：<br>f1.call(???)<br>this 是什么？去看 onclick 的源码呀 -&gt; 做不到<br>MDN 的开发者知道 onclick 的源码<br>MDN 的开发者写了文档<br>看文档呀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例 2</span><br><span class=\"line\">button.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">    console.log(this) // 该元素的引用 button</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2 结果：<br>去看 addEventListener 的源码呀 -&gt; 做不到<br>MDN 的开发者知道 addEventListener 的源码<br>MDN 的开发者写了文档<br>看文档呀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例 3</span><br><span class=\"line\">$(&apos;ul&apos;).on(&apos;click&apos;, &apos;li&apos; /*selector*/, function()&#123;</span><br><span class=\"line\">    console.log(this) //this 则代表了与 selector 相匹配的元素。</span><br><span class=\"line\">    // li 元素</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>3 结果：<br>去看 on 的源码呀 -&gt; 做不到<br>jQuery 的开发者知道 onclick 的源码<br>jQuery 的开发者写了文档<br>看文档呀</p>\n<p><strong>特例：我可以传一个 this 给它</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onclick.call(&#123;name: &apos;ada&apos;&#125;)</span><br></pre></td></tr></table></figure>\n<p>由于 this 是 call 的第一个参数<br>这样子 button.onclick 的 this 就变成了 {name:’ada’}</p>\n<p><strong>终极例题</strong><br>理解下面例子，基本上 this 就明白得差不多了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function X()&#123;</span><br><span class=\"line\">    return object = &#123;</span><br><span class=\"line\">        name: &apos;object&apos;,</span><br><span class=\"line\">        options: null,</span><br><span class=\"line\">        f1(x)&#123;</span><br><span class=\"line\">            // 3 下面的 this ？不就是 f1.call()的 this，就是 2 里面的 this：object</span><br><span class=\"line\">            this.options = x // 4 这里 x 是 options</span><br><span class=\"line\">            this.f2() // 5 this.f2.call() 显然这里 this 也是 object</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        f2()&#123;</span><br><span class=\"line\">            this.options.f2.call(this) // 6 这句代码4告诉我们是 options.f2.call(this) 我们把 this：object 传给了 options （特例）</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    name: &apos;options&apos;,</span><br><span class=\"line\">    f1()&#123;&#125;,</span><br><span class=\"line\">    f2()&#123;</span><br><span class=\"line\">        console.log(this) // 问 this 是啥 ? // 7  传过来的 object 啊</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var x = X() // 1 这里的 x 是啥？X() return 的 object</span><br><span class=\"line\">x.f1(options) // 2 x.f1.call(x,options) 显然这里 this 就是 x === object</span><br></pre></td></tr></table></figure>\n<p>问题：上面代码打印的 this 是什么？<br>正确答案：object ，思路已经在注释里，按数字顺序理解</p>\n<hr>\n<p>参考：<br><a href=\"https://zhuanlan.zhihu.com/p/25991271\" target=\"_blank\" rel=\"noopener\">你怎么还没搞懂 this？</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>新人推荐先看阮大大的书的：<a href=\"https://wangdoc.com/javascript/oop/this.html#%E6%B6%B5%E4%B9%89\" target=\"_blank\" rel=\"noopener\">相关章节</a><br>有关 this 的理解，方老师的这篇 <a href=\"https://zhuanlan.zhihu.com/p/23804247\" target=\"_blank\" rel=\"noopener\">文章</a> 已经很完美了</p>\n<p><strong>你应该已经知道并熟记 this 是 call 的第一个参数</strong><br>下面是一些 this 的特殊情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例 1</span><br><span class=\"line\">button.onclick = function f1()&#123;</span><br><span class=\"line\">    console.log(this) // 触发事件的元素。  button</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1 结果：<br>f1.call(???)<br>this 是什么？去看 onclick 的源码呀 -&gt; 做不到<br>MDN 的开发者知道 onclick 的源码<br>MDN 的开发者写了文档<br>看文档呀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例 2</span><br><span class=\"line\">button.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">    console.log(this) // 该元素的引用 button</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2 结果：<br>去看 addEventListener 的源码呀 -&gt; 做不到<br>MDN 的开发者知道 addEventListener 的源码<br>MDN 的开发者写了文档<br>看文档呀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例 3</span><br><span class=\"line\">$(&apos;ul&apos;).on(&apos;click&apos;, &apos;li&apos; /*selector*/, function()&#123;</span><br><span class=\"line\">    console.log(this) //this 则代表了与 selector 相匹配的元素。</span><br><span class=\"line\">    // li 元素</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>3 结果：<br>去看 on 的源码呀 -&gt; 做不到<br>jQuery 的开发者知道 onclick 的源码<br>jQuery 的开发者写了文档<br>看文档呀</p>\n<p><strong>特例：我可以传一个 this 给它</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onclick.call(&#123;name: &apos;ada&apos;&#125;)</span><br></pre></td></tr></table></figure>\n<p>由于 this 是 call 的第一个参数<br>这样子 button.onclick 的 this 就变成了 {name:’ada’}</p>\n<p><strong>终极例题</strong><br>理解下面例子，基本上 this 就明白得差不多了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function X()&#123;</span><br><span class=\"line\">    return object = &#123;</span><br><span class=\"line\">        name: &apos;object&apos;,</span><br><span class=\"line\">        options: null,</span><br><span class=\"line\">        f1(x)&#123;</span><br><span class=\"line\">            // 3 下面的 this ？不就是 f1.call()的 this，就是 2 里面的 this：object</span><br><span class=\"line\">            this.options = x // 4 这里 x 是 options</span><br><span class=\"line\">            this.f2() // 5 this.f2.call() 显然这里 this 也是 object</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        f2()&#123;</span><br><span class=\"line\">            this.options.f2.call(this) // 6 这句代码4告诉我们是 options.f2.call(this) 我们把 this：object 传给了 options （特例）</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    name: &apos;options&apos;,</span><br><span class=\"line\">    f1()&#123;&#125;,</span><br><span class=\"line\">    f2()&#123;</span><br><span class=\"line\">        console.log(this) // 问 this 是啥 ? // 7  传过来的 object 啊</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var x = X() // 1 这里的 x 是啥？X() return 的 object</span><br><span class=\"line\">x.f1(options) // 2 x.f1.call(x,options) 显然这里 this 就是 x === object</span><br></pre></td></tr></table></figure>\n<p>问题：上面代码打印的 this 是什么？<br>正确答案：object ，思路已经在注释里，按数字顺序理解</p>\n<hr>\n<p>参考：<br><a href=\"https://zhuanlan.zhihu.com/p/25991271\" target=\"_blank\" rel=\"noopener\">你怎么还没搞懂 this？</a></p>\n"},{"title":"浅谈 JS 继承","date":"2018-11-02T12:38:27.000Z","_content":"\n# 什么是继承\n\n根据维基百科解释，可以简单概括为：\n继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。\n\n# JS 里的原型继承模型\n\nJS：不好意思，我没有类。（即使是 ES6 中的类也是语法糖）\nJavaScript 是基于原型实现面向对象的，那么在 JS 中，面向对象概念中的继承自然也是基于原型。\n\n> 当谈到继承时，JavaScript  只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（**prototype**）。该原型对象也有一个自己的原型对象  ，层层向上直到一个对象的原型对象为  `null`。根据定义，`null`  没有原型，并作为这个**原型链**中的最后一个环节。\n\n> 几乎所有 JavaScript 中的对象都是位于原型链顶端的 **Object** 的实例。\n\n有关原型之前写过博客[JavaScript 原型和原型链](https://www.jianshu.com/p/93441c4e8f48)，对理解下面内容有帮助。\n虽然没有传统语言意义上的类，但是 JS 语言 使用构造函数生成对象，实现面向对象程序设计。\n\n# 说了这么多，JS 中的继承到底是什么？\n\n**可以简单理解为：两次的原型搜索就是继承。\n数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。**\n\n接下来我们用代码实现一下继承\n\n## 1. 使用 prototype 实现继承\n\n**prototype 的作用：为构造函数内添加实例对象之间的共有属性**\n\n**明确 JS 内的继承**\n以下面代码为例\n\n```\n// 构造一个 人类\nfunction Human(name){\n  this.name = name\n}\n// 给所有 人类 添加一个 跑 的共有属性\nHuman.prototype.run = function(){\n  console.log(\"我叫\"+this.name+\"，我在跑\")\n  return undefined\n}\n// 构造一个 男人类\nfunction Man(name){\n  Human.call(this, name)\n  this.gender = '男'\n}\n// 所有 男人 都有好战属性\nMan.prototype.fight = function(){\n  console.log('糊你熊脸')\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到名为 ada 的人只有 name、gender 和 fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。\n**目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。**\n根据我原型知识的博客里面的内容我们知道，我们可以直接：\n\n```\nMan.prototype.__proto__ = Human.prototype\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到  Man  指向了  Human  而不是直接指向  Object，ada2  继承了来自  Human  的  run  属性\n\n**但是在实际编程过程中直接操作 ** proto ** 这个非标准但许多浏览器（IE 不支持）实现的属性是不规范的。**\n\n那怎么办？\nnew 可不可以？\n\n```\nMan.prototype = new Human()\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**直接用上述代码不行，因为在 new 的过程中，虽然 new 内部实现了 `Man.prototype.__proto__ = Human.prototype` 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined**\n\n那么我们只要避免这个过程中 Human 执行就可以了\n\n```\nvar a = function(){}\na.prototype = Human.prototype\nMan.prototype = new a()\n```\n\n通过上面三行代码，即实现了没有内部执行空函数的 new\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. ES6 实现继承\n\n上面代码的 ES6 版本\n\n```\n// ES6 写法\nclass Human{\n     constructor(name){\n         this.name = name\n     }\n     run(){\n         console.log(\"我叫\"+this.name+\"，我在跑\")\n         return undefined\n     }\n }\n class Man extends Human{ // extends 实现上述继承过程\n     constructor(name){\n         super(name) // 调用构造函数:'超类'\n         this.gender = '男'\n     }\n     fight(){\n         console.log('糊你熊脸')\n     }\n }\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）\n\n# 总结：\n\nJS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。\n\n> 原型继承模型本身实际上比经典模型更强大\n\n---\n\n感谢阅读\n本文仅供个人学习使用\n\n部分参考：[继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n","source":"_posts/浅谈JS继承.md","raw":"---\ntitle: 浅谈 JS 继承\ndate: 2018-11-02 20:38:27\ntags: JavaScript\n---\n\n# 什么是继承\n\n根据维基百科解释，可以简单概括为：\n继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。\n\n# JS 里的原型继承模型\n\nJS：不好意思，我没有类。（即使是 ES6 中的类也是语法糖）\nJavaScript 是基于原型实现面向对象的，那么在 JS 中，面向对象概念中的继承自然也是基于原型。\n\n> 当谈到继承时，JavaScript  只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（**prototype**）。该原型对象也有一个自己的原型对象  ，层层向上直到一个对象的原型对象为  `null`。根据定义，`null`  没有原型，并作为这个**原型链**中的最后一个环节。\n\n> 几乎所有 JavaScript 中的对象都是位于原型链顶端的 **Object** 的实例。\n\n有关原型之前写过博客[JavaScript 原型和原型链](https://www.jianshu.com/p/93441c4e8f48)，对理解下面内容有帮助。\n虽然没有传统语言意义上的类，但是 JS 语言 使用构造函数生成对象，实现面向对象程序设计。\n\n# 说了这么多，JS 中的继承到底是什么？\n\n**可以简单理解为：两次的原型搜索就是继承。\n数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。**\n\n接下来我们用代码实现一下继承\n\n## 1. 使用 prototype 实现继承\n\n**prototype 的作用：为构造函数内添加实例对象之间的共有属性**\n\n**明确 JS 内的继承**\n以下面代码为例\n\n```\n// 构造一个 人类\nfunction Human(name){\n  this.name = name\n}\n// 给所有 人类 添加一个 跑 的共有属性\nHuman.prototype.run = function(){\n  console.log(\"我叫\"+this.name+\"，我在跑\")\n  return undefined\n}\n// 构造一个 男人类\nfunction Man(name){\n  Human.call(this, name)\n  this.gender = '男'\n}\n// 所有 男人 都有好战属性\nMan.prototype.fight = function(){\n  console.log('糊你熊脸')\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到名为 ada 的人只有 name、gender 和 fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。\n**目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。**\n根据我原型知识的博客里面的内容我们知道，我们可以直接：\n\n```\nMan.prototype.__proto__ = Human.prototype\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到  Man  指向了  Human  而不是直接指向  Object，ada2  继承了来自  Human  的  run  属性\n\n**但是在实际编程过程中直接操作 ** proto ** 这个非标准但许多浏览器（IE 不支持）实现的属性是不规范的。**\n\n那怎么办？\nnew 可不可以？\n\n```\nMan.prototype = new Human()\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**直接用上述代码不行，因为在 new 的过程中，虽然 new 内部实现了 `Man.prototype.__proto__ = Human.prototype` 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined**\n\n那么我们只要避免这个过程中 Human 执行就可以了\n\n```\nvar a = function(){}\na.prototype = Human.prototype\nMan.prototype = new a()\n```\n\n通过上面三行代码，即实现了没有内部执行空函数的 new\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. ES6 实现继承\n\n上面代码的 ES6 版本\n\n```\n// ES6 写法\nclass Human{\n     constructor(name){\n         this.name = name\n     }\n     run(){\n         console.log(\"我叫\"+this.name+\"，我在跑\")\n         return undefined\n     }\n }\n class Man extends Human{ // extends 实现上述继承过程\n     constructor(name){\n         super(name) // 调用构造函数:'超类'\n         this.gender = '男'\n     }\n     fight(){\n         console.log('糊你熊脸')\n     }\n }\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）\n\n# 总结：\n\nJS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。\n\n> 原型继承模型本身实际上比经典模型更强大\n\n---\n\n感谢阅读\n本文仅供个人学习使用\n\n部分参考：[继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n","slug":"浅谈JS继承","published":1,"updated":"2020-03-28T17:38:38.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz8000uws99xancotzq","content":"<h1 id=\"什么是继承\"><a href=\"#什么是继承\" class=\"headerlink\" title=\"什么是继承\"></a>什么是继承</h1><p>根据维基百科解释，可以简单概括为：<br>继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。</p>\n<h1 id=\"JS-里的原型继承模型\"><a href=\"#JS-里的原型继承模型\" class=\"headerlink\" title=\"JS 里的原型继承模型\"></a>JS 里的原型继承模型</h1><p>JS：不好意思，我没有类。（即使是 ES6 中的类也是语法糖）<br>JavaScript 是基于原型实现面向对象的，那么在 JS 中，面向对象概念中的继承自然也是基于原型。</p>\n<blockquote>\n<p>当谈到继承时，JavaScript  只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象  ，层层向上直到一个对象的原型对象为  <code>null</code>。根据定义，<code>null</code>  没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>\n</blockquote>\n<blockquote>\n<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <strong>Object</strong> 的实例。</p>\n</blockquote>\n<p>有关原型之前写过博客<a href=\"https://www.jianshu.com/p/93441c4e8f48\" target=\"_blank\" rel=\"noopener\">JavaScript 原型和原型链</a>，对理解下面内容有帮助。<br>虽然没有传统语言意义上的类，但是 JS 语言 使用构造函数生成对象，实现面向对象程序设计。</p>\n<h1 id=\"说了这么多，JS-中的继承到底是什么？\"><a href=\"#说了这么多，JS-中的继承到底是什么？\" class=\"headerlink\" title=\"说了这么多，JS 中的继承到底是什么？\"></a>说了这么多，JS 中的继承到底是什么？</h1><p><strong>可以简单理解为：两次的原型搜索就是继承。<br>数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。</strong></p>\n<p>接下来我们用代码实现一下继承</p>\n<h2 id=\"1-使用-prototype-实现继承\"><a href=\"#1-使用-prototype-实现继承\" class=\"headerlink\" title=\"1. 使用 prototype 实现继承\"></a>1. 使用 prototype 实现继承</h2><p><strong>prototype 的作用：为构造函数内添加实例对象之间的共有属性</strong></p>\n<p><strong>明确 JS 内的继承</strong><br>以下面代码为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 构造一个 人类</span><br><span class=\"line\">function Human(name)&#123;</span><br><span class=\"line\">  this.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 给所有 人类 添加一个 跑 的共有属性</span><br><span class=\"line\">Human.prototype.run = function()&#123;</span><br><span class=\"line\">  console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class=\"line\">  return undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 构造一个 男人类</span><br><span class=\"line\">function Man(name)&#123;</span><br><span class=\"line\">  Human.call(this, name)</span><br><span class=\"line\">  this.gender = &apos;男&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 所有 男人 都有好战属性</span><br><span class=\"line\">Man.prototype.fight = function()&#123;</span><br><span class=\"line\">  console.log(&apos;糊你熊脸&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以看到名为 ada 的人只有 name、gender 和 fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。<br><strong>目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。</strong><br>根据我原型知识的博客里面的内容我们知道，我们可以直接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Man.prototype.__proto__ = Human.prototype</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以看到  Man  指向了  Human  而不是直接指向  Object，ada2  继承了来自  Human  的  run  属性</p>\n<p><strong>但是在实际编程过程中直接操作 </strong> proto <strong> 这个非标准但许多浏览器（IE 不支持）实现的属性是不规范的。</strong></p>\n<p>那怎么办？<br>new 可不可以？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Man.prototype = new Human()</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>直接用上述代码不行，因为在 new 的过程中，虽然 new 内部实现了 <code>Man.prototype.__proto__ = Human.prototype</code> 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined</strong></p>\n<p>那么我们只要避免这个过程中 Human 执行就可以了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = function()&#123;&#125;</span><br><span class=\"line\">a.prototype = Human.prototype</span><br><span class=\"line\">Man.prototype = new a()</span><br></pre></td></tr></table></figure>\n<p>通过上面三行代码，即实现了没有内部执行空函数的 new</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"2-ES6-实现继承\"><a href=\"#2-ES6-实现继承\" class=\"headerlink\" title=\"2. ES6 实现继承\"></a>2. ES6 实现继承</h2><p>上面代码的 ES6 版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 写法</span><br><span class=\"line\">class Human&#123;</span><br><span class=\"line\">     constructor(name)&#123;</span><br><span class=\"line\">         this.name = name</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     run()&#123;</span><br><span class=\"line\">         console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class=\"line\">         return undefined</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> class Man extends Human&#123; // extends 实现上述继承过程</span><br><span class=\"line\">     constructor(name)&#123;</span><br><span class=\"line\">         super(name) // 调用构造函数:&apos;超类&apos;</span><br><span class=\"line\">         this.gender = &apos;男&apos;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     fight()&#123;</span><br><span class=\"line\">         console.log(&apos;糊你熊脸&apos;)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>JS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。</p>\n<blockquote>\n<p>原型继承模型本身实际上比经典模型更强大</p>\n</blockquote>\n<hr>\n<p>感谢阅读<br>本文仅供个人学习使用</p>\n<p>部分参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">继承与原型链</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是继承\"><a href=\"#什么是继承\" class=\"headerlink\" title=\"什么是继承\"></a>什么是继承</h1><p>根据维基百科解释，可以简单概括为：<br>继承是类与类之间的关系，其作用是使得子类具有父类别的各种属性和方法。</p>\n<h1 id=\"JS-里的原型继承模型\"><a href=\"#JS-里的原型继承模型\" class=\"headerlink\" title=\"JS 里的原型继承模型\"></a>JS 里的原型继承模型</h1><p>JS：不好意思，我没有类。（即使是 ES6 中的类也是语法糖）<br>JavaScript 是基于原型实现面向对象的，那么在 JS 中，面向对象概念中的继承自然也是基于原型。</p>\n<blockquote>\n<p>当谈到继承时，JavaScript  只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象  ，层层向上直到一个对象的原型对象为  <code>null</code>。根据定义，<code>null</code>  没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>\n</blockquote>\n<blockquote>\n<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <strong>Object</strong> 的实例。</p>\n</blockquote>\n<p>有关原型之前写过博客<a href=\"https://www.jianshu.com/p/93441c4e8f48\" target=\"_blank\" rel=\"noopener\">JavaScript 原型和原型链</a>，对理解下面内容有帮助。<br>虽然没有传统语言意义上的类，但是 JS 语言 使用构造函数生成对象，实现面向对象程序设计。</p>\n<h1 id=\"说了这么多，JS-中的继承到底是什么？\"><a href=\"#说了这么多，JS-中的继承到底是什么？\" class=\"headerlink\" title=\"说了这么多，JS 中的继承到底是什么？\"></a>说了这么多，JS 中的继承到底是什么？</h1><p><strong>可以简单理解为：两次的原型搜索就是继承。<br>数组 a 从 Array 中原型搜索到 toString 属性，只是实例属性；a 从 Array 中原型搜索到 （Array 从 Object 中原型搜索到的）valueOf 属性，可以称为继承。</strong></p>\n<p>接下来我们用代码实现一下继承</p>\n<h2 id=\"1-使用-prototype-实现继承\"><a href=\"#1-使用-prototype-实现继承\" class=\"headerlink\" title=\"1. 使用 prototype 实现继承\"></a>1. 使用 prototype 实现继承</h2><p><strong>prototype 的作用：为构造函数内添加实例对象之间的共有属性</strong></p>\n<p><strong>明确 JS 内的继承</strong><br>以下面代码为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 构造一个 人类</span><br><span class=\"line\">function Human(name)&#123;</span><br><span class=\"line\">  this.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 给所有 人类 添加一个 跑 的共有属性</span><br><span class=\"line\">Human.prototype.run = function()&#123;</span><br><span class=\"line\">  console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class=\"line\">  return undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 构造一个 男人类</span><br><span class=\"line\">function Man(name)&#123;</span><br><span class=\"line\">  Human.call(this, name)</span><br><span class=\"line\">  this.gender = &apos;男&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 所有 男人 都有好战属性</span><br><span class=\"line\">Man.prototype.fight = function()&#123;</span><br><span class=\"line\">  console.log(&apos;糊你熊脸&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c56b1f3dafb9ff8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以看到名为 ada 的人只有 name、gender 和 fight 这些 Man 构造函数里面含有的属性，而没有我们希望的 Human 应该有的 run 的属性。<br><strong>目标：假如我们有方法让 ada 有了 Man 里面没有的 run 属性，即我们自己实现了 Man 继承 Human 的过程。</strong><br>根据我原型知识的博客里面的内容我们知道，我们可以直接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Man.prototype.__proto__ = Human.prototype</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-3707e4361a656afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以看到  Man  指向了  Human  而不是直接指向  Object，ada2  继承了来自  Human  的  run  属性</p>\n<p><strong>但是在实际编程过程中直接操作 </strong> proto <strong> 这个非标准但许多浏览器（IE 不支持）实现的属性是不规范的。</strong></p>\n<p>那怎么办？<br>new 可不可以？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Man.prototype = new Human()</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4f15ba95a00b7a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>直接用上述代码不行，因为在 new 的过程中，虽然 new 内部实现了 <code>Man.prototype.__proto__ = Human.prototype</code> 这一个过程，但是由于 new 同时会在内部执行构造函数，而在执行过程中我们未传 name，因此上图中 Human 的 name 属性显示 undefined</strong></p>\n<p>那么我们只要避免这个过程中 Human 执行就可以了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = function()&#123;&#125;</span><br><span class=\"line\">a.prototype = Human.prototype</span><br><span class=\"line\">Man.prototype = new a()</span><br></pre></td></tr></table></figure>\n<p>通过上面三行代码，即实现了没有内部执行空函数的 new</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c3c89ccc7f8d8aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"2-ES6-实现继承\"><a href=\"#2-ES6-实现继承\" class=\"headerlink\" title=\"2. ES6 实现继承\"></a>2. ES6 实现继承</h2><p>上面代码的 ES6 版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 写法</span><br><span class=\"line\">class Human&#123;</span><br><span class=\"line\">     constructor(name)&#123;</span><br><span class=\"line\">         this.name = name</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     run()&#123;</span><br><span class=\"line\">         console.log(&quot;我叫&quot;+this.name+&quot;，我在跑&quot;)</span><br><span class=\"line\">         return undefined</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> class Man extends Human&#123; // extends 实现上述继承过程</span><br><span class=\"line\">     constructor(name)&#123;</span><br><span class=\"line\">         super(name) // 调用构造函数:&apos;超类&apos;</span><br><span class=\"line\">         this.gender = &apos;男&apos;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     fight()&#123;</span><br><span class=\"line\">         console.log(&apos;糊你熊脸&apos;)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-f81f6522e88774a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>文章开头已经提到， ES6 的 class 是语法糖，其实质就是函数，而上述用 class 实现继承的过程，还是基于原型链（和 ES5 的是不是完全一致）</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>JS 继承的原型写法相对 ES6 的写法看上去似乎更复杂，但是事实上更好理解；class 的写法更符合面向对象编程的思维，由于是语法糖因而自然写法简便，但其有一定局限性。</p>\n<blockquote>\n<p>原型继承模型本身实际上比经典模型更强大</p>\n</blockquote>\n<hr>\n<p>感谢阅读<br>本文仅供个人学习使用</p>\n<p>部分参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">继承与原型链</a></p>\n"},{"title":"理解 HTTP","date":"2018-06-07T14:16:57.000Z","_content":"\n# **什么是 HTTP**\n\n**HTTP（HyperText Transfer Protocol）**超文本传输协议  [维基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0)\n\n**HTTP 的作用就是指导浏览器和服务器如何进行沟通**\n\n**Client （浏览器）→ HTTP（请求）→Server（80 端口）→HTTP 响应 →Client（浏览器）**\n\n![HTTP请求与响应](https://upload-images.jianshu.io/upload_images/7094266-e2b8fabd058d2313.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n浏览器负责发起请求\n\n服务器在 80 端口接收请求\n\n服务器负责返回内容（响应）\n\n浏览器负责下载响应内容\n\n---\n\n# **HTTP 请求**\n\n![请求的格式](https://upload-images.jianshu.io/upload_images/7094266-3255f775c068ece3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n请求最多包含四部分（图中 1、2、3、4），最少包含三部分。（也就是说第四部分可以为空）\n\n第三部分永远都是一个回车（\\n）\n\n[动词](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95)有 GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS 等\n\n这里的路径包括「查询参数」，但不包括「锚点」\n\n如果你没有写路径，那么路径默认为 /\n\n第 2 部分中的 Content-Type 标注了第 4 部分的格式\n\n# **用 Chrome 发请求**\n\n打开 Network（F12）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ac46ff3c447bfe4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n地址栏输入网址，如 www.baidu.com\n\n在 Network 点击，查看 request，点击「view source」\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a26b808214a7f891.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到请求的前三部分了\n\n如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到\n\n---\n\n# **HTTP 响应**\n\n请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了\n\n![响应的格式](https://upload-images.jianshu.io/upload_images/7094266-0a2a709c31b4f71e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n状态码是服务器对浏览器说的话\n\n[1xx 消息](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF)——请求已被服务器接收，继续处理\n\n[2xx 成功](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx%E6%88%90%E5%8A%9F)——请求已成功被服务器接收、理解、并接受\n\n[3xx 重定向](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx%E9%87%8D%E5%AE%9A%E5%90%91)——需要后续操作才能完成这一请求\n\n[4xx 请求错误](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF)——请求含有词法错误或者无法被执行\n\n[5xx 服务器错误](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF)——服务器在处理某个正确请求时发生错误\n\n状态解释没什么用\n\n第 2 部分中的 Content-Type 标注了第 4 部分的格式\n\n第 2 部分中的 Content-Type 遵循 MIME 规范\n\n# **用 Chrome 查看响应**\n\n打开 Network\n\n输入网址\n\n选中第一个响应\n\n查看 Response Headers，点击「view source」\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c1ef5f68fe12bac5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你会看到响应的前两部分\n\n查看 Response 或者 Preview，你会看到响应的第 4 部分\n\n---\n\n**也可以用命令行发请求并得到响应**\n\n用到**curl**命令，具体可以命令行[释义](https://explainshell.com/)（命令行及命令行释义可以看我相关[blog](https://www.jianshu.com/p/dcf636cbe6af)）\n\n如：**curl -s -v -H  -- \"https://www.baidu.com\"**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-fb73225d2f20d079.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**请求的内容为**\n\n```\n> GET / HTTP/1.1\n\n> Host: www.baidu.com\n\n> User-Agent: curl/7.59.0\n\n> Accept: */*\n\n>\n\n**响应的内容为**\n\n< HTTP/1.1 200 OK\n\n< Accept-Ranges: bytes\n\n< Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform\n\n< Connection: Keep-Alive\n\n< Content-Length: 2443\n\n< Content-Type: text/html\n\n< Date: Thu, 07 Jun 2018 13:54:43 GMT\n\n< Etag: \"58860411-98b\"\n\n< Last-Modified: Mon, 23 Jan 2017 13:24:33 GMT\n\n< Pragma: no-cache\n\n* Server bfe/1.0.8.18 is not blacklisted\n\n< Server: bfe/1.0.8.18\n\n< Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/\n\n<\n```\n\n还有很多可以尝试的 **curl** 命令\n\n可以参考 [链接](http://man.linuxde.net/curl)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n一些参考：\n\n[HTTP-维基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)\n\n[curl 命令](http://man.linuxde.net/curl)\n","source":"_posts/理解HTTP.md","raw":"---\ntitle: 理解 HTTP\ndate: 2018-06-07 22:16:57\ntags: HTTP\n---\n\n# **什么是 HTTP**\n\n**HTTP（HyperText Transfer Protocol）**超文本传输协议  [维基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0)\n\n**HTTP 的作用就是指导浏览器和服务器如何进行沟通**\n\n**Client （浏览器）→ HTTP（请求）→Server（80 端口）→HTTP 响应 →Client（浏览器）**\n\n![HTTP请求与响应](https://upload-images.jianshu.io/upload_images/7094266-e2b8fabd058d2313.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n浏览器负责发起请求\n\n服务器在 80 端口接收请求\n\n服务器负责返回内容（响应）\n\n浏览器负责下载响应内容\n\n---\n\n# **HTTP 请求**\n\n![请求的格式](https://upload-images.jianshu.io/upload_images/7094266-3255f775c068ece3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n请求最多包含四部分（图中 1、2、3、4），最少包含三部分。（也就是说第四部分可以为空）\n\n第三部分永远都是一个回车（\\n）\n\n[动词](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95)有 GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS 等\n\n这里的路径包括「查询参数」，但不包括「锚点」\n\n如果你没有写路径，那么路径默认为 /\n\n第 2 部分中的 Content-Type 标注了第 4 部分的格式\n\n# **用 Chrome 发请求**\n\n打开 Network（F12）\n\n![](https://upload-images.jianshu.io/upload_images/7094266-ac46ff3c447bfe4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n地址栏输入网址，如 www.baidu.com\n\n在 Network 点击，查看 request，点击「view source」\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a26b808214a7f891.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到请求的前三部分了\n\n如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到\n\n---\n\n# **HTTP 响应**\n\n请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了\n\n![响应的格式](https://upload-images.jianshu.io/upload_images/7094266-0a2a709c31b4f71e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n状态码是服务器对浏览器说的话\n\n[1xx 消息](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF)——请求已被服务器接收，继续处理\n\n[2xx 成功](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx%E6%88%90%E5%8A%9F)——请求已成功被服务器接收、理解、并接受\n\n[3xx 重定向](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx%E9%87%8D%E5%AE%9A%E5%90%91)——需要后续操作才能完成这一请求\n\n[4xx 请求错误](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF)——请求含有词法错误或者无法被执行\n\n[5xx 服务器错误](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF)——服务器在处理某个正确请求时发生错误\n\n状态解释没什么用\n\n第 2 部分中的 Content-Type 标注了第 4 部分的格式\n\n第 2 部分中的 Content-Type 遵循 MIME 规范\n\n# **用 Chrome 查看响应**\n\n打开 Network\n\n输入网址\n\n选中第一个响应\n\n查看 Response Headers，点击「view source」\n\n![](https://upload-images.jianshu.io/upload_images/7094266-c1ef5f68fe12bac5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你会看到响应的前两部分\n\n查看 Response 或者 Preview，你会看到响应的第 4 部分\n\n---\n\n**也可以用命令行发请求并得到响应**\n\n用到**curl**命令，具体可以命令行[释义](https://explainshell.com/)（命令行及命令行释义可以看我相关[blog](https://www.jianshu.com/p/dcf636cbe6af)）\n\n如：**curl -s -v -H  -- \"https://www.baidu.com\"**\n\n![](https://upload-images.jianshu.io/upload_images/7094266-fb73225d2f20d079.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**请求的内容为**\n\n```\n> GET / HTTP/1.1\n\n> Host: www.baidu.com\n\n> User-Agent: curl/7.59.0\n\n> Accept: */*\n\n>\n\n**响应的内容为**\n\n< HTTP/1.1 200 OK\n\n< Accept-Ranges: bytes\n\n< Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform\n\n< Connection: Keep-Alive\n\n< Content-Length: 2443\n\n< Content-Type: text/html\n\n< Date: Thu, 07 Jun 2018 13:54:43 GMT\n\n< Etag: \"58860411-98b\"\n\n< Last-Modified: Mon, 23 Jan 2017 13:24:33 GMT\n\n< Pragma: no-cache\n\n* Server bfe/1.0.8.18 is not blacklisted\n\n< Server: bfe/1.0.8.18\n\n< Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/\n\n<\n```\n\n还有很多可以尝试的 **curl** 命令\n\n可以参考 [链接](http://man.linuxde.net/curl)\n\n---\n\n本文主要用于个人学习使用，如有侵权请联系我删除。\n\n一些参考：\n\n[HTTP-维基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)\n\n[curl 命令](http://man.linuxde.net/curl)\n","slug":"理解HTTP","published":1,"updated":"2020-03-28T17:24:40.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswz9000vws99dyknvqaz","content":"<h1 id=\"什么是-HTTP\"><a href=\"#什么是-HTTP\" class=\"headerlink\" title=\"什么是 HTTP\"></a><strong>什么是 HTTP</strong></h1><p><strong>HTTP（HyperText Transfer Protocol）</strong>超文本传输协议  <a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<p><strong>HTTP 的作用就是指导浏览器和服务器如何进行沟通</strong></p>\n<p><strong>Client （浏览器）→ HTTP（请求）→Server（80 端口）→HTTP 响应 →Client（浏览器）</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e2b8fabd058d2313.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"HTTP请求与响应\"></p>\n<p>浏览器负责发起请求</p>\n<p>服务器在 80 端口接收请求</p>\n<p>服务器负责返回内容（响应）</p>\n<p>浏览器负责下载响应内容</p>\n<hr>\n<h1 id=\"HTTP-请求\"><a href=\"#HTTP-请求\" class=\"headerlink\" title=\"HTTP 请求\"></a><strong>HTTP 请求</strong></h1><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-3255f775c068ece3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"请求的格式\"></p>\n<p>请求最多包含四部分（图中 1、2、3、4），最少包含三部分。（也就是说第四部分可以为空）</p>\n<p>第三部分永远都是一个回车（\\n）</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">动词</a>有 GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS 等</p>\n<p>这里的路径包括「查询参数」，但不包括「锚点」</p>\n<p>如果你没有写路径，那么路径默认为 /</p>\n<p>第 2 部分中的 Content-Type 标注了第 4 部分的格式</p>\n<h1 id=\"用-Chrome-发请求\"><a href=\"#用-Chrome-发请求\" class=\"headerlink\" title=\"用 Chrome 发请求\"></a><strong>用 Chrome 发请求</strong></h1><p>打开 Network（F12）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ac46ff3c447bfe4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>地址栏输入网址，如 <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a></p>\n<p>在 Network 点击，查看 request，点击「view source」</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a26b808214a7f891.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以看到请求的前三部分了</p>\n<p>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</p>\n<hr>\n<h1 id=\"HTTP-响应\"><a href=\"#HTTP-响应\" class=\"headerlink\" title=\"HTTP 响应\"></a><strong>HTTP 响应</strong></h1><p>请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0a2a709c31b4f71e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"响应的格式\"></p>\n<p>状态码是服务器对浏览器说的话</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF\" target=\"_blank\" rel=\"noopener\">1xx 消息</a>——请求已被服务器接收，继续处理</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx%E6%88%90%E5%8A%9F\" target=\"_blank\" rel=\"noopener\">2xx 成功</a>——请求已成功被服务器接收、理解、并接受</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx%E9%87%8D%E5%AE%9A%E5%90%91\" target=\"_blank\" rel=\"noopener\">3xx 重定向</a>——需要后续操作才能完成这一请求</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF\" target=\"_blank\" rel=\"noopener\">4xx 请求错误</a>——请求含有词法错误或者无法被执行</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF\" target=\"_blank\" rel=\"noopener\">5xx 服务器错误</a>——服务器在处理某个正确请求时发生错误</p>\n<p>状态解释没什么用</p>\n<p>第 2 部分中的 Content-Type 标注了第 4 部分的格式</p>\n<p>第 2 部分中的 Content-Type 遵循 MIME 规范</p>\n<h1 id=\"用-Chrome-查看响应\"><a href=\"#用-Chrome-查看响应\" class=\"headerlink\" title=\"用 Chrome 查看响应\"></a><strong>用 Chrome 查看响应</strong></h1><p>打开 Network</p>\n<p>输入网址</p>\n<p>选中第一个响应</p>\n<p>查看 Response Headers，点击「view source」</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c1ef5f68fe12bac5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你会看到响应的前两部分</p>\n<p>查看 Response 或者 Preview，你会看到响应的第 4 部分</p>\n<hr>\n<p><strong>也可以用命令行发请求并得到响应</strong></p>\n<p>用到<strong>curl</strong>命令，具体可以命令行<a href=\"https://explainshell.com/\" target=\"_blank\" rel=\"noopener\">释义</a>（命令行及命令行释义可以看我相关<a href=\"https://www.jianshu.com/p/dcf636cbe6af\" target=\"_blank\" rel=\"noopener\">blog</a>）</p>\n<p>如：<strong>curl -s -v -H  – “<a href=\"https://www.baidu.com&quot;\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com&quot;</a></strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fb73225d2f20d079.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>请求的内容为</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; GET / HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Host: www.baidu.com</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; User-Agent: curl/7.59.0</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Accept: */*</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">**响应的内容为**</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Accept-Ranges: bytes</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Connection: Keep-Alive</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Content-Length: 2443</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Content-Type: text/html</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Date: Thu, 07 Jun 2018 13:54:43 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Etag: &quot;58860411-98b&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Last-Modified: Mon, 23 Jan 2017 13:24:33 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Pragma: no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">* Server bfe/1.0.8.18 is not blacklisted</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Server: bfe/1.0.8.18</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;</span><br></pre></td></tr></table></figure>\n<p>还有很多可以尝试的 <strong>curl</strong> 命令</p>\n<p>可以参考 <a href=\"http://man.linuxde.net/curl\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p>一些参考：</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">HTTP-维基百科</a></p>\n<p><a href=\"http://man.linuxde.net/curl\" target=\"_blank\" rel=\"noopener\">curl 命令</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-HTTP\"><a href=\"#什么是-HTTP\" class=\"headerlink\" title=\"什么是 HTTP\"></a><strong>什么是 HTTP</strong></h1><p><strong>HTTP（HyperText Transfer Protocol）</strong>超文本传输协议  <a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<p><strong>HTTP 的作用就是指导浏览器和服务器如何进行沟通</strong></p>\n<p><strong>Client （浏览器）→ HTTP（请求）→Server（80 端口）→HTTP 响应 →Client（浏览器）</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-e2b8fabd058d2313.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"HTTP请求与响应\"></p>\n<p>浏览器负责发起请求</p>\n<p>服务器在 80 端口接收请求</p>\n<p>服务器负责返回内容（响应）</p>\n<p>浏览器负责下载响应内容</p>\n<hr>\n<h1 id=\"HTTP-请求\"><a href=\"#HTTP-请求\" class=\"headerlink\" title=\"HTTP 请求\"></a><strong>HTTP 请求</strong></h1><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-3255f775c068ece3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"请求的格式\"></p>\n<p>请求最多包含四部分（图中 1、2、3、4），最少包含三部分。（也就是说第四部分可以为空）</p>\n<p>第三部分永远都是一个回车（\\n）</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">动词</a>有 GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS 等</p>\n<p>这里的路径包括「查询参数」，但不包括「锚点」</p>\n<p>如果你没有写路径，那么路径默认为 /</p>\n<p>第 2 部分中的 Content-Type 标注了第 4 部分的格式</p>\n<h1 id=\"用-Chrome-发请求\"><a href=\"#用-Chrome-发请求\" class=\"headerlink\" title=\"用 Chrome 发请求\"></a><strong>用 Chrome 发请求</strong></h1><p>打开 Network（F12）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-ac46ff3c447bfe4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>地址栏输入网址，如 <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a></p>\n<p>在 Network 点击，查看 request，点击「view source」</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a26b808214a7f891.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>可以看到请求的前三部分了</p>\n<p>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</p>\n<hr>\n<h1 id=\"HTTP-响应\"><a href=\"#HTTP-响应\" class=\"headerlink\" title=\"HTTP 响应\"></a><strong>HTTP 响应</strong></h1><p>请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-0a2a709c31b4f71e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"响应的格式\"></p>\n<p>状态码是服务器对浏览器说的话</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF\" target=\"_blank\" rel=\"noopener\">1xx 消息</a>——请求已被服务器接收，继续处理</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx%E6%88%90%E5%8A%9F\" target=\"_blank\" rel=\"noopener\">2xx 成功</a>——请求已成功被服务器接收、理解、并接受</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx%E9%87%8D%E5%AE%9A%E5%90%91\" target=\"_blank\" rel=\"noopener\">3xx 重定向</a>——需要后续操作才能完成这一请求</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF\" target=\"_blank\" rel=\"noopener\">4xx 请求错误</a>——请求含有词法错误或者无法被执行</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF\" target=\"_blank\" rel=\"noopener\">5xx 服务器错误</a>——服务器在处理某个正确请求时发生错误</p>\n<p>状态解释没什么用</p>\n<p>第 2 部分中的 Content-Type 标注了第 4 部分的格式</p>\n<p>第 2 部分中的 Content-Type 遵循 MIME 规范</p>\n<h1 id=\"用-Chrome-查看响应\"><a href=\"#用-Chrome-查看响应\" class=\"headerlink\" title=\"用 Chrome 查看响应\"></a><strong>用 Chrome 查看响应</strong></h1><p>打开 Network</p>\n<p>输入网址</p>\n<p>选中第一个响应</p>\n<p>查看 Response Headers，点击「view source」</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-c1ef5f68fe12bac5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你会看到响应的前两部分</p>\n<p>查看 Response 或者 Preview，你会看到响应的第 4 部分</p>\n<hr>\n<p><strong>也可以用命令行发请求并得到响应</strong></p>\n<p>用到<strong>curl</strong>命令，具体可以命令行<a href=\"https://explainshell.com/\" target=\"_blank\" rel=\"noopener\">释义</a>（命令行及命令行释义可以看我相关<a href=\"https://www.jianshu.com/p/dcf636cbe6af\" target=\"_blank\" rel=\"noopener\">blog</a>）</p>\n<p>如：<strong>curl -s -v -H  – “<a href=\"https://www.baidu.com&quot;\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com&quot;</a></strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-fb73225d2f20d079.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>请求的内容为</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; GET / HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Host: www.baidu.com</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; User-Agent: curl/7.59.0</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Accept: */*</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">**响应的内容为**</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Accept-Ranges: bytes</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Connection: Keep-Alive</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Content-Length: 2443</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Content-Type: text/html</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Date: Thu, 07 Jun 2018 13:54:43 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Etag: &quot;58860411-98b&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Last-Modified: Mon, 23 Jan 2017 13:24:33 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Pragma: no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">* Server bfe/1.0.8.18 is not blacklisted</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Server: bfe/1.0.8.18</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;</span><br></pre></td></tr></table></figure>\n<p>还有很多可以尝试的 <strong>curl</strong> 命令</p>\n<p>可以参考 <a href=\"http://man.linuxde.net/curl\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<hr>\n<p>本文主要用于个人学习使用，如有侵权请联系我删除。</p>\n<p>一些参考：</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">HTTP-维基百科</a></p>\n<p><a href=\"http://man.linuxde.net/curl\" target=\"_blank\" rel=\"noopener\">curl 命令</a></p>\n"},{"title":"理解 JSONP 上","date":"2018-08-10T16:06:05.000Z","_content":"\n# 我们用 node 来做一个简易服务器理解 JSONP，从而了解在没有 Ajax 的时代的前端是如何绞尽脑汁做好页面交互的\n\n有关 node 搭建服务器的学习可以参考我的[另一篇博客](https://www.jianshu.com/p/ba728fb4edb4)\n**node 服务器及页面完整代码 [参考](https://github.com/Adashuai5/node-demo/tree/master/JSONP-demo)**\n\n**首先做一个简单的付款界面**\n点击按钮数字减 1（点击按钮金额每次减少 1）\n\n```\n<h5>您的余额是\n    <span id=\"amount\">100</span>\n</h5>\n<button id=\"button\">付款一块钱</button>\n<script>\n    button.addEventListener('click', (e) => {\n        let n = amount.innerText\n        let number = parseInt(n, 10)\n        let newNumber = number - 1\n        amount.innerText = newNumber\n    })\n</script>\n```\n\nNode 代码：\n\n```\nif(path == '/'){\n    var string = fs.readFileSync('./index.html','utf8')\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write(string)\n    response.end()\n  }else{\n    response.statusCode = 404\n    response.end()\n  }\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a1ec91f18d1456c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方法没有后台数据，刷新页面就恢复 100\n**\\*数据库**是什么鬼\n**只要能长久地存数据，就是数据库** 1.文件系统是一种数据库\n2.MySQL 是一种数据库\\*\n\n**那我们给它一个数据库来存储金额呗（命令行操作）**\n\n```\n//创建一个名为db的文件作为数据库\ntouch db\n//用 vim 打开 db\nvi db\n//只写入100\ni 100 :wq\n```\n\n用&&&amount&&&替代 html 里的 100（这什么意思？没什么意思，不容易重复啊）这时前端就可以不管后端数据库里的具体内容了\n\n```\n<h5>您的余额是\n    <span id=\"amount\">&&&amount&&&</span>\n</h5>\n<button id=\"button\">付款一块钱</button>\n<form action=\"/pay\" method=\"POST\">\n    <input type=\"text\" name=\"number\" value=\"1\">\n    <input type=\"submit\" value=\"付款\">\n</form>\n```\n\n```\nvar string = fs.readFileSync('./index.html','utf8')\n//引入db，赋值给变量amout，文件都是字符串类型，所以amount得到的是一个字符串\n    var amount = fs.readFileSync('./db','utf8')\n//将html里的那个占位符，替换为db里的内容\n    string = string.replace('&&&amount&&&',amount)\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write(string)\n    response.end()\n```\n\nNode 代码\n\n```\n//判断路径和post请求\nif (path === '/pay' && method.toUpperCase() === 'POST') {\n  //引入db这个文件\n  var amount = fs.readFileSync('./db', 'utf8')\n  //每提交一次db里面的数字就减去1\n  var newAmount = amount - 1\n  //模拟失败，如果产生的随机数大于0.5就成功\n  if (Math.random() > 0.5) {\n    //成功后将db文件里写入新的数值\n    fs.writeFileSync('./db', newAmount)\n    response.write('success')\n  } else {\n    response.write('fail')\n  }\n  response.end()\n}\n```\n\n这种方法，由于有了后台数据库（db 文件）就能每次得到的新的数值都会存在里面，即使页面刷新也不会变，缺点：需要返回上一个页面才能看到现在的数值\n原因是：form 表单提交后一定会刷新当前页面，并且会打开一个新的页面\n\n### 想要不刷新当前页面的方法：\n\n**经典：用 iframe**\n\n```\n<form action=\"/pay\" method=\"POST\" target=\"result\">\n    <input type=\"submit\" value=\"付款\">\n</form>\n<iframe name=\"result\" src=\"about:blank\" frameborder=\"0\" height=\"200\"></iframe>\n```\n\n这样做的好处是用户可以直接通过 iframe 看到是否付款成功，提升用户体验\n![](https://upload-images.jianshu.io/upload_images/7094266-4bc794416aa7fcaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**能不能不用 iframe？** 1.用图片造 get 请求\n\n```\n<h5>您的余额是<span id=\"amount\">&&&amount&&&</span></h5>\n<button id=\"button\">打钱</button>\n<script>\nbutton.addEventListener('click',(e)=>{\n  let image = document.createElement('img')\n  //指定路径\n  image.src = '/pay'\n  //image加载成功后执行\n  image.onload= function(){\n    alert('打钱成功')\n    //Window.location.reload() 是刷新页面，更好的方法是直接减一\n    amount.innerText = amount.innerText-1;\n  }\n  //image加载失败后执行\n  image.onerror = function(){\n    alert('打钱失败')\n  }\n})\n</script>\n```\n\nNode 代码:\n\n```\n//因为imgae只能是get请求，所以只需判断路径\nif(path==='/pay'){\n  var amount = fs.readFileSync('./db','utf8')\n  var newAmount = amount-1\n  if(Math.random()>0.5){\n    fs.writeFileSync('./db',newAmount)\n    response.setHeader('Content-Type','image/jpg')\n    //返回图片，状态码 200 成功\n    response.statusCode = 200\n    //需要真的传一张图片才能成功\n    response.write(fs.readFileSync('./dog.jpg'))\n }else{\n    //状态码 400 页面显示失败\n    response.statusCode = 400\n    response.write('fail')\n }\n response.end()\n}\n\n```\n\n点击打钱按钮，若随机数大于 0.5，则状态码显示 200.并且返回 dog.jpg，alert 打钱成功，点击确定，余额自动减一且页面不刷新。\n![](https://upload-images.jianshu.io/upload_images/7094266-8f026f51f1be16ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n缺点是这种办法不支持 post 请求，只能是 get 请求\n\n2.用 script 造 get 请求\n\n```\n<h5>您的余额是\n  <span id=\"amount\">&&&amount&&&</span>\n</h5>\n<button id=\"button\">打钱</button>\n<script>\n  button.addEventListener('click', (e) => {\n    let script = document.createElement('script')\n    script.src = '/pay'\n    //一定要把script放入body中，才有效\n    document.body.appendChild(script)\n  // script.onload= function(){\n  //   alert('打钱成功')\n  //   amount.innerText = amount.innerText-1\n  // }\n  script.onerror = function () {\n    alert('打钱失败')\n  }\n})\n</script>\n```\n\nNode 代码：\n\n```\nif (path === '/pay') {\n    var amount = fs.readFileSync('./db', 'utf8')\n    var newAmount = amount - 1\n    if (Math.random() > 0.5) {\n      fs.writeFileSync('./db', newAmount)\n      response.setHeader('Content-Type','application/javascript')\n      response.statusCode = 200\n      //直接在 response 里 返回cuccess并且减一\n      response.write(`alert(\"success\")\n      amount.innerText = amount.innerText-1`)\n    } else {\n      response.statusCode = 400\n      response.write('fail')\n    }\n    response.end()\n```\n\nScript 请求需要放入页面中才有效，由于本身 script 会给页面添加效果，那何必用 onload ，直接在 node 端写代码。\n这种技术叫做 **SRJ （Server rendered javascript）**：服务器返回 javascript ，AJAX 出现前的无刷新更新页面内容的方案。\n![](https://upload-images.jianshu.io/upload_images/7094266-b0040fe7c5d83bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这样已经达到和第一种方法 img 一样的效果，而且不用返回图片\n一直给页面添加 Script 也不好，如何去除？用下面方法无论成功还是失败，script 标签均去掉\n\n```\nscript.onload= function(e){\n    e.currentTarget.remove()\n  }\n  script.onerror = function () {\n    alert('打钱失败')\n    e.currentTarget.remove()\n  }\n```\n\n---\n\n本文主要用于个人学习使用\n[理解 JSONP 下](https://www.jianshu.com/p/38a72bd0e37d)\n","source":"_posts/理解JSONP-上.md","raw":"---\ntitle: 理解 JSONP 上\ndate: 2018-08-11 00:06:05\ntags: HTTP\n---\n\n# 我们用 node 来做一个简易服务器理解 JSONP，从而了解在没有 Ajax 的时代的前端是如何绞尽脑汁做好页面交互的\n\n有关 node 搭建服务器的学习可以参考我的[另一篇博客](https://www.jianshu.com/p/ba728fb4edb4)\n**node 服务器及页面完整代码 [参考](https://github.com/Adashuai5/node-demo/tree/master/JSONP-demo)**\n\n**首先做一个简单的付款界面**\n点击按钮数字减 1（点击按钮金额每次减少 1）\n\n```\n<h5>您的余额是\n    <span id=\"amount\">100</span>\n</h5>\n<button id=\"button\">付款一块钱</button>\n<script>\n    button.addEventListener('click', (e) => {\n        let n = amount.innerText\n        let number = parseInt(n, 10)\n        let newNumber = number - 1\n        amount.innerText = newNumber\n    })\n</script>\n```\n\nNode 代码：\n\n```\nif(path == '/'){\n    var string = fs.readFileSync('./index.html','utf8')\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write(string)\n    response.end()\n  }else{\n    response.statusCode = 404\n    response.end()\n  }\n```\n\n![](https://upload-images.jianshu.io/upload_images/7094266-a1ec91f18d1456c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方法没有后台数据，刷新页面就恢复 100\n**\\*数据库**是什么鬼\n**只要能长久地存数据，就是数据库** 1.文件系统是一种数据库\n2.MySQL 是一种数据库\\*\n\n**那我们给它一个数据库来存储金额呗（命令行操作）**\n\n```\n//创建一个名为db的文件作为数据库\ntouch db\n//用 vim 打开 db\nvi db\n//只写入100\ni 100 :wq\n```\n\n用&&&amount&&&替代 html 里的 100（这什么意思？没什么意思，不容易重复啊）这时前端就可以不管后端数据库里的具体内容了\n\n```\n<h5>您的余额是\n    <span id=\"amount\">&&&amount&&&</span>\n</h5>\n<button id=\"button\">付款一块钱</button>\n<form action=\"/pay\" method=\"POST\">\n    <input type=\"text\" name=\"number\" value=\"1\">\n    <input type=\"submit\" value=\"付款\">\n</form>\n```\n\n```\nvar string = fs.readFileSync('./index.html','utf8')\n//引入db，赋值给变量amout，文件都是字符串类型，所以amount得到的是一个字符串\n    var amount = fs.readFileSync('./db','utf8')\n//将html里的那个占位符，替换为db里的内容\n    string = string.replace('&&&amount&&&',amount)\n    response.setHeader('Content-Type', 'text/html; charset=utf-8')\n    response.write(string)\n    response.end()\n```\n\nNode 代码\n\n```\n//判断路径和post请求\nif (path === '/pay' && method.toUpperCase() === 'POST') {\n  //引入db这个文件\n  var amount = fs.readFileSync('./db', 'utf8')\n  //每提交一次db里面的数字就减去1\n  var newAmount = amount - 1\n  //模拟失败，如果产生的随机数大于0.5就成功\n  if (Math.random() > 0.5) {\n    //成功后将db文件里写入新的数值\n    fs.writeFileSync('./db', newAmount)\n    response.write('success')\n  } else {\n    response.write('fail')\n  }\n  response.end()\n}\n```\n\n这种方法，由于有了后台数据库（db 文件）就能每次得到的新的数值都会存在里面，即使页面刷新也不会变，缺点：需要返回上一个页面才能看到现在的数值\n原因是：form 表单提交后一定会刷新当前页面，并且会打开一个新的页面\n\n### 想要不刷新当前页面的方法：\n\n**经典：用 iframe**\n\n```\n<form action=\"/pay\" method=\"POST\" target=\"result\">\n    <input type=\"submit\" value=\"付款\">\n</form>\n<iframe name=\"result\" src=\"about:blank\" frameborder=\"0\" height=\"200\"></iframe>\n```\n\n这样做的好处是用户可以直接通过 iframe 看到是否付款成功，提升用户体验\n![](https://upload-images.jianshu.io/upload_images/7094266-4bc794416aa7fcaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**能不能不用 iframe？** 1.用图片造 get 请求\n\n```\n<h5>您的余额是<span id=\"amount\">&&&amount&&&</span></h5>\n<button id=\"button\">打钱</button>\n<script>\nbutton.addEventListener('click',(e)=>{\n  let image = document.createElement('img')\n  //指定路径\n  image.src = '/pay'\n  //image加载成功后执行\n  image.onload= function(){\n    alert('打钱成功')\n    //Window.location.reload() 是刷新页面，更好的方法是直接减一\n    amount.innerText = amount.innerText-1;\n  }\n  //image加载失败后执行\n  image.onerror = function(){\n    alert('打钱失败')\n  }\n})\n</script>\n```\n\nNode 代码:\n\n```\n//因为imgae只能是get请求，所以只需判断路径\nif(path==='/pay'){\n  var amount = fs.readFileSync('./db','utf8')\n  var newAmount = amount-1\n  if(Math.random()>0.5){\n    fs.writeFileSync('./db',newAmount)\n    response.setHeader('Content-Type','image/jpg')\n    //返回图片，状态码 200 成功\n    response.statusCode = 200\n    //需要真的传一张图片才能成功\n    response.write(fs.readFileSync('./dog.jpg'))\n }else{\n    //状态码 400 页面显示失败\n    response.statusCode = 400\n    response.write('fail')\n }\n response.end()\n}\n\n```\n\n点击打钱按钮，若随机数大于 0.5，则状态码显示 200.并且返回 dog.jpg，alert 打钱成功，点击确定，余额自动减一且页面不刷新。\n![](https://upload-images.jianshu.io/upload_images/7094266-8f026f51f1be16ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n缺点是这种办法不支持 post 请求，只能是 get 请求\n\n2.用 script 造 get 请求\n\n```\n<h5>您的余额是\n  <span id=\"amount\">&&&amount&&&</span>\n</h5>\n<button id=\"button\">打钱</button>\n<script>\n  button.addEventListener('click', (e) => {\n    let script = document.createElement('script')\n    script.src = '/pay'\n    //一定要把script放入body中，才有效\n    document.body.appendChild(script)\n  // script.onload= function(){\n  //   alert('打钱成功')\n  //   amount.innerText = amount.innerText-1\n  // }\n  script.onerror = function () {\n    alert('打钱失败')\n  }\n})\n</script>\n```\n\nNode 代码：\n\n```\nif (path === '/pay') {\n    var amount = fs.readFileSync('./db', 'utf8')\n    var newAmount = amount - 1\n    if (Math.random() > 0.5) {\n      fs.writeFileSync('./db', newAmount)\n      response.setHeader('Content-Type','application/javascript')\n      response.statusCode = 200\n      //直接在 response 里 返回cuccess并且减一\n      response.write(`alert(\"success\")\n      amount.innerText = amount.innerText-1`)\n    } else {\n      response.statusCode = 400\n      response.write('fail')\n    }\n    response.end()\n```\n\nScript 请求需要放入页面中才有效，由于本身 script 会给页面添加效果，那何必用 onload ，直接在 node 端写代码。\n这种技术叫做 **SRJ （Server rendered javascript）**：服务器返回 javascript ，AJAX 出现前的无刷新更新页面内容的方案。\n![](https://upload-images.jianshu.io/upload_images/7094266-b0040fe7c5d83bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这样已经达到和第一种方法 img 一样的效果，而且不用返回图片\n一直给页面添加 Script 也不好，如何去除？用下面方法无论成功还是失败，script 标签均去掉\n\n```\nscript.onload= function(e){\n    e.currentTarget.remove()\n  }\n  script.onerror = function () {\n    alert('打钱失败')\n    e.currentTarget.remove()\n  }\n```\n\n---\n\n本文主要用于个人学习使用\n[理解 JSONP 下](https://www.jianshu.com/p/38a72bd0e37d)\n","slug":"理解JSONP-上","published":1,"updated":"2020-03-28T17:28:14.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswza000wws99inbk7tjg","content":"<h1 id=\"我们用-node-来做一个简易服务器理解-JSONP，从而了解在没有-Ajax-的时代的前端是如何绞尽脑汁做好页面交互的\"><a href=\"#我们用-node-来做一个简易服务器理解-JSONP，从而了解在没有-Ajax-的时代的前端是如何绞尽脑汁做好页面交互的\" class=\"headerlink\" title=\"我们用 node 来做一个简易服务器理解 JSONP，从而了解在没有 Ajax 的时代的前端是如何绞尽脑汁做好页面交互的\"></a>我们用 node 来做一个简易服务器理解 JSONP，从而了解在没有 Ajax 的时代的前端是如何绞尽脑汁做好页面交互的</h1><p>有关 node 搭建服务器的学习可以参考我的<a href=\"https://www.jianshu.com/p/ba728fb4edb4\" target=\"_blank\" rel=\"noopener\">另一篇博客</a><br><strong>node 服务器及页面完整代码 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/JSONP-demo\">参考</a></strong></p>\n<p><strong>首先做一个简单的付款界面</strong><br>点击按钮数字减 1（点击按钮金额每次减少 1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是</span><br><span class=\"line\">    &lt;span id=&quot;amount&quot;&gt;100&lt;/span&gt;</span><br><span class=\"line\">&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;付款一块钱&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    button.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">        let n = amount.innerText</span><br><span class=\"line\">        let number = parseInt(n, 10)</span><br><span class=\"line\">        let newNumber = number - 1</span><br><span class=\"line\">        amount.innerText = newNumber</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(path == &apos;/&apos;)&#123;</span><br><span class=\"line\">    var string = fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    response.statusCode = 404</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a1ec91f18d1456c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这种方法没有后台数据，刷新页面就恢复 100<br><strong>*数据库</strong>是什么鬼<br><strong>只要能长久地存数据，就是数据库</strong> 1.文件系统是一种数据库<br>2.MySQL 是一种数据库*</p>\n<p><strong>那我们给它一个数据库来存储金额呗（命令行操作）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个名为db的文件作为数据库</span><br><span class=\"line\">touch db</span><br><span class=\"line\">//用 vim 打开 db</span><br><span class=\"line\">vi db</span><br><span class=\"line\">//只写入100</span><br><span class=\"line\">i 100 :wq</span><br></pre></td></tr></table></figure>\n<p>用&amp;&amp;&amp;amount&amp;&amp;&amp;替代 html 里的 100（这什么意思？没什么意思，不容易重复啊）这时前端就可以不管后端数据库里的具体内容了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是</span><br><span class=\"line\">    &lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;</span><br><span class=\"line\">&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;付款一块钱&lt;/button&gt;</span><br><span class=\"line\">&lt;form action=&quot;/pay&quot; method=&quot;POST&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; name=&quot;number&quot; value=&quot;1&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;付款&quot;&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var string = fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">//引入db，赋值给变量amout，文件都是字符串类型，所以amount得到的是一个字符串</span><br><span class=\"line\">    var amount = fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">//将html里的那个占位符，替换为db里的内容</span><br><span class=\"line\">    string = string.replace(&apos;&amp;&amp;&amp;amount&amp;&amp;&amp;&apos;,amount)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>Node 代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//判断路径和post请求</span><br><span class=\"line\">if (path === &apos;/pay&apos; &amp;&amp; method.toUpperCase() === &apos;POST&apos;) &#123;</span><br><span class=\"line\">  //引入db这个文件</span><br><span class=\"line\">  var amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">  //每提交一次db里面的数字就减去1</span><br><span class=\"line\">  var newAmount = amount - 1</span><br><span class=\"line\">  //模拟失败，如果产生的随机数大于0.5就成功</span><br><span class=\"line\">  if (Math.random() &gt; 0.5) &#123;</span><br><span class=\"line\">    //成功后将db文件里写入新的数值</span><br><span class=\"line\">    fs.writeFileSync(&apos;./db&apos;, newAmount)</span><br><span class=\"line\">    response.write(&apos;success&apos;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    response.write(&apos;fail&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法，由于有了后台数据库（db 文件）就能每次得到的新的数值都会存在里面，即使页面刷新也不会变，缺点：需要返回上一个页面才能看到现在的数值<br>原因是：form 表单提交后一定会刷新当前页面，并且会打开一个新的页面</p>\n<h3 id=\"想要不刷新当前页面的方法：\"><a href=\"#想要不刷新当前页面的方法：\" class=\"headerlink\" title=\"想要不刷新当前页面的方法：\"></a>想要不刷新当前页面的方法：</h3><p><strong>经典：用 iframe</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/pay&quot; method=&quot;POST&quot; target=&quot;result&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;付款&quot;&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">&lt;iframe name=&quot;result&quot; src=&quot;about:blank&quot; frameborder=&quot;0&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处是用户可以直接通过 iframe 看到是否付款成功，提升用户体验<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4bc794416aa7fcaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>能不能不用 iframe？</strong> 1.用图片造 get 请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是&lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;打钱&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">button.addEventListener(&apos;click&apos;,(e)=&gt;&#123;</span><br><span class=\"line\">  let image = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">  //指定路径</span><br><span class=\"line\">  image.src = &apos;/pay&apos;</span><br><span class=\"line\">  //image加载成功后执行</span><br><span class=\"line\">  image.onload= function()&#123;</span><br><span class=\"line\">    alert(&apos;打钱成功&apos;)</span><br><span class=\"line\">    //Window.location.reload() 是刷新页面，更好的方法是直接减一</span><br><span class=\"line\">    amount.innerText = amount.innerText-1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //image加载失败后执行</span><br><span class=\"line\">  image.onerror = function()&#123;</span><br><span class=\"line\">    alert(&apos;打钱失败&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//因为imgae只能是get请求，所以只需判断路径</span><br><span class=\"line\">if(path===&apos;/pay&apos;)&#123;</span><br><span class=\"line\">  var amount = fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">  var newAmount = amount-1</span><br><span class=\"line\">  if(Math.random()&gt;0.5)&#123;</span><br><span class=\"line\">    fs.writeFileSync(&apos;./db&apos;,newAmount)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;,&apos;image/jpg&apos;)</span><br><span class=\"line\">    //返回图片，状态码 200 成功</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    //需要真的传一张图片才能成功</span><br><span class=\"line\">    response.write(fs.readFileSync(&apos;./dog.jpg&apos;))</span><br><span class=\"line\"> &#125;else&#123;</span><br><span class=\"line\">    //状态码 400 页面显示失败</span><br><span class=\"line\">    response.statusCode = 400</span><br><span class=\"line\">    response.write(&apos;fail&apos;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点击打钱按钮，若随机数大于 0.5，则状态码显示 200.并且返回 dog.jpg，alert 打钱成功，点击确定，余额自动减一且页面不刷新。<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8f026f51f1be16ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>缺点是这种办法不支持 post 请求，只能是 get 请求</p>\n<p>2.用 script 造 get 请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是</span><br><span class=\"line\">  &lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;</span><br><span class=\"line\">&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;打钱&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  button.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let script = document.createElement(&apos;script&apos;)</span><br><span class=\"line\">    script.src = &apos;/pay&apos;</span><br><span class=\"line\">    //一定要把script放入body中，才有效</span><br><span class=\"line\">    document.body.appendChild(script)</span><br><span class=\"line\">  // script.onload= function()&#123;</span><br><span class=\"line\">  //   alert(&apos;打钱成功&apos;)</span><br><span class=\"line\">  //   amount.innerText = amount.innerText-1</span><br><span class=\"line\">  // &#125;</span><br><span class=\"line\">  script.onerror = function () &#123;</span><br><span class=\"line\">    alert(&apos;打钱失败&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (path === &apos;/pay&apos;) &#123;</span><br><span class=\"line\">    var amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    var newAmount = amount - 1</span><br><span class=\"line\">    if (Math.random() &gt; 0.5) &#123;</span><br><span class=\"line\">      fs.writeFileSync(&apos;./db&apos;, newAmount)</span><br><span class=\"line\">      response.setHeader(&apos;Content-Type&apos;,&apos;application/javascript&apos;)</span><br><span class=\"line\">      response.statusCode = 200</span><br><span class=\"line\">      //直接在 response 里 返回cuccess并且减一</span><br><span class=\"line\">      response.write(`alert(&quot;success&quot;)</span><br><span class=\"line\">      amount.innerText = amount.innerText-1`)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      response.statusCode = 400</span><br><span class=\"line\">      response.write(&apos;fail&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>Script 请求需要放入页面中才有效，由于本身 script 会给页面添加效果，那何必用 onload ，直接在 node 端写代码。<br>这种技术叫做 <strong>SRJ （Server rendered javascript）</strong>：服务器返回 javascript ，AJAX 出现前的无刷新更新页面内容的方案。<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-b0040fe7c5d83bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">这样已经达到和第一种方法 img 一样的效果，而且不用返回图片<br>一直给页面添加 Script 也不好，如何去除？用下面方法无论成功还是失败，script 标签均去掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script.onload= function(e)&#123;</span><br><span class=\"line\">    e.currentTarget.remove()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  script.onerror = function () &#123;</span><br><span class=\"line\">    alert(&apos;打钱失败&apos;)</span><br><span class=\"line\">    e.currentTarget.remove()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>本文主要用于个人学习使用<br><a href=\"https://www.jianshu.com/p/38a72bd0e37d\" target=\"_blank\" rel=\"noopener\">理解 JSONP 下</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我们用-node-来做一个简易服务器理解-JSONP，从而了解在没有-Ajax-的时代的前端是如何绞尽脑汁做好页面交互的\"><a href=\"#我们用-node-来做一个简易服务器理解-JSONP，从而了解在没有-Ajax-的时代的前端是如何绞尽脑汁做好页面交互的\" class=\"headerlink\" title=\"我们用 node 来做一个简易服务器理解 JSONP，从而了解在没有 Ajax 的时代的前端是如何绞尽脑汁做好页面交互的\"></a>我们用 node 来做一个简易服务器理解 JSONP，从而了解在没有 Ajax 的时代的前端是如何绞尽脑汁做好页面交互的</h1><p>有关 node 搭建服务器的学习可以参考我的<a href=\"https://www.jianshu.com/p/ba728fb4edb4\" target=\"_blank\" rel=\"noopener\">另一篇博客</a><br><strong>node 服务器及页面完整代码 <a href=\"https://github.com/Adashuai5/node-demo/tree/master/JSONP-demo\">参考</a></strong></p>\n<p><strong>首先做一个简单的付款界面</strong><br>点击按钮数字减 1（点击按钮金额每次减少 1）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是</span><br><span class=\"line\">    &lt;span id=&quot;amount&quot;&gt;100&lt;/span&gt;</span><br><span class=\"line\">&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;付款一块钱&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    button.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">        let n = amount.innerText</span><br><span class=\"line\">        let number = parseInt(n, 10)</span><br><span class=\"line\">        let newNumber = number - 1</span><br><span class=\"line\">        amount.innerText = newNumber</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(path == &apos;/&apos;)&#123;</span><br><span class=\"line\">    var string = fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    response.statusCode = 404</span><br><span class=\"line\">    response.end()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-a1ec91f18d1456c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这种方法没有后台数据，刷新页面就恢复 100<br><strong>*数据库</strong>是什么鬼<br><strong>只要能长久地存数据，就是数据库</strong> 1.文件系统是一种数据库<br>2.MySQL 是一种数据库*</p>\n<p><strong>那我们给它一个数据库来存储金额呗（命令行操作）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个名为db的文件作为数据库</span><br><span class=\"line\">touch db</span><br><span class=\"line\">//用 vim 打开 db</span><br><span class=\"line\">vi db</span><br><span class=\"line\">//只写入100</span><br><span class=\"line\">i 100 :wq</span><br></pre></td></tr></table></figure>\n<p>用&amp;&amp;&amp;amount&amp;&amp;&amp;替代 html 里的 100（这什么意思？没什么意思，不容易重复啊）这时前端就可以不管后端数据库里的具体内容了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是</span><br><span class=\"line\">    &lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;</span><br><span class=\"line\">&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;付款一块钱&lt;/button&gt;</span><br><span class=\"line\">&lt;form action=&quot;/pay&quot; method=&quot;POST&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; name=&quot;number&quot; value=&quot;1&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;付款&quot;&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var string = fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">//引入db，赋值给变量amout，文件都是字符串类型，所以amount得到的是一个字符串</span><br><span class=\"line\">    var amount = fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">//将html里的那个占位符，替换为db里的内容</span><br><span class=\"line\">    string = string.replace(&apos;&amp;&amp;&amp;amount&amp;&amp;&amp;&apos;,amount)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class=\"line\">    response.write(string)</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>Node 代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//判断路径和post请求</span><br><span class=\"line\">if (path === &apos;/pay&apos; &amp;&amp; method.toUpperCase() === &apos;POST&apos;) &#123;</span><br><span class=\"line\">  //引入db这个文件</span><br><span class=\"line\">  var amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">  //每提交一次db里面的数字就减去1</span><br><span class=\"line\">  var newAmount = amount - 1</span><br><span class=\"line\">  //模拟失败，如果产生的随机数大于0.5就成功</span><br><span class=\"line\">  if (Math.random() &gt; 0.5) &#123;</span><br><span class=\"line\">    //成功后将db文件里写入新的数值</span><br><span class=\"line\">    fs.writeFileSync(&apos;./db&apos;, newAmount)</span><br><span class=\"line\">    response.write(&apos;success&apos;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    response.write(&apos;fail&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法，由于有了后台数据库（db 文件）就能每次得到的新的数值都会存在里面，即使页面刷新也不会变，缺点：需要返回上一个页面才能看到现在的数值<br>原因是：form 表单提交后一定会刷新当前页面，并且会打开一个新的页面</p>\n<h3 id=\"想要不刷新当前页面的方法：\"><a href=\"#想要不刷新当前页面的方法：\" class=\"headerlink\" title=\"想要不刷新当前页面的方法：\"></a>想要不刷新当前页面的方法：</h3><p><strong>经典：用 iframe</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/pay&quot; method=&quot;POST&quot; target=&quot;result&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;付款&quot;&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">&lt;iframe name=&quot;result&quot; src=&quot;about:blank&quot; frameborder=&quot;0&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处是用户可以直接通过 iframe 看到是否付款成功，提升用户体验<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-4bc794416aa7fcaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>能不能不用 iframe？</strong> 1.用图片造 get 请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是&lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;打钱&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">button.addEventListener(&apos;click&apos;,(e)=&gt;&#123;</span><br><span class=\"line\">  let image = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">  //指定路径</span><br><span class=\"line\">  image.src = &apos;/pay&apos;</span><br><span class=\"line\">  //image加载成功后执行</span><br><span class=\"line\">  image.onload= function()&#123;</span><br><span class=\"line\">    alert(&apos;打钱成功&apos;)</span><br><span class=\"line\">    //Window.location.reload() 是刷新页面，更好的方法是直接减一</span><br><span class=\"line\">    amount.innerText = amount.innerText-1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //image加载失败后执行</span><br><span class=\"line\">  image.onerror = function()&#123;</span><br><span class=\"line\">    alert(&apos;打钱失败&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//因为imgae只能是get请求，所以只需判断路径</span><br><span class=\"line\">if(path===&apos;/pay&apos;)&#123;</span><br><span class=\"line\">  var amount = fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)</span><br><span class=\"line\">  var newAmount = amount-1</span><br><span class=\"line\">  if(Math.random()&gt;0.5)&#123;</span><br><span class=\"line\">    fs.writeFileSync(&apos;./db&apos;,newAmount)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;,&apos;image/jpg&apos;)</span><br><span class=\"line\">    //返回图片，状态码 200 成功</span><br><span class=\"line\">    response.statusCode = 200</span><br><span class=\"line\">    //需要真的传一张图片才能成功</span><br><span class=\"line\">    response.write(fs.readFileSync(&apos;./dog.jpg&apos;))</span><br><span class=\"line\"> &#125;else&#123;</span><br><span class=\"line\">    //状态码 400 页面显示失败</span><br><span class=\"line\">    response.statusCode = 400</span><br><span class=\"line\">    response.write(&apos;fail&apos;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> response.end()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点击打钱按钮，若随机数大于 0.5，则状态码显示 200.并且返回 dog.jpg，alert 打钱成功，点击确定，余额自动减一且页面不刷新。<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-8f026f51f1be16ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>缺点是这种办法不支持 post 请求，只能是 get 请求</p>\n<p>2.用 script 造 get 请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h5&gt;您的余额是</span><br><span class=\"line\">  &lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;</span><br><span class=\"line\">&lt;/h5&gt;</span><br><span class=\"line\">&lt;button id=&quot;button&quot;&gt;打钱&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  button.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class=\"line\">    let script = document.createElement(&apos;script&apos;)</span><br><span class=\"line\">    script.src = &apos;/pay&apos;</span><br><span class=\"line\">    //一定要把script放入body中，才有效</span><br><span class=\"line\">    document.body.appendChild(script)</span><br><span class=\"line\">  // script.onload= function()&#123;</span><br><span class=\"line\">  //   alert(&apos;打钱成功&apos;)</span><br><span class=\"line\">  //   amount.innerText = amount.innerText-1</span><br><span class=\"line\">  // &#125;</span><br><span class=\"line\">  script.onerror = function () &#123;</span><br><span class=\"line\">    alert(&apos;打钱失败&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Node 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (path === &apos;/pay&apos;) &#123;</span><br><span class=\"line\">    var amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    var newAmount = amount - 1</span><br><span class=\"line\">    if (Math.random() &gt; 0.5) &#123;</span><br><span class=\"line\">      fs.writeFileSync(&apos;./db&apos;, newAmount)</span><br><span class=\"line\">      response.setHeader(&apos;Content-Type&apos;,&apos;application/javascript&apos;)</span><br><span class=\"line\">      response.statusCode = 200</span><br><span class=\"line\">      //直接在 response 里 返回cuccess并且减一</span><br><span class=\"line\">      response.write(`alert(&quot;success&quot;)</span><br><span class=\"line\">      amount.innerText = amount.innerText-1`)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      response.statusCode = 400</span><br><span class=\"line\">      response.write(&apos;fail&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>Script 请求需要放入页面中才有效，由于本身 script 会给页面添加效果，那何必用 onload ，直接在 node 端写代码。<br>这种技术叫做 <strong>SRJ （Server rendered javascript）</strong>：服务器返回 javascript ，AJAX 出现前的无刷新更新页面内容的方案。<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-b0040fe7c5d83bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">这样已经达到和第一种方法 img 一样的效果，而且不用返回图片<br>一直给页面添加 Script 也不好，如何去除？用下面方法无论成功还是失败，script 标签均去掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script.onload= function(e)&#123;</span><br><span class=\"line\">    e.currentTarget.remove()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  script.onerror = function () &#123;</span><br><span class=\"line\">    alert(&apos;打钱失败&apos;)</span><br><span class=\"line\">    e.currentTarget.remove()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>本文主要用于个人学习使用<br><a href=\"https://www.jianshu.com/p/38a72bd0e37d\" target=\"_blank\" rel=\"noopener\">理解 JSONP 下</a></p>\n"},{"title":"正则表达式速记","date":"2018-10-28T06:15:51.000Z","_content":"\n# 前言\n\n如何学习：[30 分钟入门正则表达式](https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html)\n[工具](https://www.regexpal.com/)\n本文参（zhao）考（chao）[RegExp 对象](https://wangdoc.com/javascript/stdlib/regexp.html)，该笔记只为速查\n\n# 简介\n\n正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，其体系参照 Perl 5 建立。\n\n# 创建正则表达式的方法\n\n1. 使用一个正则表达式字面量\n\n```\nvar re = /xxx/\n```\n\n2. 调用 RegExp 对象的构造函数\n\n```\nvar re = new RegExp('xxx')\n```\n\n两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。\n\n# 正则表达式的实例属性\n\n分为两类\n\n1. 修饰符（只读）\n   RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了 i 修饰符。用于忽略字符串大小写。\n   RegExp.prototype.global：返回一个布尔值，表示是否设置了 g 修饰符。用于全局匹配。\n   RegExp.prototype.multiline：返回一个布尔值，表示是否设置了 m 修饰符。用于设置匹配为多行模式。\n2. 其他属性\n   RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。\n   RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\n\n# 实例方法\n\n## 1. RegExp.prototype.test()\n\ntest 方法返回布尔值，表示当前模式是否能匹配参数字符串\n\n```\n/a/.test('and') // true\n```\n\n## 2. RegExp.prototype.exec()\n\nexec 方法，用来返回匹配结果\n如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回 null\n\n```\n/a/.exec('adbca')\n```\n\n如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。\n\n```\nString.prototype.match()：返回一个数组，成员是所有匹配的子字符串。\nString.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。\nString.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\nString.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\n```\n\n---\n\n# 字面量字符和元字符\n\n## 元字符\n\n1. 点字符（.)\n   匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n2. 位置字符\n\n```\n^ 表示字符串的开始位置\n$ 表示字符串的结束位置\n```\n\n3. 选择符（|）\n   表示“或关系”\n4. 转义符\n   匹配元字符本身可以在它们前面加反斜杠\n   构造函数需要两次转义\n5. 特殊字符\n\n```\n\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。\n[\\b] 匹配退格键(U+0008)，不要与\\b混淆。\n\\n 匹配换行键。\n\\r 匹配回车键。\n\\t 匹配制表符 tab（U+0009）。\n\\v 匹配垂直制表符（U+000B）。\n\\f 匹配换页符（U+000C）。\n\\0 匹配null字符（U+0000）。\n\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。\n\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。\n```\n\n# 字符类\n\n字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示 x、y、z 之中任选一个匹配。\n\n1. 脱字符（^）：需在字符类第一位\n   表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。\n2. 连字符（-）\n\n```\n[0-9.,]\n[0-9a-fA-F]\n[a-zA-Z0-9-]\n[1-31] // 不代表1到31，只代表1到3\n```\n\n# 预定义模式：某些常见模式的简写方式\n\n```\n\\d 匹配0-9之间的任一数字，相当于[0-9]。\n\\D 匹配所有0-9以外的字符，相当于[^0-9]。\n\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\n\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\n\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。\n\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。\n\\b 匹配词的边界。\n\\B 匹配非词边界，即在词的内部\n```\n\n# 重复类\n\n模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复 n 次，{n,}表示至少重复 n 次，{n,m}表示重复不少于 n 次，不多于 m 次。\n\n# 量词符：设定某个模式出现的次数\n\n```\n? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n* 星号表示某个模式出现0次或多次，等同于{0,}。\n+ 加号表示某个模式出现1次或多次，等同于{1,}。\n```\n\n# 贪婪模式\n\n```\nvar s = 'aaa';\ns.match(/a+/) // [\"aaa\"]\n```\n\n贪婪模式改为非贪婪模式\n\n```\n*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\n+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\n```\n\n# 字符串去空格(replace)\n\n```\nvar str = '  #id div.class  ';\nstr.trim() // \"#id div.class\"\nstr.replace(/^\\s+|\\s+$/g, '') // \"#id div.class\"\n```\n\n```\n$&：匹配的子字符串。\n$`：匹配结果前面的文本。\n$’：匹配结果后面的文本。\n$n：匹配成功的第n组内容，n是从1开始的自然数。\n$$：指代美元符号$。\n```\n\n多多练习吧\n\n---\n\n本文仅供个人学习使用\n","source":"_posts/正则表达式速记.md","raw":"---\ntitle: 正则表达式速记\ndate: 2018-10-28 14:15:51\ntags: RegExp\n---\n\n# 前言\n\n如何学习：[30 分钟入门正则表达式](https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html)\n[工具](https://www.regexpal.com/)\n本文参（zhao）考（chao）[RegExp 对象](https://wangdoc.com/javascript/stdlib/regexp.html)，该笔记只为速查\n\n# 简介\n\n正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，其体系参照 Perl 5 建立。\n\n# 创建正则表达式的方法\n\n1. 使用一个正则表达式字面量\n\n```\nvar re = /xxx/\n```\n\n2. 调用 RegExp 对象的构造函数\n\n```\nvar re = new RegExp('xxx')\n```\n\n两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。\n\n# 正则表达式的实例属性\n\n分为两类\n\n1. 修饰符（只读）\n   RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了 i 修饰符。用于忽略字符串大小写。\n   RegExp.prototype.global：返回一个布尔值，表示是否设置了 g 修饰符。用于全局匹配。\n   RegExp.prototype.multiline：返回一个布尔值，表示是否设置了 m 修饰符。用于设置匹配为多行模式。\n2. 其他属性\n   RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。\n   RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\n\n# 实例方法\n\n## 1. RegExp.prototype.test()\n\ntest 方法返回布尔值，表示当前模式是否能匹配参数字符串\n\n```\n/a/.test('and') // true\n```\n\n## 2. RegExp.prototype.exec()\n\nexec 方法，用来返回匹配结果\n如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回 null\n\n```\n/a/.exec('adbca')\n```\n\n如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。\n\n```\nString.prototype.match()：返回一个数组，成员是所有匹配的子字符串。\nString.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。\nString.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\nString.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\n```\n\n---\n\n# 字面量字符和元字符\n\n## 元字符\n\n1. 点字符（.)\n   匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n2. 位置字符\n\n```\n^ 表示字符串的开始位置\n$ 表示字符串的结束位置\n```\n\n3. 选择符（|）\n   表示“或关系”\n4. 转义符\n   匹配元字符本身可以在它们前面加反斜杠\n   构造函数需要两次转义\n5. 特殊字符\n\n```\n\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。\n[\\b] 匹配退格键(U+0008)，不要与\\b混淆。\n\\n 匹配换行键。\n\\r 匹配回车键。\n\\t 匹配制表符 tab（U+0009）。\n\\v 匹配垂直制表符（U+000B）。\n\\f 匹配换页符（U+000C）。\n\\0 匹配null字符（U+0000）。\n\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。\n\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。\n```\n\n# 字符类\n\n字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示 x、y、z 之中任选一个匹配。\n\n1. 脱字符（^）：需在字符类第一位\n   表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。\n2. 连字符（-）\n\n```\n[0-9.,]\n[0-9a-fA-F]\n[a-zA-Z0-9-]\n[1-31] // 不代表1到31，只代表1到3\n```\n\n# 预定义模式：某些常见模式的简写方式\n\n```\n\\d 匹配0-9之间的任一数字，相当于[0-9]。\n\\D 匹配所有0-9以外的字符，相当于[^0-9]。\n\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\n\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\n\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。\n\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。\n\\b 匹配词的边界。\n\\B 匹配非词边界，即在词的内部\n```\n\n# 重复类\n\n模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复 n 次，{n,}表示至少重复 n 次，{n,m}表示重复不少于 n 次，不多于 m 次。\n\n# 量词符：设定某个模式出现的次数\n\n```\n? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n* 星号表示某个模式出现0次或多次，等同于{0,}。\n+ 加号表示某个模式出现1次或多次，等同于{1,}。\n```\n\n# 贪婪模式\n\n```\nvar s = 'aaa';\ns.match(/a+/) // [\"aaa\"]\n```\n\n贪婪模式改为非贪婪模式\n\n```\n*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\n+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\n```\n\n# 字符串去空格(replace)\n\n```\nvar str = '  #id div.class  ';\nstr.trim() // \"#id div.class\"\nstr.replace(/^\\s+|\\s+$/g, '') // \"#id div.class\"\n```\n\n```\n$&：匹配的子字符串。\n$`：匹配结果前面的文本。\n$’：匹配结果后面的文本。\n$n：匹配成功的第n组内容，n是从1开始的自然数。\n$$：指代美元符号$。\n```\n\n多多练习吧\n\n---\n\n本文仅供个人学习使用\n","slug":"正则表达式速记","published":1,"updated":"2020-03-28T17:29:27.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswza000xws99wpb8otxp","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如何学习：<a href=\"https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html\" target=\"_blank\" rel=\"noopener\">30 分钟入门正则表达式</a><br><a href=\"https://www.regexpal.com/\" target=\"_blank\" rel=\"noopener\">工具</a><br>本文参（zhao）考（chao）<a href=\"https://wangdoc.com/javascript/stdlib/regexp.html\" target=\"_blank\" rel=\"noopener\">RegExp 对象</a>，该笔记只为速查</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，其体系参照 Perl 5 建立。</p>\n<h1 id=\"创建正则表达式的方法\"><a href=\"#创建正则表达式的方法\" class=\"headerlink\" title=\"创建正则表达式的方法\"></a>创建正则表达式的方法</h1><ol>\n<li>使用一个正则表达式字面量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /xxx/</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>调用 RegExp 对象的构造函数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = new RegExp(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure>\n<p>两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>\n<h1 id=\"正则表达式的实例属性\"><a href=\"#正则表达式的实例属性\" class=\"headerlink\" title=\"正则表达式的实例属性\"></a>正则表达式的实例属性</h1><p>分为两类</p>\n<ol>\n<li>修饰符（只读）<br>RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了 i 修饰符。用于忽略字符串大小写。<br>RegExp.prototype.global：返回一个布尔值，表示是否设置了 g 修饰符。用于全局匹配。<br>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了 m 修饰符。用于设置匹配为多行模式。</li>\n<li>其他属性<br>RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。<br>RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>\n</ol>\n<h1 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h1><h2 id=\"1-RegExp-prototype-test\"><a href=\"#1-RegExp-prototype-test\" class=\"headerlink\" title=\"1. RegExp.prototype.test()\"></a>1. RegExp.prototype.test()</h2><p>test 方法返回布尔值，表示当前模式是否能匹配参数字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/a/.test(&apos;and&apos;) // true</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-RegExp-prototype-exec\"><a href=\"#2-RegExp-prototype-exec\" class=\"headerlink\" title=\"2. RegExp.prototype.exec()\"></a>2. RegExp.prototype.exec()</h2><p>exec 方法，用来返回匹配结果<br>如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回 null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/a/.exec(&apos;adbca&apos;)</span><br></pre></td></tr></table></figure>\n<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</span><br><span class=\"line\">String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</span><br><span class=\"line\">String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</span><br><span class=\"line\">String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"字面量字符和元字符\"><a href=\"#字面量字符和元字符\" class=\"headerlink\" title=\"字面量字符和元字符\"></a>字面量字符和元字符</h1><h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><ol>\n<li>点字符（.)<br>匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。</li>\n<li>位置字符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^ 表示字符串的开始位置</span><br><span class=\"line\">$ 表示字符串的结束位置</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>选择符（|）<br>表示“或关系”</li>\n<li>转义符<br>匹配元字符本身可以在它们前面加反斜杠<br>构造函数需要两次转义</li>\n<li>特殊字符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</span><br><span class=\"line\">[\\b] 匹配退格键(U+0008)，不要与\\b混淆。</span><br><span class=\"line\">\\n 匹配换行键。</span><br><span class=\"line\">\\r 匹配回车键。</span><br><span class=\"line\">\\t 匹配制表符 tab（U+0009）。</span><br><span class=\"line\">\\v 匹配垂直制表符（U+000B）。</span><br><span class=\"line\">\\f 匹配换页符（U+000C）。</span><br><span class=\"line\">\\0 匹配null字符（U+0000）。</span><br><span class=\"line\">\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。</span><br><span class=\"line\">\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h1><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示 x、y、z 之中任选一个匹配。</p>\n<ol>\n<li>脱字符（^）：需在字符类第一位<br>表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</li>\n<li>连字符（-）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0-9.,]</span><br><span class=\"line\">[0-9a-fA-F]</span><br><span class=\"line\">[a-zA-Z0-9-]</span><br><span class=\"line\">[1-31] // 不代表1到31，只代表1到3</span><br></pre></td></tr></table></figure>\n<h1 id=\"预定义模式：某些常见模式的简写方式\"><a href=\"#预定义模式：某些常见模式的简写方式\" class=\"headerlink\" title=\"预定义模式：某些常见模式的简写方式\"></a>预定义模式：某些常见模式的简写方式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\d 匹配0-9之间的任一数字，相当于[0-9]。</span><br><span class=\"line\">\\D 匹配所有0-9以外的字符，相当于[^0-9]。</span><br><span class=\"line\">\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</span><br><span class=\"line\">\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</span><br><span class=\"line\">\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。</span><br><span class=\"line\">\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。</span><br><span class=\"line\">\\b 匹配词的边界。</span><br><span class=\"line\">\\B 匹配非词边界，即在词的内部</span><br></pre></td></tr></table></figure>\n<h1 id=\"重复类\"><a href=\"#重复类\" class=\"headerlink\" title=\"重复类\"></a>重复类</h1><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复 n 次，{n,}表示至少重复 n 次，{n,m}表示重复不少于 n 次，不多于 m 次。</p>\n<h1 id=\"量词符：设定某个模式出现的次数\"><a href=\"#量词符：设定某个模式出现的次数\" class=\"headerlink\" title=\"量词符：设定某个模式出现的次数\"></a>量词符：设定某个模式出现的次数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。</span><br><span class=\"line\">* 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。</span><br><span class=\"line\">+ 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。</span><br></pre></td></tr></table></figure>\n<h1 id=\"贪婪模式\"><a href=\"#贪婪模式\" class=\"headerlink\" title=\"贪婪模式\"></a>贪婪模式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = &apos;aaa&apos;;</span><br><span class=\"line\">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure>\n<p>贪婪模式改为非贪婪模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</span><br><span class=\"line\">+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串去空格-replace\"><a href=\"#字符串去空格-replace\" class=\"headerlink\" title=\"字符串去空格(replace)\"></a>字符串去空格(replace)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;  #id div.class  &apos;;</span><br><span class=\"line\">str.trim() // &quot;#id div.class&quot;</span><br><span class=\"line\">str.replace(/^\\s+|\\s+$/g, &apos;&apos;) // &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&amp;：匹配的子字符串。</span><br><span class=\"line\">$`：匹配结果前面的文本。</span><br><span class=\"line\">$’：匹配结果后面的文本。</span><br><span class=\"line\">$n：匹配成功的第n组内容，n是从1开始的自然数。</span><br><span class=\"line\">$$：指代美元符号$。</span><br></pre></td></tr></table></figure>\n<p>多多练习吧</p>\n<hr>\n<p>本文仅供个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如何学习：<a href=\"https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter8.html\" target=\"_blank\" rel=\"noopener\">30 分钟入门正则表达式</a><br><a href=\"https://www.regexpal.com/\" target=\"_blank\" rel=\"noopener\">工具</a><br>本文参（zhao）考（chao）<a href=\"https://wangdoc.com/javascript/stdlib/regexp.html\" target=\"_blank\" rel=\"noopener\">RegExp 对象</a>，该笔记只为速查</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>正则表达式（regular expression）是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，其体系参照 Perl 5 建立。</p>\n<h1 id=\"创建正则表达式的方法\"><a href=\"#创建正则表达式的方法\" class=\"headerlink\" title=\"创建正则表达式的方法\"></a>创建正则表达式的方法</h1><ol>\n<li>使用一个正则表达式字面量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /xxx/</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>调用 RegExp 对象的构造函数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = new RegExp(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure>\n<p>两种方法主要区别是：第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>\n<h1 id=\"正则表达式的实例属性\"><a href=\"#正则表达式的实例属性\" class=\"headerlink\" title=\"正则表达式的实例属性\"></a>正则表达式的实例属性</h1><p>分为两类</p>\n<ol>\n<li>修饰符（只读）<br>RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了 i 修饰符。用于忽略字符串大小写。<br>RegExp.prototype.global：返回一个布尔值，表示是否设置了 g 修饰符。用于全局匹配。<br>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了 m 修饰符。用于设置匹配为多行模式。</li>\n<li>其他属性<br>RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。<br>RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>\n</ol>\n<h1 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h1><h2 id=\"1-RegExp-prototype-test\"><a href=\"#1-RegExp-prototype-test\" class=\"headerlink\" title=\"1. RegExp.prototype.test()\"></a>1. RegExp.prototype.test()</h2><p>test 方法返回布尔值，表示当前模式是否能匹配参数字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/a/.test(&apos;and&apos;) // true</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-RegExp-prototype-exec\"><a href=\"#2-RegExp-prototype-exec\" class=\"headerlink\" title=\"2. RegExp.prototype.exec()\"></a>2. RegExp.prototype.exec()</h2><p>exec 方法，用来返回匹配结果<br>如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回 null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/a/.exec(&apos;adbca&apos;)</span><br></pre></td></tr></table></figure>\n<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</span><br><span class=\"line\">String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</span><br><span class=\"line\">String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</span><br><span class=\"line\">String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"字面量字符和元字符\"><a href=\"#字面量字符和元字符\" class=\"headerlink\" title=\"字面量字符和元字符\"></a>字面量字符和元字符</h1><h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><ol>\n<li>点字符（.)<br>匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。</li>\n<li>位置字符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^ 表示字符串的开始位置</span><br><span class=\"line\">$ 表示字符串的结束位置</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>选择符（|）<br>表示“或关系”</li>\n<li>转义符<br>匹配元字符本身可以在它们前面加反斜杠<br>构造函数需要两次转义</li>\n<li>特殊字符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</span><br><span class=\"line\">[\\b] 匹配退格键(U+0008)，不要与\\b混淆。</span><br><span class=\"line\">\\n 匹配换行键。</span><br><span class=\"line\">\\r 匹配回车键。</span><br><span class=\"line\">\\t 匹配制表符 tab（U+0009）。</span><br><span class=\"line\">\\v 匹配垂直制表符（U+000B）。</span><br><span class=\"line\">\\f 匹配换页符（U+000C）。</span><br><span class=\"line\">\\0 匹配null字符（U+0000）。</span><br><span class=\"line\">\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。</span><br><span class=\"line\">\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h1><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[^xyz] 表示 x、y、z 之中任选一个匹配。</p>\n<ol>\n<li>脱字符（^）：需在字符类第一位<br>表示除了字符类之中的字符，其他字符都可以匹配。只有[^]，就表示匹配一切字符，包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。</li>\n<li>连字符（-）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0-9.,]</span><br><span class=\"line\">[0-9a-fA-F]</span><br><span class=\"line\">[a-zA-Z0-9-]</span><br><span class=\"line\">[1-31] // 不代表1到31，只代表1到3</span><br></pre></td></tr></table></figure>\n<h1 id=\"预定义模式：某些常见模式的简写方式\"><a href=\"#预定义模式：某些常见模式的简写方式\" class=\"headerlink\" title=\"预定义模式：某些常见模式的简写方式\"></a>预定义模式：某些常见模式的简写方式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\d 匹配0-9之间的任一数字，相当于[0-9]。</span><br><span class=\"line\">\\D 匹配所有0-9以外的字符，相当于[^0-9]。</span><br><span class=\"line\">\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</span><br><span class=\"line\">\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</span><br><span class=\"line\">\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。</span><br><span class=\"line\">\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。</span><br><span class=\"line\">\\b 匹配词的边界。</span><br><span class=\"line\">\\B 匹配非词边界，即在词的内部</span><br></pre></td></tr></table></figure>\n<h1 id=\"重复类\"><a href=\"#重复类\" class=\"headerlink\" title=\"重复类\"></a>重复类</h1><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复 n 次，{n,}表示至少重复 n 次，{n,m}表示重复不少于 n 次，不多于 m 次。</p>\n<h1 id=\"量词符：设定某个模式出现的次数\"><a href=\"#量词符：设定某个模式出现的次数\" class=\"headerlink\" title=\"量词符：设定某个模式出现的次数\"></a>量词符：设定某个模式出现的次数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。</span><br><span class=\"line\">* 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。</span><br><span class=\"line\">+ 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。</span><br></pre></td></tr></table></figure>\n<h1 id=\"贪婪模式\"><a href=\"#贪婪模式\" class=\"headerlink\" title=\"贪婪模式\"></a>贪婪模式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = &apos;aaa&apos;;</span><br><span class=\"line\">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure>\n<p>贪婪模式改为非贪婪模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</span><br><span class=\"line\">+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串去空格-replace\"><a href=\"#字符串去空格-replace\" class=\"headerlink\" title=\"字符串去空格(replace)\"></a>字符串去空格(replace)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;  #id div.class  &apos;;</span><br><span class=\"line\">str.trim() // &quot;#id div.class&quot;</span><br><span class=\"line\">str.replace(/^\\s+|\\s+$/g, &apos;&apos;) // &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&amp;：匹配的子字符串。</span><br><span class=\"line\">$`：匹配结果前面的文本。</span><br><span class=\"line\">$’：匹配结果后面的文本。</span><br><span class=\"line\">$n：匹配成功的第n组内容，n是从1开始的自然数。</span><br><span class=\"line\">$$：指代美元符号$。</span><br></pre></td></tr></table></figure>\n<p>多多练习吧</p>\n<hr>\n<p>本文仅供个人学习使用</p>\n"},{"title":"理解 JSONP 下","date":"2018-08-12T04:25:05.000Z","_content":"\n[理解 JSONP 上](https://www.jianshu.com/p/2a2fe02917e7)\n\n# 跨域 SRJ\n\n**如果我访问其他网站的服务器，可以吗？\n由于 JSONP 可以规避同源策略，因此可以**\n下面我们自己做两个网站尝试一下\n请求方：ada.com （浏览器）\n响应方：jack.com （服务器）\n\nLinux 或 mac 直接\n\n```\nvi /etc/hosts\n```\n\nwindows 需要找到/etc/hosts 文件 比较难找，推荐 Everything![](https://upload-images.jianshu.io/upload_images/7094266-19f9953c967705a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)在 hosts 文件下编辑两个网站![](https://upload-images.jianshu.io/upload_images/7094266-28b643545d3a06f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)打开两个 node 服务器![](https://upload-images.jianshu.io/upload_images/7094266-3cd83a6dd9b8e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将 script.src 改成后端服务器的 jack.com\n\n```\nscript.src = 'http://jack.com:8002/pay'\n```\n\n成功在 ada.com 里接收到 jack.com，ada.com 的前端程序员成功向 jack.com 的后端程序员发起请求并得到响应![](https://upload-images.jianshu.io/upload_images/7094266-455e37f97e889991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)跨域 SRJ 成功\n\n# 代码分离：\n\n**耦合**和**解耦**![](https://upload-images.jianshu.io/upload_images/7094266-39446f3e68a37a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)上面的 amount.innerText=amount.innerText-1 就是前端页面的代码，这说明 jack.com 的后端程序元需要对 ada.com 的页面细节了解的很清楚，这种情况叫做耦合\n那我们让前后端分离呗，即解耦\n后端改成\n\n```\n//获取参数.call（this，成功）\nresponse.write(`${query.callbackName}.call(undefined,'success')`)\n```\n\n前端给参\n\n```\n//callbackName = 随便\nscript.src = 'http://jack.com:8002/pay?callbackName=yyy'\n```\n\n# JSONP:\n\n![](https://upload-images.jianshu.io/upload_images/7094266-9442483142643759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面代码高亮的部分就是[JSON](https://www.json.org/)（一个键必须是双引号的对象）\nJSON 左边的代码就是左 padding，右边就是右 padding，所以 JSONP=JSON +Padding\n\n# 让我们理一下过程\n\n请求方：ada.com 的前端程序员（浏览器）\n响应方：jack.com 的后端程序员（服务器） 1.请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 2.响应方根据查询参数 callbackName，构造形如\nyyy.call(undefined, '你要的数据')\nyyy('你要的数据')\n这样的响应 3.浏览器接收到响应，就会执行 yyy.call(undefined, '你要的数据') 4.那么请求方就知道了他要的数据\n这就是 JSONP\n**约定：**\ncallbackName -> callback\nyyy -> 随机数 如 ada1213123123412()\n\n# JSONP 方案\n\n```\nbutton.addEventListener('click', (e)=>{\n    let script = document.createElement('script')\n    let functionName = 'ada'+ parseInt(Math.random()*10000000 ,10)\n    window[functionName] = function(){  // 每次请求之前搞出一个随机的函数\n        amount.innerText = amount.innerText - 1\n    }\n    script.src = 'http://jack.com:8002/pay?callback=' + functionName\n    document.body.appendChild(script)\n    script.onload = function(e){ // 状态码是 200~299 则表示成功\n        e.currentTarget.remove()\n        delete window[functionName] // 请求完了就干掉这个随机函数\n    }\n    script.onload = function(e){ // 状态码大于等于 400 则表示失败\n        e.currentTarget.remove()\n        delete window[functionName] // 请求完了就干掉这个随机函数\n    }\n})\n```\n\nNode 部分：\n\n```\nif (path === '/pay') {\n    var amount = fs.readFileSync('./db', 'utf8')\n    var newAmount = amount - 1\n    fs.writeFileSync('./db', newAmount)\n    response.setHeader('Content-Type', 'application/javascript')\n    response.write(`${query.callbackName}.call(undefined,\n      'success'`)\n    response.end()\n```\n\njQuery 写法\n\n```\n $.ajax({\n url: \"http://jack.com:8002/pay\",\n dataType: \"jsonp\",\n success: function( response ) {\n     if(response === 'success'){\n     amount.innerText = amount.innerText - 1\n     }\n }\n })\n```\n\n# [JSONP 为什么不支持 POST？](https://www.zhihu.com/question/28890257)\n\n因为 JSONP 是通过**动态创建 Script** 实现的，而**动态创建 Script**只能用 GET 请求，不能用 POST 请求\n\n---\n\n本文主要用于个人学习使用\n","source":"_posts/理解JSONP-下.md","raw":"---\ntitle: 理解 JSONP 下\ndate: 2018-08-12 12:25:05\ntags: HTTP\n---\n\n[理解 JSONP 上](https://www.jianshu.com/p/2a2fe02917e7)\n\n# 跨域 SRJ\n\n**如果我访问其他网站的服务器，可以吗？\n由于 JSONP 可以规避同源策略，因此可以**\n下面我们自己做两个网站尝试一下\n请求方：ada.com （浏览器）\n响应方：jack.com （服务器）\n\nLinux 或 mac 直接\n\n```\nvi /etc/hosts\n```\n\nwindows 需要找到/etc/hosts 文件 比较难找，推荐 Everything![](https://upload-images.jianshu.io/upload_images/7094266-19f9953c967705a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)在 hosts 文件下编辑两个网站![](https://upload-images.jianshu.io/upload_images/7094266-28b643545d3a06f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)打开两个 node 服务器![](https://upload-images.jianshu.io/upload_images/7094266-3cd83a6dd9b8e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将 script.src 改成后端服务器的 jack.com\n\n```\nscript.src = 'http://jack.com:8002/pay'\n```\n\n成功在 ada.com 里接收到 jack.com，ada.com 的前端程序员成功向 jack.com 的后端程序员发起请求并得到响应![](https://upload-images.jianshu.io/upload_images/7094266-455e37f97e889991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)跨域 SRJ 成功\n\n# 代码分离：\n\n**耦合**和**解耦**![](https://upload-images.jianshu.io/upload_images/7094266-39446f3e68a37a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)上面的 amount.innerText=amount.innerText-1 就是前端页面的代码，这说明 jack.com 的后端程序元需要对 ada.com 的页面细节了解的很清楚，这种情况叫做耦合\n那我们让前后端分离呗，即解耦\n后端改成\n\n```\n//获取参数.call（this，成功）\nresponse.write(`${query.callbackName}.call(undefined,'success')`)\n```\n\n前端给参\n\n```\n//callbackName = 随便\nscript.src = 'http://jack.com:8002/pay?callbackName=yyy'\n```\n\n# JSONP:\n\n![](https://upload-images.jianshu.io/upload_images/7094266-9442483142643759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面代码高亮的部分就是[JSON](https://www.json.org/)（一个键必须是双引号的对象）\nJSON 左边的代码就是左 padding，右边就是右 padding，所以 JSONP=JSON +Padding\n\n# 让我们理一下过程\n\n请求方：ada.com 的前端程序员（浏览器）\n响应方：jack.com 的后端程序员（服务器） 1.请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 2.响应方根据查询参数 callbackName，构造形如\nyyy.call(undefined, '你要的数据')\nyyy('你要的数据')\n这样的响应 3.浏览器接收到响应，就会执行 yyy.call(undefined, '你要的数据') 4.那么请求方就知道了他要的数据\n这就是 JSONP\n**约定：**\ncallbackName -> callback\nyyy -> 随机数 如 ada1213123123412()\n\n# JSONP 方案\n\n```\nbutton.addEventListener('click', (e)=>{\n    let script = document.createElement('script')\n    let functionName = 'ada'+ parseInt(Math.random()*10000000 ,10)\n    window[functionName] = function(){  // 每次请求之前搞出一个随机的函数\n        amount.innerText = amount.innerText - 1\n    }\n    script.src = 'http://jack.com:8002/pay?callback=' + functionName\n    document.body.appendChild(script)\n    script.onload = function(e){ // 状态码是 200~299 则表示成功\n        e.currentTarget.remove()\n        delete window[functionName] // 请求完了就干掉这个随机函数\n    }\n    script.onload = function(e){ // 状态码大于等于 400 则表示失败\n        e.currentTarget.remove()\n        delete window[functionName] // 请求完了就干掉这个随机函数\n    }\n})\n```\n\nNode 部分：\n\n```\nif (path === '/pay') {\n    var amount = fs.readFileSync('./db', 'utf8')\n    var newAmount = amount - 1\n    fs.writeFileSync('./db', newAmount)\n    response.setHeader('Content-Type', 'application/javascript')\n    response.write(`${query.callbackName}.call(undefined,\n      'success'`)\n    response.end()\n```\n\njQuery 写法\n\n```\n $.ajax({\n url: \"http://jack.com:8002/pay\",\n dataType: \"jsonp\",\n success: function( response ) {\n     if(response === 'success'){\n     amount.innerText = amount.innerText - 1\n     }\n }\n })\n```\n\n# [JSONP 为什么不支持 POST？](https://www.zhihu.com/question/28890257)\n\n因为 JSONP 是通过**动态创建 Script** 实现的，而**动态创建 Script**只能用 GET 请求，不能用 POST 请求\n\n---\n\n本文主要用于个人学习使用\n","slug":"理解JSONP-下","published":1,"updated":"2020-03-28T17:28:20.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswzb000yws99rzgk0oe6","content":"<p><a href=\"https://www.jianshu.com/p/2a2fe02917e7\" target=\"_blank\" rel=\"noopener\">理解 JSONP 上</a></p>\n<h1 id=\"跨域-SRJ\"><a href=\"#跨域-SRJ\" class=\"headerlink\" title=\"跨域 SRJ\"></a>跨域 SRJ</h1><p><strong>如果我访问其他网站的服务器，可以吗？<br>由于 JSONP 可以规避同源策略，因此可以</strong><br>下面我们自己做两个网站尝试一下<br>请求方：ada.com （浏览器）<br>响应方：jack.com （服务器）</p>\n<p>Linux 或 mac 直接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/hosts</span><br></pre></td></tr></table></figure>\n<p>windows 需要找到/etc/hosts 文件 比较难找，推荐 Everything<img src=\"https://upload-images.jianshu.io/upload_images/7094266-19f9953c967705a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">在 hosts 文件下编辑两个网站<img src=\"https://upload-images.jianshu.io/upload_images/7094266-28b643545d3a06f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">打开两个 node 服务器<img src=\"https://upload-images.jianshu.io/upload_images/7094266-3cd83a6dd9b8e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>将 script.src 改成后端服务器的 jack.com</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script.src = &apos;http://jack.com:8002/pay&apos;</span><br></pre></td></tr></table></figure>\n<p>成功在 ada.com 里接收到 jack.com，ada.com 的前端程序员成功向 jack.com 的后端程序员发起请求并得到响应<img src=\"https://upload-images.jianshu.io/upload_images/7094266-455e37f97e889991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">跨域 SRJ 成功</p>\n<h1 id=\"代码分离：\"><a href=\"#代码分离：\" class=\"headerlink\" title=\"代码分离：\"></a>代码分离：</h1><p><strong>耦合</strong>和<strong>解耦</strong><img src=\"https://upload-images.jianshu.io/upload_images/7094266-39446f3e68a37a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">上面的 amount.innerText=amount.innerText-1 就是前端页面的代码，这说明 jack.com 的后端程序元需要对 ada.com 的页面细节了解的很清楚，这种情况叫做耦合<br>那我们让前后端分离呗，即解耦<br>后端改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取参数.call（this，成功）</span><br><span class=\"line\">response.write(`$&#123;query.callbackName&#125;.call(undefined,&apos;success&apos;)`)</span><br></pre></td></tr></table></figure>\n<p>前端给参</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//callbackName = 随便</span><br><span class=\"line\">script.src = &apos;http://jack.com:8002/pay?callbackName=yyy&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP:\"></a>JSONP:</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-9442483142643759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>上面代码高亮的部分就是<a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener\">JSON</a>（一个键必须是双引号的对象）<br>JSON 左边的代码就是左 padding，右边就是右 padding，所以 JSONP=JSON +Padding</p>\n<h1 id=\"让我们理一下过程\"><a href=\"#让我们理一下过程\" class=\"headerlink\" title=\"让我们理一下过程\"></a>让我们理一下过程</h1><p>请求方：ada.com 的前端程序员（浏览器）<br>响应方：jack.com 的后端程序员（服务器） 1.请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 2.响应方根据查询参数 callbackName，构造形如<br>yyy.call(undefined, ‘你要的数据’)<br>yyy(‘你要的数据’)<br>这样的响应 3.浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’) 4.那么请求方就知道了他要的数据<br>这就是 JSONP<br><strong>约定：</strong><br>callbackName -&gt; callback<br>yyy -&gt; 随机数 如 ada1213123123412()</p>\n<h1 id=\"JSONP-方案\"><a href=\"#JSONP-方案\" class=\"headerlink\" title=\"JSONP 方案\"></a>JSONP 方案</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</span><br><span class=\"line\">    let script = document.createElement(&apos;script&apos;)</span><br><span class=\"line\">    let functionName = &apos;ada&apos;+ parseInt(Math.random()*10000000 ,10)</span><br><span class=\"line\">    window[functionName] = function()&#123;  // 每次请求之前搞出一个随机的函数</span><br><span class=\"line\">        amount.innerText = amount.innerText - 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.src = &apos;http://jack.com:8002/pay?callback=&apos; + functionName</span><br><span class=\"line\">    document.body.appendChild(script)</span><br><span class=\"line\">    script.onload = function(e)&#123; // 状态码是 200~299 则表示成功</span><br><span class=\"line\">        e.currentTarget.remove()</span><br><span class=\"line\">        delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.onload = function(e)&#123; // 状态码大于等于 400 则表示失败</span><br><span class=\"line\">        e.currentTarget.remove()</span><br><span class=\"line\">        delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Node 部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (path === &apos;/pay&apos;) &#123;</span><br><span class=\"line\">    var amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    var newAmount = amount - 1</span><br><span class=\"line\">    fs.writeFileSync(&apos;./db&apos;, newAmount)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;)</span><br><span class=\"line\">    response.write(`$&#123;query.callbackName&#125;.call(undefined,</span><br><span class=\"line\">      &apos;success&apos;`)</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>jQuery 写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">url: &quot;http://jack.com:8002/pay&quot;,</span><br><span class=\"line\">dataType: &quot;jsonp&quot;,</span><br><span class=\"line\">success: function( response ) &#123;</span><br><span class=\"line\">    if(response === &apos;success&apos;)&#123;</span><br><span class=\"line\">    amount.innerText = amount.innerText - 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSONP-为什么不支持-POST？\"><a href=\"#JSONP-为什么不支持-POST？\" class=\"headerlink\" title=\"JSONP 为什么不支持 POST？\"></a><a href=\"https://www.zhihu.com/question/28890257\" target=\"_blank\" rel=\"noopener\">JSONP 为什么不支持 POST？</a></h1><p>因为 JSONP 是通过<strong>动态创建 Script</strong> 实现的，而<strong>动态创建 Script</strong>只能用 GET 请求，不能用 POST 请求</p>\n<hr>\n<p>本文主要用于个人学习使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/2a2fe02917e7\" target=\"_blank\" rel=\"noopener\">理解 JSONP 上</a></p>\n<h1 id=\"跨域-SRJ\"><a href=\"#跨域-SRJ\" class=\"headerlink\" title=\"跨域 SRJ\"></a>跨域 SRJ</h1><p><strong>如果我访问其他网站的服务器，可以吗？<br>由于 JSONP 可以规避同源策略，因此可以</strong><br>下面我们自己做两个网站尝试一下<br>请求方：ada.com （浏览器）<br>响应方：jack.com （服务器）</p>\n<p>Linux 或 mac 直接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/hosts</span><br></pre></td></tr></table></figure>\n<p>windows 需要找到/etc/hosts 文件 比较难找，推荐 Everything<img src=\"https://upload-images.jianshu.io/upload_images/7094266-19f9953c967705a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">在 hosts 文件下编辑两个网站<img src=\"https://upload-images.jianshu.io/upload_images/7094266-28b643545d3a06f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">打开两个 node 服务器<img src=\"https://upload-images.jianshu.io/upload_images/7094266-3cd83a6dd9b8e522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>将 script.src 改成后端服务器的 jack.com</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script.src = &apos;http://jack.com:8002/pay&apos;</span><br></pre></td></tr></table></figure>\n<p>成功在 ada.com 里接收到 jack.com，ada.com 的前端程序员成功向 jack.com 的后端程序员发起请求并得到响应<img src=\"https://upload-images.jianshu.io/upload_images/7094266-455e37f97e889991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">跨域 SRJ 成功</p>\n<h1 id=\"代码分离：\"><a href=\"#代码分离：\" class=\"headerlink\" title=\"代码分离：\"></a>代码分离：</h1><p><strong>耦合</strong>和<strong>解耦</strong><img src=\"https://upload-images.jianshu.io/upload_images/7094266-39446f3e68a37a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">上面的 amount.innerText=amount.innerText-1 就是前端页面的代码，这说明 jack.com 的后端程序元需要对 ada.com 的页面细节了解的很清楚，这种情况叫做耦合<br>那我们让前后端分离呗，即解耦<br>后端改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取参数.call（this，成功）</span><br><span class=\"line\">response.write(`$&#123;query.callbackName&#125;.call(undefined,&apos;success&apos;)`)</span><br></pre></td></tr></table></figure>\n<p>前端给参</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//callbackName = 随便</span><br><span class=\"line\">script.src = &apos;http://jack.com:8002/pay?callbackName=yyy&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP:\"></a>JSONP:</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/7094266-9442483142643759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>上面代码高亮的部分就是<a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener\">JSON</a>（一个键必须是双引号的对象）<br>JSON 左边的代码就是左 padding，右边就是右 padding，所以 JSONP=JSON +Padding</p>\n<h1 id=\"让我们理一下过程\"><a href=\"#让我们理一下过程\" class=\"headerlink\" title=\"让我们理一下过程\"></a>让我们理一下过程</h1><p>请求方：ada.com 的前端程序员（浏览器）<br>响应方：jack.com 的后端程序员（服务器） 1.请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 2.响应方根据查询参数 callbackName，构造形如<br>yyy.call(undefined, ‘你要的数据’)<br>yyy(‘你要的数据’)<br>这样的响应 3.浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’) 4.那么请求方就知道了他要的数据<br>这就是 JSONP<br><strong>约定：</strong><br>callbackName -&gt; callback<br>yyy -&gt; 随机数 如 ada1213123123412()</p>\n<h1 id=\"JSONP-方案\"><a href=\"#JSONP-方案\" class=\"headerlink\" title=\"JSONP 方案\"></a>JSONP 方案</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</span><br><span class=\"line\">    let script = document.createElement(&apos;script&apos;)</span><br><span class=\"line\">    let functionName = &apos;ada&apos;+ parseInt(Math.random()*10000000 ,10)</span><br><span class=\"line\">    window[functionName] = function()&#123;  // 每次请求之前搞出一个随机的函数</span><br><span class=\"line\">        amount.innerText = amount.innerText - 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.src = &apos;http://jack.com:8002/pay?callback=&apos; + functionName</span><br><span class=\"line\">    document.body.appendChild(script)</span><br><span class=\"line\">    script.onload = function(e)&#123; // 状态码是 200~299 则表示成功</span><br><span class=\"line\">        e.currentTarget.remove()</span><br><span class=\"line\">        delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.onload = function(e)&#123; // 状态码大于等于 400 则表示失败</span><br><span class=\"line\">        e.currentTarget.remove()</span><br><span class=\"line\">        delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Node 部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (path === &apos;/pay&apos;) &#123;</span><br><span class=\"line\">    var amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class=\"line\">    var newAmount = amount - 1</span><br><span class=\"line\">    fs.writeFileSync(&apos;./db&apos;, newAmount)</span><br><span class=\"line\">    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;)</span><br><span class=\"line\">    response.write(`$&#123;query.callbackName&#125;.call(undefined,</span><br><span class=\"line\">      &apos;success&apos;`)</span><br><span class=\"line\">    response.end()</span><br></pre></td></tr></table></figure>\n<p>jQuery 写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">url: &quot;http://jack.com:8002/pay&quot;,</span><br><span class=\"line\">dataType: &quot;jsonp&quot;,</span><br><span class=\"line\">success: function( response ) &#123;</span><br><span class=\"line\">    if(response === &apos;success&apos;)&#123;</span><br><span class=\"line\">    amount.innerText = amount.innerText - 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSONP-为什么不支持-POST？\"><a href=\"#JSONP-为什么不支持-POST？\" class=\"headerlink\" title=\"JSONP 为什么不支持 POST？\"></a><a href=\"https://www.zhihu.com/question/28890257\" target=\"_blank\" rel=\"noopener\">JSONP 为什么不支持 POST？</a></h1><p>因为 JSONP 是通过<strong>动态创建 Script</strong> 实现的，而<strong>动态创建 Script</strong>只能用 GET 请求，不能用 POST 请求</p>\n<hr>\n<p>本文主要用于个人学习使用</p>\n"},{"title":"理解虚拟 DOM","date":"2018-09-27T13:10:41.000Z","_content":"\n# DOM 和 Virtual DOM\n\n**DOM：Document Object Model 把文档变成对象的模型\n在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。\n问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？\n你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。\n方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。\n在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。**\n\n`Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）`\n\n# 过程实现\n\n文档界面\n\n```\n<body>\n    <div id=\"root\"></div>\n    <script src=\"./v-dom.js\"></script>\n</body>\n```\n\n```\n// 定义一个 VNode 类\nclass VNode {\n    constructor(tag, children, text) {\n        this.tag = tag\n        this.children = children\n        this.text = text\n    }\n\n    render() { // render 方法，创建子元素\n        if (this.tag === '#text') {\n            return document.createTextNode(this.text)\n        }\n        let el = document.createElement(this.tag)\n        this.children.forEach(vChild => {\n            el.appendChild(vChild.render())\n        })\n        return el\n    }\n}\n// v 构造函数，判断子元素类型\nfunction v(tag, children, text) {\n    if (typeof children === 'string') {\n        text = children\n        children = []\n    }\n    return new VNode(tag, children, text)\n}\n```\n\n```\nlet vNode = v('div', [\n    v('p', [\n        v('span', [v('#text', 'Ada')])\n    ]),\n    v('span', [v('#text', 'shuai')])\n])\nconst root = document.querySelector('#root')\nroot.appendChild(vNode.render())\n```\n\n通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中\n![](https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了**\n\n```\nfunction patchElement(parent, newVNode, oldVNode, index = 0) {\n    if (!oldVNode) {\n        parent.appendChild(newVNode.render())\n    } else if (!newVNode) {\n        parent.removeChild(parent.childNodes[index])\n    } else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) {\n        parent.replaceChild(newVNode.render(), parent.childNodes[index])\n    } else {\n        for (let i = 0; i < newVNode.children.length || i < oldVNode.children.length; i++) {\n            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)\n        }\n    }\n}\n```\n\n当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。\n\n整个状态变更的过程如下\n\n```\n// 1. 构建虚拟DOM\nlet vNode = v('div', [\n    v('p', [\n        v('span', [v('#text', 'Ada')])\n    ]),\n    v('span', [v('#text', 'shuai')])\n])\n// 3. 生成新的虚拟DOM\nlet vNode1 = v('div', [\n    v('p', [\n        v('span', [v('#text', 'Ada')])\n    ]),\n    v('span', [v('#text', 'shuai')]),\n    v('p', [v('#text', 'upload')])\n])\n// 2. 通过虚拟DOM构建真正的DOM\nconst root = document.querySelector('#root')\npatchElement(root, vNode)\nvar n = 0\n// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更\ndocument.querySelector('.btn').onclick = function () {\n    if (n % 2 == 0) {\n        patchElement(root, vNode1, vNode)\n    } else {\n        patchElement(root, vNode, vNode1)\n    }\n    n += 1\n}\n```\n\n本文仅供个人学习使用\n\n---\n\n主要参考：[深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)\n","source":"_posts/理解虚拟-DOM.md","raw":"---\ntitle: 理解虚拟 DOM\ndate: 2018-09-27 21:10:41\ntags: 设计模式\n---\n\n# DOM 和 Virtual DOM\n\n**DOM：Document Object Model 把文档变成对象的模型\n在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。\n问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？\n你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。\n方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。\n在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。**\n\n`Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）`\n\n# 过程实现\n\n文档界面\n\n```\n<body>\n    <div id=\"root\"></div>\n    <script src=\"./v-dom.js\"></script>\n</body>\n```\n\n```\n// 定义一个 VNode 类\nclass VNode {\n    constructor(tag, children, text) {\n        this.tag = tag\n        this.children = children\n        this.text = text\n    }\n\n    render() { // render 方法，创建子元素\n        if (this.tag === '#text') {\n            return document.createTextNode(this.text)\n        }\n        let el = document.createElement(this.tag)\n        this.children.forEach(vChild => {\n            el.appendChild(vChild.render())\n        })\n        return el\n    }\n}\n// v 构造函数，判断子元素类型\nfunction v(tag, children, text) {\n    if (typeof children === 'string') {\n        text = children\n        children = []\n    }\n    return new VNode(tag, children, text)\n}\n```\n\n```\nlet vNode = v('div', [\n    v('p', [\n        v('span', [v('#text', 'Ada')])\n    ]),\n    v('span', [v('#text', 'shuai')])\n])\nconst root = document.querySelector('#root')\nroot.appendChild(vNode.render())\n```\n\n通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中\n![](https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了**\n\n```\nfunction patchElement(parent, newVNode, oldVNode, index = 0) {\n    if (!oldVNode) {\n        parent.appendChild(newVNode.render())\n    } else if (!newVNode) {\n        parent.removeChild(parent.childNodes[index])\n    } else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) {\n        parent.replaceChild(newVNode.render(), parent.childNodes[index])\n    } else {\n        for (let i = 0; i < newVNode.children.length || i < oldVNode.children.length; i++) {\n            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)\n        }\n    }\n}\n```\n\n当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。\n\n整个状态变更的过程如下\n\n```\n// 1. 构建虚拟DOM\nlet vNode = v('div', [\n    v('p', [\n        v('span', [v('#text', 'Ada')])\n    ]),\n    v('span', [v('#text', 'shuai')])\n])\n// 3. 生成新的虚拟DOM\nlet vNode1 = v('div', [\n    v('p', [\n        v('span', [v('#text', 'Ada')])\n    ]),\n    v('span', [v('#text', 'shuai')]),\n    v('p', [v('#text', 'upload')])\n])\n// 2. 通过虚拟DOM构建真正的DOM\nconst root = document.querySelector('#root')\npatchElement(root, vNode)\nvar n = 0\n// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更\ndocument.querySelector('.btn').onclick = function () {\n    if (n % 2 == 0) {\n        patchElement(root, vNode1, vNode)\n    } else {\n        patchElement(root, vNode, vNode1)\n    }\n    n += 1\n}\n```\n\n本文仅供个人学习使用\n\n---\n\n主要参考：[深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)\n","slug":"理解虚拟-DOM","published":1,"updated":"2020-03-28T17:38:17.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8keswzc000zws99su8g38a0","content":"<h1 id=\"DOM-和-Virtual-DOM\"><a href=\"#DOM-和-Virtual-DOM\" class=\"headerlink\" title=\"DOM 和 Virtual DOM\"></a>DOM 和 Virtual DOM</h1><p><strong>DOM：Document Object Model 把文档变成对象的模型<br>在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。<br>问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？<br>你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。<br>方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。<br>在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。</strong></p>\n<p><code>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</code></p>\n<h1 id=\"过程实现\"><a href=\"#过程实现\" class=\"headerlink\" title=\"过程实现\"></a>过程实现</h1><p>文档界面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./v-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个 VNode 类</span><br><span class=\"line\">class VNode &#123;</span><br><span class=\"line\">    constructor(tag, children, text) &#123;</span><br><span class=\"line\">        this.tag = tag</span><br><span class=\"line\">        this.children = children</span><br><span class=\"line\">        this.text = text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123; // render 方法，创建子元素</span><br><span class=\"line\">        if (this.tag === &apos;#text&apos;) &#123;</span><br><span class=\"line\">            return document.createTextNode(this.text)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let el = document.createElement(this.tag)</span><br><span class=\"line\">        this.children.forEach(vChild =&gt; &#123;</span><br><span class=\"line\">            el.appendChild(vChild.render())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return el</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// v 构造函数，判断子元素类型</span><br><span class=\"line\">function v(tag, children, text) &#123;</span><br><span class=\"line\">    if (typeof children === &apos;string&apos;) &#123;</span><br><span class=\"line\">        text = children</span><br><span class=\"line\">        children = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new VNode(tag, children, text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let vNode = v(&apos;div&apos;, [</span><br><span class=\"line\">    v(&apos;p&apos;, [</span><br><span class=\"line\">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class=\"line\">])</span><br><span class=\"line\">const root = document.querySelector(&apos;#root&apos;)</span><br><span class=\"line\">root.appendChild(vNode.render())</span><br></pre></td></tr></table></figure>\n<p>通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function patchElement(parent, newVNode, oldVNode, index = 0) &#123;</span><br><span class=\"line\">    if (!oldVNode) &#123;</span><br><span class=\"line\">        parent.appendChild(newVNode.render())</span><br><span class=\"line\">    &#125; else if (!newVNode) &#123;</span><br><span class=\"line\">        parent.removeChild(parent.childNodes[index])</span><br><span class=\"line\">    &#125; else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123;</span><br><span class=\"line\">        parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        for (let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class=\"line\">            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。</p>\n<p>整个状态变更的过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 构建虚拟DOM</span><br><span class=\"line\">let vNode = v(&apos;div&apos;, [</span><br><span class=\"line\">    v(&apos;p&apos;, [</span><br><span class=\"line\">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class=\"line\">])</span><br><span class=\"line\">// 3. 生成新的虚拟DOM</span><br><span class=\"line\">let vNode1 = v(&apos;div&apos;, [</span><br><span class=\"line\">    v(&apos;p&apos;, [</span><br><span class=\"line\">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)]),</span><br><span class=\"line\">    v(&apos;p&apos;, [v(&apos;#text&apos;, &apos;upload&apos;)])</span><br><span class=\"line\">])</span><br><span class=\"line\">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class=\"line\">const root = document.querySelector(&apos;#root&apos;)</span><br><span class=\"line\">patchElement(root, vNode)</span><br><span class=\"line\">var n = 0</span><br><span class=\"line\">// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更</span><br><span class=\"line\">document.querySelector(&apos;.btn&apos;).onclick = function () &#123;</span><br><span class=\"line\">    if (n % 2 == 0) &#123;</span><br><span class=\"line\">        patchElement(root, vNode1, vNode)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        patchElement(root, vNode, vNode1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    n += 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本文仅供个人学习使用</p>\n<hr>\n<p>主要参考：<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DOM-和-Virtual-DOM\"><a href=\"#DOM-和-Virtual-DOM\" class=\"headerlink\" title=\"DOM 和 Virtual DOM\"></a>DOM 和 Virtual DOM</h1><p><strong>DOM：Document Object Model 把文档变成对象的模型<br>在没有 DOM 之前，JavaScript 想要操作页面（文档）内的元素比较麻烦，于是有了 DOM API 把文档变成对象的模型，可以通过操作这些 API，直接操作元素，而不需要经过麻烦的遍历等基本操作。有了 DOM 写代码的人是舒服了（当然我们知道 DOM 也比较麻烦），但是事实上它的速度自然没有原生 js 的对象来得快。<br>问题：在需要操作大量页面元素的时候，每当发生更改，有什么办法能够快速生成新页面？<br>你可以很快想到用模版引擎重新渲染整个视图，而这样会产生很多问题，首要问题就是慢。DOM 内部含有大量数据结构，而我们有时只对其中一部分元素内容进行增删改查，但却需要对整个页面进行重复渲染。<br>方法：通过创建与 DOM 的数据结构映射的 Virtual DOM 虚拟数据结构，我们只操作虚拟数据结构，先比较虚拟 DOM 的异同，再将最终操作结果反应到 真实 DOM 中。<br>在整个过程中，DOM 只操作了一次，其他改变的操作，我们都通过操作虚拟 DOM：当页面元素需要发生变化，原本我们需要通过 DOM 操作，重新渲染页面，而现在，我们只需要操作虚拟 DOM ，由虚拟 DOM 对比之前操作，把页面变化部分反馈给 DOM，此时 DOM 只需要渲染变化的一部分，不用再次渲染整个页面，大大提高效率和性能。</strong></p>\n<p><code>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</code></p>\n<h1 id=\"过程实现\"><a href=\"#过程实现\" class=\"headerlink\" title=\"过程实现\"></a>过程实现</h1><p>文档界面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./v-dom.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个 VNode 类</span><br><span class=\"line\">class VNode &#123;</span><br><span class=\"line\">    constructor(tag, children, text) &#123;</span><br><span class=\"line\">        this.tag = tag</span><br><span class=\"line\">        this.children = children</span><br><span class=\"line\">        this.text = text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123; // render 方法，创建子元素</span><br><span class=\"line\">        if (this.tag === &apos;#text&apos;) &#123;</span><br><span class=\"line\">            return document.createTextNode(this.text)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let el = document.createElement(this.tag)</span><br><span class=\"line\">        this.children.forEach(vChild =&gt; &#123;</span><br><span class=\"line\">            el.appendChild(vChild.render())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        return el</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// v 构造函数，判断子元素类型</span><br><span class=\"line\">function v(tag, children, text) &#123;</span><br><span class=\"line\">    if (typeof children === &apos;string&apos;) &#123;</span><br><span class=\"line\">        text = children</span><br><span class=\"line\">        children = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new VNode(tag, children, text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let vNode = v(&apos;div&apos;, [</span><br><span class=\"line\">    v(&apos;p&apos;, [</span><br><span class=\"line\">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class=\"line\">])</span><br><span class=\"line\">const root = document.querySelector(&apos;#root&apos;)</span><br><span class=\"line\">root.appendChild(vNode.render())</span><br></pre></td></tr></table></figure>\n<p>通过上述代码，我们构建了一个简单的虚拟 DOM 树，可以通过它构建一个真正的 DOM 树，渲染到页面中<br><img src=\"https://upload-images.jianshu.io/upload_images/7094266-762ab26eabd2e04e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>精髓：通过对比新旧虚拟 DOM 树，其原生对象判断页面增删改查了哪些部分，而后单独渲染差异部分。没有这个 patchElement 就失去了虚拟 DOM 的意义，和原始 DOM 效果无异了</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function patchElement(parent, newVNode, oldVNode, index = 0) &#123;</span><br><span class=\"line\">    if (!oldVNode) &#123;</span><br><span class=\"line\">        parent.appendChild(newVNode.render())</span><br><span class=\"line\">    &#125; else if (!newVNode) &#123;</span><br><span class=\"line\">        parent.removeChild(parent.childNodes[index])</span><br><span class=\"line\">    &#125; else if (newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123;</span><br><span class=\"line\">        parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        for (let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class=\"line\">            patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，上述只是简单的算法判断逻辑，但是也能让我们理解其相应过程和原理。</p>\n<p>整个状态变更的过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 构建虚拟DOM</span><br><span class=\"line\">let vNode = v(&apos;div&apos;, [</span><br><span class=\"line\">    v(&apos;p&apos;, [</span><br><span class=\"line\">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)])</span><br><span class=\"line\">])</span><br><span class=\"line\">// 3. 生成新的虚拟DOM</span><br><span class=\"line\">let vNode1 = v(&apos;div&apos;, [</span><br><span class=\"line\">    v(&apos;p&apos;, [</span><br><span class=\"line\">        v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;Ada&apos;)])</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    v(&apos;span&apos;, [v(&apos;#text&apos;, &apos;shuai&apos;)]),</span><br><span class=\"line\">    v(&apos;p&apos;, [v(&apos;#text&apos;, &apos;upload&apos;)])</span><br><span class=\"line\">])</span><br><span class=\"line\">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class=\"line\">const root = document.querySelector(&apos;#root&apos;)</span><br><span class=\"line\">patchElement(root, vNode)</span><br><span class=\"line\">var n = 0</span><br><span class=\"line\">// 4. 比较两次虚拟DOM树的不同，在真正的DOM元素上应用变更</span><br><span class=\"line\">document.querySelector(&apos;.btn&apos;).onclick = function () &#123;</span><br><span class=\"line\">    if (n % 2 == 0) &#123;</span><br><span class=\"line\">        patchElement(root, vNode1, vNode)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        patchElement(root, vNode, vNode1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    n += 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本文仅供个人学习使用</p>\n<hr>\n<p>主要参考：<a href=\"https://github.com/livoras/blog/issues/13\">深度剖析：如何实现一个 Virtual DOM 算法</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck8keswyc0001ws99isv7oria","tag_id":"ck8kesx010010ws996sukdink","_id":"ck8kesx0x001yws99xjv3yf7h"},{"post_id":"ck8keswyh0003ws999z0r81cf","tag_id":"ck8kesx0a0011ws99xv6f6inm","_id":"ck8kesx0y001zws99kx2jdfu7"},{"post_id":"ck8keswyi0004ws99yfyssdvp","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx0y0020ws99erk8zo8e"},{"post_id":"ck8keswyj0005ws996dt0zv8s","tag_id":"ck8kesx0a0011ws99xv6f6inm","_id":"ck8kesx0y0021ws99hu9tfwgk"},{"post_id":"ck8keswyk0006ws990euxzjv4","tag_id":"ck8kesx0e0014ws99h1kb41e4","_id":"ck8kesx0y0022ws99jk56svp0"},{"post_id":"ck8keswyl0007ws99sc175wpz","tag_id":"ck8kesx0f0015ws99ux6jyzz6","_id":"ck8kesx0z0023ws99ijxj3ud3"},{"post_id":"ck8keswym0008ws99bm6lkykf","tag_id":"ck8kesx0e0014ws99h1kb41e4","_id":"ck8kesx0z0024ws997jjfmgn9"},{"post_id":"ck8keswyn0009ws99snftixoh","tag_id":"ck8kesx010010ws996sukdink","_id":"ck8kesx0z0025ws99tfxza7de"},{"post_id":"ck8keswyo000aws99flojxh27","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx0z0026ws99b0dgxa8j"},{"post_id":"ck8keswyq000bws99v1m90kcu","tag_id":"ck8kesx0h0019ws99jcferb8u","_id":"ck8kesx0z0027ws99gtjh0syi"},{"post_id":"ck8keswys000cws996joe0apy","tag_id":"ck8kesx0i001aws99lc57vpe8","_id":"ck8kesx0z0028ws99tuw2sn7r"},{"post_id":"ck8keswyt000dws99k297k38v","tag_id":"ck8kesx0i001aws99lc57vpe8","_id":"ck8kesx100029ws99pxm54cfo"},{"post_id":"ck8keswyu000ews99qlxe0zur","tag_id":"ck8kesx0j001cws99stxfmdyw","_id":"ck8kesx10002aws9978nym3h7"},{"post_id":"ck8keswyv000fws996qgfl6hh","tag_id":"ck8kesx0j001cws99stxfmdyw","_id":"ck8kesx10002bws99483c4kj3"},{"post_id":"ck8keswyw000gws992qzx0e13","tag_id":"ck8kesx0k001ews99zd1bhy5b","_id":"ck8kesx10002cws99372s8pmo"},{"post_id":"ck8keswyx000hws99b2f79j4n","tag_id":"ck8kesx0i001aws99lc57vpe8","_id":"ck8kesx10002dws99ty4em6j8"},{"post_id":"ck8keswyy000iws99n7bxqb8f","tag_id":"ck8kesx0l001gws99g42oside","_id":"ck8kesx10002ews99kxw33jje"},{"post_id":"ck8keswyz000jws99ikzzseh9","tag_id":"ck8kesx0l001hws99eujkwya0","_id":"ck8kesx10002fws99vfml6lbq"},{"post_id":"ck8keswz0000kws99rwtrdwdq","tag_id":"ck8kesx0m001iws991vdr0q1w","_id":"ck8kesx11002gws99hq7lwa12"},{"post_id":"ck8keswz1000lws99fdraodnw","tag_id":"ck8kesx0l001hws99eujkwya0","_id":"ck8kesx11002hws99gqtwlurj"},{"post_id":"ck8keswz1000mws99xxlc7g9t","tag_id":"ck8kesx0n001kws99ydc1xi3a","_id":"ck8kesx11002iws9942unum24"},{"post_id":"ck8keswz2000nws99ggw9neod","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx11002jws99on18hspl"},{"post_id":"ck8keswz3000ows99cma38gb8","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx11002kws99kzllgyx6"},{"post_id":"ck8keswz4000pws9988jn65x1","tag_id":"ck8kesx0a0011ws99xv6f6inm","_id":"ck8kesx11002lws99tko0z7jx"},{"post_id":"ck8keswz5000qws99mgxh4ows","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx11002mws99ruqqmdcy"},{"post_id":"ck8keswz5000rws9990w4u6g2","tag_id":"ck8kesx0l001gws99g42oside","_id":"ck8kesx11002nws99oi1aog4x"},{"post_id":"ck8keswz6000sws99u3t830bi","tag_id":"ck8kesx010010ws996sukdink","_id":"ck8kesx12002ows99ycn3nvrd"},{"post_id":"ck8keswz7000tws99tpnuozum","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx12002pws99fug2u5vy"},{"post_id":"ck8keswz8000uws99xancotzq","tag_id":"ck8kesx0b0012ws99l27lh9gz","_id":"ck8kesx12002qws9948b9tr7o"},{"post_id":"ck8keswz9000vws99dyknvqaz","tag_id":"ck8kesx010010ws996sukdink","_id":"ck8kesx13002rws996svl1y5g"},{"post_id":"ck8keswza000wws99inbk7tjg","tag_id":"ck8kesx010010ws996sukdink","_id":"ck8kesx13002sws99szjdoqb7"},{"post_id":"ck8keswza000xws99wpb8otxp","tag_id":"ck8kesx0t001vws99zv6u1mvt","_id":"ck8kesx14002tws99gyek653c"},{"post_id":"ck8keswzb000yws99rzgk0oe6","tag_id":"ck8kesx010010ws996sukdink","_id":"ck8kesx14002uws991lh6mm57"},{"post_id":"ck8keswzc000zws99su8g38a0","tag_id":"ck8kesx0i001aws99lc57vpe8","_id":"ck8kesx14002vws993epq6pin"}],"Tag":[{"name":"HTTP","_id":"ck8kesx010010ws996sukdink"},{"name":"CSS","_id":"ck8kesx0a0011ws99xv6f6inm"},{"name":"JavaScript","_id":"ck8kesx0b0012ws99l27lh9gz"},{"name":"HTML","_id":"ck8kesx0e0014ws99h1kb41e4"},{"name":"Flutter","_id":"ck8kesx0f0015ws99ux6jyzz6"},{"name":"算法","_id":"ck8kesx0h0019ws99jcferb8u"},{"name":"设计模式","_id":"ck8kesx0i001aws99lc57vpe8"},{"name":"Vue","_id":"ck8kesx0j001cws99stxfmdyw"},{"name":"Node.js","_id":"ck8kesx0k001ews99zd1bhy5b"},{"name":"git","_id":"ck8kesx0l001gws99g42oside"},{"name":"linux","_id":"ck8kesx0l001hws99eujkwya0"},{"name":"命令行","_id":"ck8kesx0m001iws991vdr0q1w"},{"name":"Web 性能优化","_id":"ck8kesx0n001kws99ydc1xi3a"},{"name":"RegExp","_id":"ck8kesx0t001vws99zv6u1mvt"}]}}